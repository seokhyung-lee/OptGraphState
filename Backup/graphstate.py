import time
import os
import sys

import networkx as nx

from optgraphstate.graph_tools import *
from optgraphstate.visualization import *

try:
    import parmap
except ModuleNotFoundError:
    pass


def _max_seed():
    return 2**32


class GraphState:
    graph: ig.Graph  #: Graph of the graph state to investigate.
    graph_info: set  #: Information of the graph in `GraphState.graph`. It is not empty only when the graph is initialized by using the parameters `shape` and `prms`.
    unraveled_graph: ig.Graph  #: Unraveled graph generated by unraveling the original graph (in `GraphState.graph`). It is `None` before the unraveled graph is created.
    fusion_network: ig.Graph  #: Fuson network constructed from the unraveled graph (in `GraphState.unraveled_graph`) or the original graph (in `GraphState.graph`). It is `None` before the fusion network is created.
    unraveled_bcss: set  #: Unraveled bipartitely-complete subgraphs (BCSs). It is empty before unraveling the graph.
    unraveled_cliques: set  #: Unraveled cliques. It is empty before unraveling the graph.
    data: dict  #: Any data obtained during unraveling the graph, constructing the fusion network, and calculating the resource overhead.

    def __init__(self,
                 graph=None,
                 edges=None,
                 shape=None,
                 prms=None,
                 cliffords=None,
                 unraveled_graph=None,
                 fusion_network=None):
        """
        Class for calculating and optimizing the resource overhead of the
        fusion-based generation of a graph state.

        The graph of the concerned graph state can be given by the following
        three ways:

        1. Given explicitly by `igraph.Graph` or `networkx.Graph`.
        2. Given by a list of edges.
        3. Chosen among predefined graphs.

        Parameters
        ----------
        graph : None or igraph.Graph or networkx.Graph (default: None)
            Graph of the concerned graph.<br>
            If it is given, `edges`, `shape`, and `prms` are ignored. If it
            is `networkx.Graph`, it is internally converted to `igraph.Graph`.

        edges : None or list of 2-tuple of int (default: None)
            List of edges that form the concerned graph.<br>
            Each integer in the tuples indicates a vertex label. If it is
            given and `graph` is `None`, `shape` and `prms` are ignored.

        shape : None or str (default: None)
            Shape of the concerned graph chosen among predefined graphs.<br>
            One of `[None, 'random', 'complete', 'star', 'linear', 'cycle',
            'lattice', 'tree', 'rhg', 'repeater', 'parity_encoding', 'ptqc']`.

            - `shape='random'` : Random graph for fixed numbers of vertices
            and edges, sampled by the Erd√∂s-Renyi model.
                - `prms[0]` <`int`> : Number of vertices.
                - `prms[1]` <`int`> : Number of edges.
                - [Optional] `prms[2]` <`None` or `int`> : Random seed. If
                `None`, the current system time is used as the seed. If not
                given, the random number generator is not initialized.
            - `shape='complete'`, `'star'`, `'linear'`, or `'cycle'` :
            Complete, star, linear, or cycle graph, respectively.
                - `prms[0]` <`int`> : Number of vertices.
            - `shape='lattice'` : Lattice graph.
                - `prms` <`tuple` of `int`> : Numbers of repeated vertices
                along the axes. The dimension of the lattice is
                automatically set as `len(prms)`.
            - `shape='tree'` : Tree graph where all branches in each
            generation have an equal number of children.
                - `prms[0]` <`int`> : Degree of the root vertex.
                - `prms[i]` (<`int`>, i >= 1) : Number of the children of each
                `i`th-generation branch.
            - `shape='rhg'` : Raussendorf-Harrington-Goyal lattice with primal
            boundaries only.
                - `prms[0]`, `prms[1]`, `prms[2]` <`int`> : Size of the lattice
                along the three axes in the unit of a cell.
            - `shape='repeater'` : Repeater graph with 4m vertices.
                - `prms[0]` <`int`> : Parameter m.
            - `shape='parity_encoding'` : (n, m) parity-encoded graph.
                - `prms[0]` <`igraph.Graph`> : Logical-level graph. Can be
                generated with python-igraph library directly or from the
                function `get_graph_from_edges()` or `get_sample_graph`.
                - `prms[1]`, `prms[2]` <`int`> : Parameters n and m of the
                parity encoding.
            - `shape='ptqc'` : Microcluster for parity-encoding-based
            topological quantum computing protocol.
                - `prms[0]`, `prms[1]` <`int`> : Parameter n and m of the
                parity encoding.
                - `prms[2]` <`bool`> : Whether the H-configuration is
                HIC (`True`) or HIS (`False`).
                - `prms[3]` <`bool`> : Whether the microcluster is
                central (`True`) or side (`False`) one.

        prms : None or tuple or int (default: None)
            Parameters for a predefined graph.<br>
            See the description for parameter `shape`. If only one parameter
            is required, it can be given as a number, not a tuple.

        cliffords : None or list of str (default: None)
            Local clifford operations applied on the qubits of the graph
            state.<br>
            If it is `None`, no Clifford operations are applied on the qubits.<br>
            If it is a `list` of `str`, its length should be equal to the
            number of vertices in the graph. Its i-th element indicates the
            Clifford operation applied on the i-th qubit. For example,
            if it is `'H'`, it means that a Hadamard gate is applied on the
            qubit. If it is `'H-S-Z'`, it means that Hadamard, phase,
            and Z gates are applied in order.

        unraveled_graph : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven unraveled graph.<br>
            The code does not check the validity of the given unraveled graph.
            If it is `networkx.Graph`, it is internally converted to
            `igraph.Graph`.

        fusion_network : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven fusion network.<br>
            The code does not check the validity of the given fusion network.
            If it is `networkx.Graph`, it is internally converted to
            `igraph.Graph`.
        """

        def convert_type(g, varname):
            if g is None:
                return None
            elif isinstance(g, ig.Graph):
                return g
            elif isinstance(g, nx.Graph):
                return ig.Graph.from_networkx(g)
            else:
                raise TypeError(f'Parameter {varname} should be igraph.Graph '
                                f'or networkx.Graph.')

        if graph is not None:
            self.graph = convert_type(graph, 'graph')
            self.graph_info = None

        elif edges is not None:
            self.graph = ig.Graph(edges=edges)
            self.graph_info = None

        elif shape is not None:
            try:
                prms[0]
            except TypeError:
                prms = (prms,)

            self.graph, self.graph_info = get_sample_graph(shape, *prms)

        else:
            raise ValueError(
                "At least one of graph, edges, and shape should be given.")

        if self.graph_info is None:
            self.graph_info = {
                'num_vertices': self.graph.vcount(),
                'num_edges': self.graph.ecount()}

        self.graph.vs['name'] = [str(vid) for vid in
                                 range(self.graph.vcount())]

        if cliffords is not None and edges is None:
            self.graph.vs['clifford'] = cliffords

        self.unraveled_graph = convert_type(unraveled_graph, 'unraveled_graph')
        self.unraveled_bcss = set()
        self.unraveled_cliques = set()

        self.fusion_network = convert_type(fusion_network, 'fusion_network')

        self.data = {}

    def initialize(self):
        """
        Initialize the created unraveled graph and fusion network and the
        calculation data.
        """
        self.unraveled_graph = None
        self.fusion_network = None
        self.unraveled_bcss = set()
        self.unraveled_cliques = set()
        self.data = {}

    def unravel_graph(self,
                      unravel_bcs_first='random',
                      plot=False,
                      verbose=False):
        """
        Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

        The unraveled graph is saved in `self.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        unravel_bcs_first : one of [True, False, 'random'] (default: 'random')
            - `True`: BCSs are unraveled first, then clqiues are
            unraveled.
            - `False`: cliques are unraveled first, then BCSs are
            unraveled.<br>
            - `'random'`: the order is randomly chosen.

        plot : bool (default: False)
            Whether to plot the unraveled graph after unraveling.

        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Data on unraveled BCSs, which is identical with
            `GraphState.unraveled_bcss`.<br>
            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.

        cliques : list of list of set of str
            Data on unraveled cliques, which is identical with
            `GraphState.unraveled_cliques`.<br>
            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        """

        if unravel_bcs_first == 'random':
            unravel_bcs_first = np.random.choice([True, False])

        if unravel_bcs_first:
            bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)
            cliques = self.unravel_cliques(verbose=verbose)
        else:
            cliques = self.unravel_cliques(verbose=verbose)
            bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)

        if plot or verbose:
            if verbose:
                print('[Final]')
            self.plot_graph(unraveled=True)
            plt.show()

        self.data['unravel'] = True
        self.data['unravel_bcs_first'] = unravel_bcs_first

        return self.unraveled_graph, bcss, cliques

    def unravel_bipartitely_complete_subgraphs(self, verbose=False):
        """
        Unravel bipartitely-complete subgraphs (BCSs) of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Data on unraveled BCSs.<br>
            See the description of `GraphState.unravel_graph()`.
        """

        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if 'ext_fusion' not in vs_attrs:
            graph.vs['ext_fusion'] = None
        if 'clifford' not in vs_attrs:
            graph.vs['clifford'] = None

        unraveled_bcss = []

        new_vertex_name = graph.vcount()

        while True:
            # Repeat until there are no bipartitely-complete subgraphs
            bcs_exist = False
            while True:
                bcss = find_nonoverlapping_bcs(graph, get_name=True)
                if bcss:
                    bcs_exist = True
                else:
                    break

                unraveled_bcss.append(bcss)
                eids_to_remove = []
                for part1, part2 in bcss:
                    if verbose:
                        graph.delete_edges(eids_to_remove)
                        eids_to_remove.clear()
                        print('bcs to unravel =', part1, '&', part2)
                        vertex_color = []
                        for v in graph.vs:
                            if v['name'] in part1:
                                vertex_color.append('orange')
                            elif v['name'] in part2:
                                vertex_color.append('blue')
                            else:
                                vertex_color.append('white')
                        self.plot_graph(unraveled=True,
                                        vertex_color=vertex_color)
                        plt.show()

                    eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                           vname1, vname2 in
                                           itertools.product(part1, part2)])

                    vname1 = str(new_vertex_name)
                    vname2 = str(new_vertex_name + 1)
                    new_v1 = graph.add_vertex(name=vname1,
                                              ext_fusion=vname2,
                                              clifford=None)
                    new_v2 = graph.add_vertex(name=vname2,
                                              ext_fusion=vname1,
                                              clifford=None)
                    new_vertex_name += 2

                    graph.add_edges(itertools.product([new_v1], part1))
                    graph.add_edges(itertools.product([new_v2], part2))

                graph.delete_edges(eids_to_remove)

            if not bcs_exist:
                break

        self.unraveled_bcss = unraveled_bcss

        return unraveled_bcss

    def unravel_cliques(self, verbose=False):
        """
        Unravel cliques of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        cliques : list of list of set of str
            Data on unraveled cliques.<br>
            See the description of `GraphState.unravel_graph()`.
        """
        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if 'ext_fusion' not in vs_attrs:
            graph.vs['ext_fusion'] = None
        if 'clifford' not in vs_attrs:
            graph.vs['clifford'] = None

        unraveled_cliques = []

        def apply_clifford(v, clifford):
            org_clifford = v['clifford']
            if org_clifford is None:
                new_clifford = clifford
            else:
                new_clifford = '-'.join([clifford, org_clifford])
            v['clifford'] = new_clifford

        while True:
            cliques = find_nonoverlapping_cliques(graph, get_name=True)

            if not cliques:
                break

            unraveled_cliques.append(cliques)

            for clique in cliques:
                if verbose:
                    print('clique to unravel =', clique)
                    vertex_color = ['orange' if vname in clique else 'white'
                                    for vname in graph.vs['name']]
                    self.plot_graph(unraveled=True, vertex_color=vertex_color)
                    plt.show()
                clique = list(clique)
                clique_size = len(clique)

                # Choose a vertex to apply LC
                degrees = graph.degree(clique)
                min_degree = min(degrees)
                if min_degree == clique_size - 1:
                    # There exists a vertex in the clique that doesn't have
                    # outer edges
                    vname_LC = [vname for vname, deg in zip(clique, degrees) if
                                deg == min_degree]
                    need_to_separate = False
                else:
                    vname_LC = clique
                    need_to_separate = True

                if len(vname_LC) > 1:
                    vname_LC = np.random.choice(vname_LC)
                else:
                    vname_LC = vname_LC[0]
                v_LC = graph.vs.find(name=vname_LC)

                # Separate the edges (E) incident to v_LC outside the clique
                # from v_LC
                eids_to_delete = []
                if need_to_separate:
                    # Vertex connected with E
                    new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=v_LC['clifford'],
                                              ext_fusion=v_LC['ext_fusion'])

                    # Vertex having an external fusion with v_LC
                    new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=None,
                                              ext_fusion=v_LC['name'])

                    graph.add_edge(new_v1, new_v2)

                    ngh_vids = graph.neighbors(vname_LC)
                    for ngh_vid in ngh_vids:
                        if graph.vs[ngh_vid]['name'] not in clique:
                            graph.add_edge(ngh_vid, new_v1)
                            eids_to_delete.append(graph.get_eid(vname_LC,
                                                                ngh_vid))

                    vname_org_ext_fusion = v_LC['ext_fusion']
                    if vname_org_ext_fusion is not None:
                        v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                        v_org_ext_fusion['ext_fusion'] = new_v1['name']

                    v_LC['ext_fusion'] = new_v2['name']

                # Apply LC
                adj_vnames = set(clique) - {vname_LC}
                apply_clifford(v_LC, 'R_X')
                for adj_vname in adj_vnames:
                    adj_v = graph.vs.find(name=adj_vname)
                    apply_clifford(adj_v, 'R_Z')

                new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                      vname1, vname2 in
                                      itertools.combinations(adj_vnames, r=2)]
                eids_to_delete.extend(new_eids_to_delete)
                graph.delete_edges(eids_to_delete)

        self.unraveled_cliques = unraveled_cliques

        return unraveled_cliques

    def build_fusion_network(self,
                             use_unraveled_graph=True,
                             plot=False,
                             verbose=False):
        """
        Build a fusion network from the graph.

        The constructed fusion network is saved in `GraphState.fusion_network` as
        `igraph.Graph`.

        Parameters
        ----------
        use_unraveled_graph : bool (default: True)
            Whether to use the unraveled graph (in `GraphState.unraveled_graph`) or
            the original graph (in `GraphState.graph`) for building a fusion network.

        plot : bool (default: False)
            Whether to plot the fusion network after building it.

        verbose : bool (default: False)
            Whether to print logs.
        """

        graph = self.unraveled_graph if use_unraveled_graph else self.graph
        if graph is None:
            raise ValueError("No unraveled qubit graph created.")

        # Fusion network
        network = ig.Graph()
        self.fusion_network = network
        nodes_corr = {}

        # Links inside star graphs
        for v in graph.vs:
            num_internal_nodes = v.degree() - 1
            vname_xrot = v['name']
            if num_internal_nodes >= 1:

                # Add nodes
                nid_init = network.vcount()
                seed = np.random.randint(0, num_internal_nodes)
                node_names = [vname_xrot if i == 0 else f'{vname_xrot}-{i}' for
                              i in itertools.chain(range(seed, -1, -1),
                                                   range(seed + 1,
                                                         num_internal_nodes))]
                attr = {
                    'name': node_names,
                    'seed': [True if i == seed else False for i in
                             range(num_internal_nodes)],
                    'clifford_root': None,
                    # Clifford gate applied on the root qubit
                    'clifford_leaves': None
                    # Clifford gate applied on the leaf qubits
                }
                network.add_vertices(num_internal_nodes, attributes=attr)
                nodes_corr[vname_xrot] = network.vs[
                                         nid_init:nid_init + num_internal_nodes]

                if num_internal_nodes >= 2:
                    # Connect internal links
                    links = [(nid, nid + 1) for nid in range(nid_init,
                                                             nid_init + num_internal_nodes - 1)]
                    attr = {  # One of RR, RL, and LL, which respectively means
                        # that a fusion is performed on two roots,
                        # one root and one leaf, and two leaves of GHZ-3
                        # states.
                        'kind': "RL",  # Root node name, if kind == 'RL'
                        'root_node': [
                            node_names[i + 1] if i < seed else node_names[i]
                            for i in range(num_internal_nodes - 1)]}
                    network.add_edges(links, attributes=attr)

        # Links between star graphs
        for e in graph.es:
            vs = [e.source_vertex, e.target_vertex]
            deg_vs = graph.degree(vs)

            if deg_vs[0] > 1 and deg_vs[1] > 1:
                nodes_to_connect = []
                for v in vs:
                    vname = v['name']
                    nodes = nodes_corr[
                        vname].select(lambda node: node.degree() < (
                        2 if node['seed'] else 3))
                    nodes_to_connect.append(np.random.choice(nodes))
                network.add_edge(*nodes_to_connect,
                                 kind='LL',
                                 root_node=None, )

        if verbose:
            print("Fusion network of the unraveled graph:")
            self.plot_fusion_network()
            plt.show()

        # Set of seed node names where root vertices are connected by
        # external fusions.
        root_connected = set()
        is_node_not_full = lambda node: node.degree() < (
            2 if node['seed'] and (node['name'] not in root_connected) else 3)

        def get_nodes_containing_vertex(vname):
            try:
                node = nodes_corr[vname].find(name=vname)
                root = True
            except KeyError:
                root_name = graph.vs[graph.neighbors(vname)[0]]['name']
                nodes = nodes_corr[root_name].select(is_node_not_full)
                node = np.random.choice(nodes)
                root = False

            return node, root

        # Clifford operations
        vs_attrs = graph.vs.attributes()
        if 'clifford' in vs_attrs:
            for v_cl in graph.vs.select(clifford_ne=None):
                vname = v_cl['name']
                node, root = get_nodes_containing_vertex(vname)
                cl = v_cl['clifford']

                if root:
                    node['clifford_root'] = cl

                else:
                    key = v_cl['ext_fusion']
                    if key is None:
                        key = f'final_{v_cl["name"]}'

                    clifford_leaves = node['clifford_leaves']
                    try:
                        clifford_leaves[key] = cl
                    except TypeError:
                        node['clifford_leaves'] = {key: cl}

        if verbose:
            print("Apply Clifford operations:")
            self.plot_fusion_network()
            plt.show()

        # Links by external fusions
        if 'ext_fusion' in vs_attrs:
            done = set()
            for v1 in graph.vs.select(ext_fusion_ne=None):

                vname1 = v1['name']
                if vname1 in done:
                    continue
                vname2 = v1['ext_fusion']
                done.add(vname2)

                node1, root1 = get_nodes_containing_vertex(vname1)
                node2, root2 = get_nodes_containing_vertex(vname2)
                if root1 and root2:
                    kind = 'RR'
                    root_node = None
                    root_connected.add(node1['name'])
                    root_connected.add(node2['name'])
                elif not root1 and not root2:
                    kind = 'LL'
                    root_node = None
                else:
                    kind = 'RL'
                    root_node = node1['name'] if root1 else node2['name']
                    root_connected.add(root_node)
                network.add_edge(node1, node2, kind=kind, root_node=root_node)

        network.es['name'] = [str(eid) for eid in range(network.ecount())]

        self.fusion_network = network

        if plot:
            print("Final:")
            self.plot_fusion_network()
            plt.show()

    def _contract_edge(self, fusion_network, ename_to_merge):
        ename_to_merge = str(ename_to_merge)

        e_to_merge = fusion_network.es.find(name=ename_to_merge)
        v_merged, v_removed = e_to_merge.source_vertex, e_to_merge.target_vertex
        enames_updated_weight = []

        if v_merged.degree() < v_removed.degree():
            v_merged, v_removed = v_removed, v_merged

        vname_merged = v_merged['name']
        vname_removed = v_removed['name']

        v_merged['weight'] = e_to_merge['weight']
        v_merged['step'] = max(v_merged['step'], v_removed['step']) + 1

        assert vname_merged != vname_removed

        eids_to_delete = list(set(fusion_network.incident(v_removed)))
        v_removed['on'] = False

        for eid_connected in eids_to_delete:
            e_connected = fusion_network.es[eid_connected]
            ename_connected = e_connected['name']
            if ename_connected != ename_to_merge:
                enames_updated_weight.append(ename_connected)
                vs_ngh = e_connected.source_vertex, e_connected.target_vertex
                new_edge = [
                    v_merged if v_ngh['name'] == vname_removed else v_ngh for
                    v_ngh in vs_ngh]
                if new_edge[0] == new_edge[1]:  # If a loop is formed
                    v_vrt = fusion_network.add_vertex(name=f'vrt_{fusion_network.vcount()}',
                                                      weight=0,
                                                      step=0)
                    new_edge = [v_merged, v_vrt]

                fusion_network.add_edge(*new_edge,
                                        name=ename_connected,
                                        weight=None, )

        fusion_network.delete_edges(eids_to_delete)

        p_succ = fusion_network['p_succ']
        for eid_connected in list(set(fusion_network.incident(v_merged))):
            e_connected = fusion_network.es[eid_connected]
            v_ngh1, v_ngh2 = e_connected.source_vertex, e_connected.target_vertex

            assert v_ngh1 != v_ngh2
            new_weight = (v_ngh1['weight'] + v_ngh2['weight']) / p_succ
            e_connected['weight'] = new_weight

        self.fusion_network.es.find(name=ename_to_merge)['step'] = v_merged[
            'step']

        return enames_updated_weight

    def calculate_overhead(self,
                           p_succ=0.5,
                           strategy='weight_and_matching',
                           fusion_order=None,
                           get_fusion_order=False, ):
        """
        Calculate the resource overhead from the fusion network.

        The resulting data is saved in `GraphState.data`.

        Parameters
        ----------
        p_succ : float (default: 0.5)
            Success probability of a fusion.

        strategy: str, one of ['weight', 'matching', 'weight_and_matching', 'random'] (default: 'weight_and_matching')
            Strategy for determining the edge to contract in each step.

            - `'weight'`: Contract a random one among the edges with the
            smallest weight.
            - `'matching'`: Contract an edge in a maximum matching.
            - `'weight_and_matching'`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `'random'`: Contract a random edge.

        fusion_order : None or list of {int or str} (default: None)
            Fusion order given explicitly as vertex names.<br>
            If it is not `None`, parameter `strategy` is ignored.

        get_fusion_order : bool (default: False)
            Whether to include the determined fusion order in the returned
            data.

        Returns
        -------
        data : dict
            Outcomes of the calculation, which is a shallow copy of
            `GraphState.data`.<br>
            The calculated overhead and number of steps can be obtained from
            `data['overhead']` and `data['step']`, respectively.
        """

        if self.fusion_network is None:
            raise ValueError("No fusion network created")

        # Trivial cases
        node_num = self.fusion_network.vcount()
        if node_num == 0:
            self.data['overhead'] = 0
            self.data['step'] = 0
            return self.data
        elif node_num == 1:
            self.data['overhead'] = 1
            self.data['step'] = 0
            return self.data

        if fusion_order is None:
            fusion_order = []
            is_fusion_order_given = False
        else:
            is_fusion_order_given = True

        self.fusion_network.es['step'] = None

        # Initialize intermediate fusion network
        network = self.fusion_network.copy()
        network['p_succ'] = p_succ
        network.vs['weight'] = 1
        network.vs['step'] = 0
        network.vs['on'] = True
        network.es['weight'] = 2 / p_succ
        del network.es['step']

        turn = 0

        # Iterate until no edges remain in the fusion network
        while True:
            if not network.ecount():
                break

            if is_fusion_order_given:
                enames_curr_step = [str(fusion_order[turn])]
                is_parellel = True

            elif strategy == 'weight':
                min_weight = min(network.es['weight'])
                eids_min_weight = network.es.select(weight=min_weight)
                enames_curr_step = eids_min_weight['name']
                is_parellel = len(enames_curr_step) == 1

            # elif strategy == 'betweenness':
            #     eb = np.array(network.edge_betweenness())
            #     min_eb = np.min(eb)
            #     eids_curr_step = np.nonzero(eb == min_eb)[0]
            #     enames_curr_step = [network.es[eid]['name'] for eid in
            #     eids_curr_step]
            #     is_parellel = len(enames_curr_step) == 1
            #
            # elif strategy == 'weight_and_betweenness':
            #     min_weight = min(network.es['weight'])
            #     eids_min_weight = network.es.select(weight=min_weight)
            #     es_min_ovh = eids_min_weight
            #
            #     eb = network.edge_betweenness()
            #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
            #     min_eb = np.min(ebs_min_ovh)
            #     enames_curr_step = [es_min_ovh[i]['name'] for i in
            #     np.nonzero(ebs_min_ovh == min_eb)[0]]
            #     is_parellel = len(enames_curr_step) == 1

            elif 'matching' in strategy:
                if strategy == 'weight_and_matching':
                    min_weight = min(network.es['weight'])
                    es_min_weight = network.es.select(weight=min_weight)
                    subnetwork = network.subgraph_edges(es_min_weight)
                else:
                    subnetwork = network

                subnetwork_nx = subnetwork.to_networkx()
                if isinstance(subnetwork_nx, nx.MultiGraph):
                    subnetwork_nx = nx.Graph(subnetwork_nx)
                matching = nx.max_weight_matching(subnetwork_nx, weight=None)
                enames_curr_step = \
                    subnetwork.es[subnetwork.get_eids(matching)]['name']

                is_parellel = True

            elif strategy == 'random':
                enames_curr_step = [np.random.choice(network.es['name'])]
                is_parellel = True

            else:
                raise ValueError

            recalculated_enames = []

            if get_fusion_order and not is_fusion_order_given:
                fusion_order_curr_step = set()
                fusion_order.append(fusion_order_curr_step)

            while True:
                if not is_parellel:
                    for rec_ename in recalculated_enames:
                        try:
                            enames_curr_step.remove(rec_ename)
                        except ValueError:
                            pass

                if not enames_curr_step:
                    break

                recalculated_enames.clear()

                if is_parellel:
                    ename_to_merge = enames_curr_step.pop()
                else:
                    ename_to_merge = np.random.choice(enames_curr_step)
                    enames_curr_step.remove(ename_to_merge)

                if get_fusion_order:
                    e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                    v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                    fusion_order_curr_step.add((v1['name'], v2['name'],
                                                ename_to_merge))

                enames_updated_weight = self._contract_edge(network,
                                                            ename_to_merge)

                recalculated_enames.extend(enames_updated_weight)

        v_final = network.vs.select(on=True)
        overhead = sum(v_final['weight'])
        step = max(v_final['step'])

        results = {
            'overhead': overhead,
            'step': step,
            'fusion_order_strategy': strategy,
            'p_succ': p_succ}

        if get_fusion_order:
            results['fusion_order'] = fusion_order

        self.data.update(results)

        return self.data.copy()

    def simulate(self,
                 n_iter,
                 p_succ=0.5,
                 mp=False,
                 n_procs=None,
                 get_all_data=False,
                 get_all_graphs=False,
                 get_all_fusion_networks=False,
                 unravel=True,
                 unravel_bcs_first='random',
                 fusion_order_strategy='weight_and_matching',
                 seed='keep',
                 verbose=True,
                 pbar=False,
                 **kwargs):
        """
        Execute the strategy for a fixed number of iterations and obtain the
        best one only (by default).

        Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
        `GraphState.fusion_network` are updated according to the result of the best
        sample.

        Parameters
        ----------
        n_iter : int
            Iteration number.

        p_succ : float (default: 0.5)
            Success probability of a fusion.

        mp : bool (default: False)
            Whether to use multiprocessing for the iterations. Package
            *parmap* should be installed to use it.

        n_procs : None or int (default: None)
            Maximal number of simultaneous processes for multiprocessing.<br>
            If it is `None`, the number of CPUs is used. Ignored when `mp` is
            `False`.

        get_all_data : bool (default: False)
            Whether to obtain the data (overheads, numbers of steps, etc.) from
            all samples or only the best sample.

        get_all_graphs : bool (default: False)
            Whether to obtain the unraveled graphs from all samples or only the
            best sample.

        get_all_fusion_networks : bool (default: False)
            Whether to obtain the fusion networks from all samples or only the
            best sample.

        unravel : bool (default: True)
            Whether to unravel the graph or not.

        unravel_bcs_first : one of [True, False, 'random'] (default: 'random')
            - `True`: BCSs are unraveled first, then clqiues are unraveled.
            - `False`, cliques are unraveled first, then BCSs are unraveled.
            - `'random'`, the order is randomly chosen.

        fusion_order_strategy : one of ['weight', 'matching', 'weight_and_matching', 'random'] (default: `weight_and_matching')
            Strategy for determining the edge to contract in each step.

            - `'weight'`: Contract a random one among the edges with the
            smallest weight.
            - `'matching'`: Contract an edge in a maximum matching.
            - `'weight_and_matching'`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `'random'`: Contract a random edge.

        seed : 'keep' or None or int (default: 'keep')
            Random seed.

            - `'keep'`: The seed is not initialized.
            - `None`: The current time is used as the random seed.
            - `int`: The given number is used as the random seed.

        verbose : bool (default: True)
            Whether to print logs.

        pbar : bool (default: False)
            Whether to show a progress bar.<br>
            Ignored if `mp` is `False`

        kwargs : dict
            Additional keyword arguments for calculating overheads.<br>
            See the description of `GraphState.calculate_overhead()`.

        Returns
        -------
        res : dict
            Result of the iterations.<br>
            By default, only the information of the best sample is given.
        """

        t0 = time.time()

        if seed != 'keep':
            np.random.seed(seed)

        if mp:
            if n_procs is None:
                n_procs = os.cpu_count()
            mp = mp and n_iter >= n_procs

        if not mp:
            if verbose:
                print("Multiprocessing OFF.")
                print(f"Calculating for n_iter = {n_iter}...")

            if n_iter == 1 and seed is not None and seed != 'keep':
                seeds_samples = [seed]
            else:
                seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

            overheads = [] if get_all_data else None
            steps = [] if get_all_data else None
            seeds = [] if get_all_data else None
            unravalled_graphs = [] if get_all_graphs else None
            fusion_networks = [] if get_all_fusion_networks else None

            best_sample = None
            lowest_overhead = None
            for i_sample in range(n_iter):
                seed_sample = seeds_samples[i_sample]
                np.random.seed(seed_sample)

                if unravel:
                    self.unraveled_graph = None
                    try:
                        self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                    except:
                        print('Error occurs during unraveling')
                        print('seed =', seed_sample)
                        raise ValueError

                try:
                    self.build_fusion_network(use_unraveled_graph=unravel)
                except:
                    print('Error occurs during building fusion network')
                    print('seed =', seed_sample)
                    raise ValueError

                try:
                    data_now = self.calculate_overhead(p_succ=p_succ,
                                                       strategy=fusion_order_strategy,
                                                       **kwargs)
                except:
                    print('Error occurs during calculating overhead')
                    print('seed =', seed_sample)
                    raise ValueError

                overhead_now = data_now['overhead']
                step_now = data_now['step']
                self.data['seed'] = seed_sample

                if lowest_overhead is None or overhead_now < lowest_overhead:
                    best_sample = i_sample
                    lowest_overhead = overhead_now
                    best_ogs = self.copy()

                if get_all_data:
                    overheads.append(overhead_now)
                    steps.append(step_now)
                    seeds.append(seed_sample)

                if get_all_graphs:
                    unravalled_graphs.append(self.unraveled_graph)

                if get_all_fusion_networks:
                    fusion_networks.append(self.fusion_network)

            res = {
                'best_overhead': best_ogs.data['overhead'],
                'best_step': best_ogs.data['step'],
                'best_seed': best_ogs.data['seed'],
                'n_iter': n_iter}

            if unravel:
                res['unravel_bcs_first'] = best_ogs.data['unravel_bcs_first']

            if get_all_data or get_all_graphs or get_all_fusion_networks:
                res['best_sample'] = best_sample

                if get_all_data:
                    res['overheads'] = overheads
                    res['steps'] = steps
                    res['seeds'] = seeds

                if get_all_graphs:
                    res['unraveled_graphs'] = unravalled_graphs

                if get_all_fusion_networks:
                    res['fusion_networks'] = fusion_networks

        else:
            if 'parmap' not in sys.modules:
                raise ModuleNotFoundError("Package parmap is not installed.")

            if verbose:
                print(f"Multiprocessing ON: n_procs = {n_procs}")
                print(f"Calculating for n_iter = {n_iter}... ", end='')

            additional_keys = []
            if get_all_data:
                additional_keys.extend(['overheads', 'steps', 'seeds'])
            if get_all_graphs:
                additional_keys.append('unraveled_graphs')
            if get_all_fusion_networks:
                additional_keys.append('fusion_networks')

            left = n_iter % n_procs
            ns_samples = [n_iter // n_procs] * n_procs
            for i in range(left):
                ns_samples[i] += 1

            seeds = np.random.randint(0, _max_seed(), size=n_procs)

            res_procs = parmap.starmap(_simulate_single,
                                       list(zip(ns_samples, seeds)),
                                       self.graph,
                                       p_succ=p_succ,
                                       get_all_data=get_all_data,
                                       get_all_graphs=get_all_graphs,
                                       get_all_fusion_networks=get_all_fusion_networks,
                                       unravel=unravel,
                                       unravel_bcs_first=unravel_bcs_first,
                                       fusion_order_strategy=fusion_order_strategy,
                                       pm_pbar=pbar,
                                       **kwargs)
            best_overheads = [res_each['best_overhead'] for res_each in
                              res_procs]
            best_proc = np.argmin(best_overheads)
            res = res_procs[best_proc]
            res['n_iter'] = n_iter
            best_ogs = res['best_ogs']
            del res['best_ogs']

            if additional_keys:
                res['best_sample'] += sum(ns_samples[:best_proc])

            for key in additional_keys:
                vals = [res_each[key] for res_each in res_procs]
                res[key] = list(itertools.chain(*vals))

        if verbose:
            print(f"Done. Best: {res['best_overhead']:.2f} "
                  f"({time.time() - t0:.2f} s)")

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.unraveled_bcss = best_ogs.unraveled_bcss
        self.unraveled_cliques = best_ogs.unraveled_cliques
        self.data = best_ogs.data

        return res

    def simulate_adaptive(self,
                          init_n_iter,
                          mul=2,
                          p_succ=0.5,
                          mp=False,
                          n_procs=None,
                          get_all_data=False,
                          get_all_graphs=False,
                          get_all_fusion_networks=False,
                          unravel=True,
                          unravel_bcs_first='random',
                          fusion_order_strategy='weight_and_matching',
                          seed='keep',
                          verbose=True,
                          pbar=False,
                          **kwargs):
        """
        Run the adaptive iteration method for the strategy and obtain the
        best one only (by default).

        The adaptive iteration method looks for the best iteration while
        keeps increasing the iteration number until a certain condition
        meets. In detail, denoting N iterations of the strategy as R(N),
        R(`init_n_iter`) is first executed and `q0` is obtained which is the
        lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
        and `q1` is obtained similarly. If `q0 <= q1`, `q0` is returned. If
        otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
        If `q1 <= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
        is executed, and so on.

        Parameters
        ----------
        init_n_iter : int
            Initial iteration number.

        mul : int (default: 2)
            Multiplicative factor of the iteration number.

        See the description of `GraphState.simulate()` for the other parameters.

        Returns
        -------
        res : dict
            Result of the iterations.<br>
            By default, only the information of the best sample is given.
        """

        if mp and n_procs is None:
            n_procs = os.cpu_count()

        if seed != 'keep':
            np.random.seed(seed)

        additional_keys = []
        if get_all_data:
            additional_keys.extend(['overheads', 'steps'])
        if get_all_graphs:
            additional_keys.append('unraveled_graphs')
        if get_all_fusion_networks:
            additional_keys.append('fusion_networks')

        if verbose:
            if mp:
                print(f"Multiprocessing (n_procs = {n_procs})")
            else:
                print("No multiprocessing")

        n_iter_history = []
        n_iter_now = init_n_iter
        res = None
        while True:
            if verbose:
                print(f"Calculating for n_iter = {n_iter_now}... ", end='')
            t0 = time.time()

            n_iter_history.append(n_iter_now)
            res_now = self.simulate(n_iter=n_iter_now,
                                    p_succ=p_succ,
                                    mp=mp,
                                    n_procs=n_procs,
                                    get_all_data=get_all_data,
                                    get_all_graphs=get_all_graphs,
                                    get_all_fusion_networks=get_all_fusion_networks,
                                    unravel=unravel,
                                    unravel_bcs_first=unravel_bcs_first,
                                    fusion_order_strategy=fusion_order_strategy,
                                    verbose=False,
                                    pbar=pbar,
                                    **kwargs)

            if res is None:
                res = res_now
                best_ogs = self.copy()
                n_iter_now *= mul

            else:
                for key in additional_keys:
                    res[key].extend(res_now[key])

                if res_now['best_overhead'] < res['best_overhead']:
                    for key in additional_keys:
                        res_now[key] = res[key]
                    res = res_now
                    best_ogs = self.copy()

                    n_iter_now *= mul

                else:
                    if verbose:
                        print(f"Done. Best: {res['best_overhead']:.2f} ("
                              f"{time.time() - t0:.2f} s)")
                    break

            if verbose:
                print(f"Done. Best: {res['best_overhead']:.2f} "
                      f"({time.time() - t0:.2f} s)")

        res['n_iter'] = sum(n_iter_history)

        if additional_keys:
            res['best_sample'] += res['best_sample']

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.unraveled_bcss = best_ogs.unraveled_bcss
        self.unraveled_cliques = best_ogs.unraveled_cliques
        self.data = best_ogs.data

        return res

    def _get_graph(self, graph):
        if isinstance(graph, ig.Graph):
            return graph

        if graph == 'graph':
            return self.graph
        elif graph in ['unraveled', 'unraveled_graph']:
            if self.unraveled_graph is None:
                raise ValueError('No unraveled graph created.')
            return self.unraveled_graph
        elif graph in ['network', 'fusion_network']:
            if self.fusion_network is None:
                raise ValueError('No fusion network created')
            return self.fusion_network
        else:
            raise ValueError('Wrong input.')

    def group_links_by_steps(self):
        """
        Get all the links grouped by their fusion steps.

        Returns
        -------
        group : dict
            `group[i]` (for `i` = 1, 2, ...) is the list of the connected pairs
            of nodes in the `i`-th step.
        """
        network = self.fusion_network
        if not isinstance(network, ig.Graph):
            raise ValueError('No fusion network created')

        group = {}
        i = 1
        while True:
            es = network.es.select(step=i)
            if len(es) == 0:
                break
            node_pairs = []
            for e in es:
                node_pairs.append((e.source_vertex['name'],
                                   e.target_vertex['name']))
            group[i] = node_pairs
            i += 1

        return group

    def plot_graph(self, unraveled=False, **kwargs):
        """
        Plot the original or unraveled graph.

        If the unraveled graph is plotted, edges in the unraveled graph are
        drawn as black solid lines while external fusions are drawn as red
        dashed lines (by default).

        Parameters
        ----------
        unraveled : bool (default: False)
            Whether to plot the unraveled graph or the original graph.

        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: 'auto')
            Layout algorithm for plotting.<br>
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (7, 7))
            Size of the figure in inches.

        show_vertex_name : bool (default: True)
            Whether to show vertex names.

        vertex_color_normal : str (default: 'white')
            Color of vertices without Clifford operations.

        vertex_color_clifford : str (default: 'orange')
            Color of vertices with Clifford operations.

        vertices_to_highlight : None or list of {str or int} (default: None)
            Name of vertices to highlight.

        vertex_color_highlight : str (default: purple)
            Color of the highlighted vertices.<br>
            Ignored if `vertices_to_highlight` is `None`.

        edge_color_normal : str (default: black)
            Color of edges in the graph.

        edge_color_fusion : str (default: red)
            Color of lines for external fusions.<br>
            Ignored if `unraveled` is `False`.

        edge_style_fusion : str (default: '--')
            Style of lines for external fusions.

        Any other keyword arguments in `igraph.plot()` can be directly used.<br>
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting <br>
        If they are given, they override the above parameters.

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        """

        graph = self.unraveled_graph if unraveled else self.graph
        if graph is None:
            raise ValueError("No unraveled graph created.")

        fig, ax = plot_graph(graph, **kwargs)

        return fig, ax

    def plot_fusion_network(self, **kwargs):
        """
        Plot the fusion network.

        Parameters
        ----------
        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: 'auto')
            Layout algorithm for plotting.<br>
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (7, 7))
            Size of the figure in inches.

        show_node_name : bool (default: True)
            Whether to show node names.

        node_color_normal : str (default: 'white')
            Color of nodes without Clifford operations.

        node_color_clifford : str (default: 'orange')
            Color of nodes with Clifford operations.

        show_link_name : bool (default: False)
            Whether to show link names.

        show_fusion_order : bool (default: True)
            Whether to show fusion orders on links.<br>
            If both `show_link_name` and `show_fusion_order` are `True`,
            it is shown as `'{link name}-{fusion order}'`

        uniform_link_style : bool (default: False)
            Whether to use uniform link colors/styles or not.
            If it is `False`, links of different types (leaf-to-leaf,
            root-to-leaf, root-to-root) are drawn in different colors and
            linestyles. Specifically, root-to-leaf links are drawn as lines
            with arrows.

        link_color_ll : str (default: 'black')
            Color of links of 'leaf-to-leaf' type.<br>
            Ignored if `uniform_link_style` is `True`

        link_color_rl : str (default: 'blue')
            Color of links of 'root-to-leaf' type.<br>
            Ignored if `uniform_link_style` is `True`

        link_color_rr : str (default: 'red')
            Color of links of 'root-to-root' type.<br>
            Ignored if `uniform_link_style` is `True`

        link_style_ll : str (default: '-')
            Style of links of 'leaf-to-leaf' type.<br>
            Ignored if `uniform_link_style` is `True`

        link_style_rl : str (default: '-')
            Style of links of 'root-to-leaf' type.<br>
            Ignored if `uniform_link_style` is `True`

        link_style_rr : str (default: '--')
            Style of links of 'root-to-root' type.<br>
            Ignored if `uniform_link_style` is `True`

        Any other keyword arguments in igraph.plot can be directly used.<br>
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting <br>
        If they are given, they override the above parameters.<br>

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        """

        network = self.fusion_network
        if network is None:
            raise ValueError('No fusion network created.')

        fig, ax = plot_fusion_network(network, **kwargs)

        return fig, ax

    def copy(self):
        """
        Return a **shallow** copy of this object.

        Returns
        -------
        copy : GraphState
            Copied instance of itself.
        """

        copy = GraphState(graph=self.graph,
                          unraveled_graph=self.unraveled_graph,
                          fusion_network=self.fusion_network)

        copy.unraveled_bcss = self.unraveled_bcss
        copy.unraveled_cliques = self.unraveled_cliques
        copy.data = self.data.copy()
        if self.graph_info is not None:
            copy.graph_info = self.graph_info.copy()

        return copy


def _simulate_single(n_iter, seed, graph, **kwargs):
    ogs = GraphState(graph=graph)
    res = ogs.simulate(n_iter=n_iter, seed=seed, verbose=False, **kwargs)
    res['best_ogs'] = ogs

    return res
