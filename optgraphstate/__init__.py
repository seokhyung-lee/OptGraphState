"""
**OptGraphState** is a python package that implements the graph-theoretical
strategy to optimize the fusion-based generation of any graph state.
The package has the following features:

- Finding a resource-efficient method of generating a given graph state through
type-II fusions from multiple basic resource states, which are three-qubit
linear graph states.
- Computing the corresponding resource overhead, which is quantified by the
average number of required basic resource states.
- Visualizing the original graph (of the graph state you want to generate),
unraveled graphs, and fusion networks. An unraveled graph is a simplified graph
where the corresponding graph state is equivalent to the desired graph state up
to fusions and single-qubit Clifford operations. A fusion network is a graph
that instructs the fusions between basic resource states required to generate
the desired graph state.
- Various predefined sample graphs for input.

Github: https://github.com/seokhyung-lee/OptGraphState

Tutorials: https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf
"""

import time
import os
import sys

import networkx as nx

from .graph_tools import *
from .visualization import *

try:
    import parmap
except ModuleNotFoundError:
    pass


def _max_seed():
    return 2**32


class GraphState:
    #: Graph of the graph state to investigate.
    graph: ig.Graph
    #: Unraveled graph generated by unraveling the original graph/
    #:
    #: It is `None` before the unraveled graph is created.
    #: See Sec. 7 of our tutorial for the list of its vertex attributes.
    unraveled_graph: ig.Graph
    #: Fuson network constructed from the unraveled or original graph.
    #:
    #: It is `None` before the fusion network is created.
    #: See Sec. 7 of our tutorial for the list of its vertex and edge
    #: attributes.
    fusion_network: ig.Graph
    #: Any data obtained during unraveling the graph, constructing the fusion
    #: network, and calculating the resource overhead.
    data: dict

    def __init__(self,
                 graph=None,
                 edges=None,
                 shape=None,
                 prms=None,
                 cliffords=None,
                 unraveled_graph=None,
                 fusion_network=None):
        """
        Class for calculating and optimizing the resource overhead of the
        fusion-based generation of a graph state.

        The graph of the graph state can be given by the following
        three ways:

        1. Given explicitly by [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html) or [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html).
        2. Given by a list of edges.
        3. Chosen among predefined graphs.

        Parameters
        ----------
        graph : None or igraph.Graph or networkx.Graph (default: None)
            Graph of the concerned graph.

            If it is given, `edges`, `shape`, and `prms` are ignored.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html), it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        edges : None or list of 2-tuple of int (default: None)
            List of edges that form the concerned graph.

            Each integer in the tuples indicates a vertex label.

            If it is given and `graph` is `None`, `shape` and `prms` are
            ignored.

        shape : None or str (default: None)
            Shape of the concerned graph chosen among predefined graphs.

            One of `[None, 'random', 'complete', 'star', 'linear', 'cycle',
            'lattice', 'tree', 'rhg', 'repeater', 'parity_encoding', 'ptqc']`.

            - `shape='random'` : Random graph for fixed numbers of vertices
            and edges, sampled by the Erd√∂s-Renyi model.
                - `prms[0]` <`int`> : Number of vertices.
                - `prms[1]` <`int`> : Number of edges.
                - [Optional] `prms[2]` <`None` or `int`> : Random seed. If
                `None`, the current system time is used as the seed. If not
                given, the random number generator is not initialized.
            - `shape='complete'`, `'star'`, `'linear'`, or `'cycle'` :
            Complete, star, linear, or cycle graph, respectively.
                - `prms[0]` <`int`> : Number of vertices.
            - `shape='lattice'` : Lattice graph.
                - `prms` <`tuple` of `int`> : Numbers of repeated vertices
                along the axes. The dimension of the lattice is
                automatically set as `len(prms)`.
            - `shape='tree'` : Tree graph where all branches in each
            generation have an equal number of children.
                - `prms[0]` <`int`> : Degree of the root vertex.
                - `prms[i]` (<`int`>, i >= 1) : Number of the children of each
                `i`th-generation branch.
            - `shape='rhg'` : Raussendorf-Harrington-Goyal lattice with primal
            boundaries only.
                - `prms[0]`, `prms[1]`, `prms[2]` <`int`> : Size of the lattice
                along the three axes in the unit of a cell.
            - `shape='repeater'` : Repeater graph with 4m vertices.
                - `prms[0]` <`int`> : Parameter m.
            - `shape='parity_encoding'` : (n, m) parity-encoded graph.
                - `prms[0]` <[`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html)> : Logical-level graph. Can be
                generated with python-igraph library directly or from the
                function `get_graph_from_edges()` or `get_sample_graph`.
                - `prms[1]`, `prms[2]` <`int`> : Parameters n and m of the
                parity encoding.
            - `shape='ptqc'` : Microcluster for parity-encoding-based
            topological quantum computing protocol.
                - `prms[0]`, `prms[1]` <`int`> : Parameter n and m of the
                parity encoding.
                - `prms[2]` <`bool`> : Whether the H-configuration is
                HIC (`True`) or HIS (`False`).
                - `prms[3]` <`bool`> : Whether the microcluster is
                central (`True`) or side (`False`) one.

        prms : None or tuple or int (default: None)
            Parameters for a predefined graph.

            See the description for parameter `shape`.

            If only one parameter is required, it can be given as a number, not
            a tuple.

        cliffords : None or list of str (default: None)
            Local Clifford gates applied on the qubits of the graph
            state.

            If it is `None`, no Clifford gates are applied on the qubits.

            If it is a `list` of `str`, its length should be equal to the
            number of vertices in the graph. Its i-th element indicates the
            Clifford gate applied on the i-th qubit. For example,
            if it is `'H'`, it means that a Hadamard gate is applied on the
            qubit. If it is `'H-S-Z'`, it means that Hadamard, phase,
            and Z gates are applied in order.

        unraveled_graph : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven unraveled graph.

            The code does not check the validity of the given unraveled graph.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html),
            it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        fusion_network : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven fusion network.

            The code does not check the validity of the given fusion network.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html),
            it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).
        """

        def convert_type(g, varname):
            if g is None:
                return None
            elif isinstance(g, ig.Graph):
                return g
            elif isinstance(g, nx.Graph):
                return ig.Graph.from_networkx(g)
            else:
                raise TypeError(f'Parameter {varname} should be igraph.Graph '
                                f'or networkx.Graph.')

        if graph is not None:
            self.graph = convert_type(graph, 'graph')

        elif edges is not None:
            self.graph = ig.Graph(edges=edges)

        elif shape is not None:
            try:
                prms[0]
            except TypeError:
                prms = (prms,)

            self.graph = get_sample_graph(shape, *prms)

        else:
            raise ValueError(
                "At least one of graph, edges, and shape should be given.")

        self.graph.vs['name'] = [str(vid) for vid in
                                 range(self.graph.vcount())]

        if cliffords is not None and edges is None:
            self.graph.vs['clifford'] = cliffords

        self.unraveled_graph = convert_type(unraveled_graph, 'unraveled_graph')

        self.fusion_network = convert_type(fusion_network, 'fusion_network')

        self.data = {}

    def initialize(self):
        """
        Initialize the created unraveled graph and fusion network and the
        calculation data.
        """
        self.unraveled_graph = None
        self.fusion_network = None
        self.data = {}

    def unravel_graph(self,
                      unravel_bcs_first='random',
                      plot=False,
                      verbose=False):
        """
        Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

        The unraveled graph is saved in `self.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        unravel_bcs_first : one of [True, False, 'random'] (default: 'random')
            - `True`: BCSs are unraveled first, then clqiues are
            unraveled.
            - `False`: cliques are unraveled first, then BCSs are
            unraveled.<br>
            - `'random'`: the order is randomly chosen.

        plot : bool (default: False)
            Whether to plot the unraveled graph after unraveling.

        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Information on the unraveled BCSs.

            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.

        cliques : list of list of set of str
            Information on the unraveled cliques.

            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        """

        if unravel_bcs_first == 'random':
            unravel_bcs_first = np.random.choice([True, False])

        if unravel_bcs_first:
            bcss = self.unravel_bcss(verbose=verbose)
            cliques = self.unravel_cliques(verbose=verbose)
        else:
            cliques = self.unravel_cliques(verbose=verbose)
            bcss = self.unravel_bcss(verbose=verbose)

        if plot or verbose:
            if verbose:
                print('[Final]')
            self.plot_graph(unraveled=True)
            plt.show()

        self.data['unravel'] = True
        self.data['unravel_bcs_first'] = unravel_bcs_first

        return bcss, cliques

    def unravel_bcss(self, verbose=False):
        """
        Unravel bipartitely-complete subgraphs (BCSs) of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Information on the unraveled BCSs.

            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.
        """

        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if 'ext_fusion' not in vs_attrs:
            graph.vs['ext_fusion'] = None
        if 'clifford' not in vs_attrs:
            graph.vs['clifford'] = None

        unraveled_bcss = []

        new_vertex_name = graph.vcount()

        while True:
            # Repeat until there are no bipartitely-complete subgraphs
            bcs_exist = False
            while True:
                bcss = find_nonoverlapping_bcss(graph, get_name=True)
                if bcss:
                    bcs_exist = True
                else:
                    break

                unraveled_bcss.append(bcss)
                eids_to_remove = []
                for part1, part2 in bcss:
                    if verbose:
                        graph.delete_edges(eids_to_remove)
                        eids_to_remove.clear()
                        print('bcs to unravel =', part1, '&', part2)
                        vertex_color = []
                        for v in graph.vs:
                            if v['name'] in part1:
                                vertex_color.append('orange')
                            elif v['name'] in part2:
                                vertex_color.append('blue')
                            else:
                                vertex_color.append('white')
                        self.plot_graph(unraveled=True,
                                        vertex_color=vertex_color)
                        plt.show()

                    eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                           vname1, vname2 in
                                           itertools.product(part1, part2)])

                    vname1 = str(new_vertex_name)
                    vname2 = str(new_vertex_name + 1)
                    new_v1 = graph.add_vertex(name=vname1,
                                              ext_fusion=vname2,
                                              clifford=None)
                    new_v2 = graph.add_vertex(name=vname2,
                                              ext_fusion=vname1,
                                              clifford=None)
                    new_vertex_name += 2

                    graph.add_edges(itertools.product([new_v1], part1))
                    graph.add_edges(itertools.product([new_v2], part2))

                graph.delete_edges(eids_to_remove)

            if not bcs_exist:
                break

        return unraveled_bcss

    def unravel_cliques(self, verbose=False):
        """
        Unravel cliques of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        cliques : list of list of set of str
            Information on the unraveled cliques.

            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        """
        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if 'ext_fusion' not in vs_attrs:
            graph.vs['ext_fusion'] = None
        if 'clifford' not in vs_attrs:
            graph.vs['clifford'] = None

        unraveled_cliques = []

        def apply_clifford(v, clifford):
            org_clifford = v['clifford']
            if org_clifford is None:
                new_clifford = clifford
            else:
                new_clifford = '-'.join([clifford, org_clifford])
            v['clifford'] = new_clifford

        while True:
            cliques = find_nonoverlapping_cliques(graph, get_name=True)

            if not cliques:
                break

            unraveled_cliques.append(cliques)

            for clique in cliques:
                if verbose:
                    print('clique to unravel =', clique)
                    vertex_color = ['orange' if vname in clique else 'white'
                                    for vname in graph.vs['name']]
                    self.plot_graph(unraveled=True, vertex_color=vertex_color)
                    plt.show()
                clique = list(clique)
                clique_size = len(clique)

                # Choose a vertex to apply LC
                degrees = graph.degree(clique)
                min_degree = min(degrees)
                if min_degree == clique_size - 1:
                    # There exists a vertex in the clique that doesn't have
                    # outer edges
                    vname_LC = [vname for vname, deg in zip(clique, degrees) if
                                deg == min_degree]
                    need_to_separate = False
                else:
                    vname_LC = clique
                    need_to_separate = True

                if len(vname_LC) > 1:
                    vname_LC = np.random.choice(vname_LC)
                else:
                    vname_LC = vname_LC[0]
                v_LC = graph.vs.find(name=vname_LC)

                # Separate the edges (E) incident to v_LC outside the clique
                # from v_LC
                eids_to_delete = []
                if need_to_separate:
                    # Vertex connected with E
                    new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=v_LC['clifford'],
                                              ext_fusion=v_LC['ext_fusion'])

                    # Vertex having an external fusion with v_LC
                    new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=None,
                                              ext_fusion=v_LC['name'])

                    graph.add_edge(new_v1, new_v2)

                    ngh_vids = graph.neighbors(vname_LC)
                    for ngh_vid in ngh_vids:
                        if graph.vs[ngh_vid]['name'] not in clique:
                            graph.add_edge(ngh_vid, new_v1)
                            eids_to_delete.append(graph.get_eid(vname_LC,
                                                                ngh_vid))

                    vname_org_ext_fusion = v_LC['ext_fusion']
                    if vname_org_ext_fusion is not None:
                        v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                        v_org_ext_fusion['ext_fusion'] = new_v1['name']

                    v_LC['ext_fusion'] = new_v2['name']

                    v_LC['name'], new_v1['name'] = new_v1['name'], vname_LC

                # Apply LC
                adj_vnames = set(clique) - {vname_LC}
                apply_clifford(v_LC, 'RX')
                for adj_vname in adj_vnames:
                    adj_v = graph.vs.find(name=adj_vname)
                    apply_clifford(adj_v, 'RZ')

                new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                      vname1, vname2 in
                                      itertools.combinations(adj_vnames, r=2)]
                eids_to_delete.extend(new_eids_to_delete)
                graph.delete_edges(eids_to_delete)

        return unraveled_cliques

    def build_fusion_network(self,
                             use_unraveled_graph=True,
                             plot=False,
                             verbose=False):
        """
        Build a fusion network from the original graph or unraveled graph.

        If you want to build it from the unraveled graph, at least one of
        `GraphState.unravel_graph()`, `GraphState.unravel_bcss()`, and
        `GraphState.unravel_cliques()` must be executed beforehand.

        The constructed fusion network is saved in `GraphState.fusion_network`
        as [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        use_unraveled_graph : bool (default: True)
            Whether to use the unraveled graph or the original graph for
            building a fusion network.

        plot : bool (default: False)
            Whether to plot the fusion network after building it.

        verbose : bool (default: False)
            Whether to print logs.
        """

        graph = self.unraveled_graph if use_unraveled_graph else self.graph
        if graph is None:
            raise ValueError("No unraveled qubit graph created.")

        # Fusion network
        network = ig.Graph()
        self.fusion_network = network
        node_groups = {}

        # Links inside star graphs
        for v in graph.vs:
            num_internal_nodes = v.degree() - 1
            vname = v['name']
            if num_internal_nodes >= 1:

                # Add nodes
                nid_init = network.vcount()
                seed = np.random.randint(0, num_internal_nodes)
                node_names = [vname if i == 0 else f'{vname}-{i}' for
                              i in itertools.chain(range(seed, -1, -1),
                                                   range(seed + 1,
                                                         num_internal_nodes))]
                attr = {
                    'name': node_names,
                    'seed': [True if i == seed else False for i in
                             range(num_internal_nodes)],
                    'node_group': vname,
                    # 'clifford_root': None,
                    # 'clifford_leaves': None
                }
                network.add_vertices(num_internal_nodes, attributes=attr)
                node_groups[vname] \
                    = network.vs[nid_init:nid_init + num_internal_nodes]

                if num_internal_nodes >= 2:
                    # Connect internal links
                    links = [(nid, nid + 1) for nid
                             in range(nid_init,
                                      nid_init + num_internal_nodes - 1)]
                    attr = {
                        'kind': "RL",
                        'root_node': [
                            node_names[i] if i < seed else node_names[i + 1]
                            for i in range(num_internal_nodes - 1)],
                        'cliffords': {}
                    }
                    network.add_edges(links, attributes=attr)

        # Links between star graphs
        for e in graph.es:
            vs = [e.source_vertex, e.target_vertex]
            deg_vs = graph.degree(vs)

            if deg_vs[0] > 1 and deg_vs[1] > 1:
                nodes_to_connect = []
                for v in vs:
                    vname = v['name']
                    nodes = node_groups[vname].select(
                        lambda node: node.degree() < (2 if node['seed'] else 3)
                    )
                    nodes_to_connect.append(np.random.choice(nodes))
                network.add_edge(*nodes_to_connect,
                                 kind='LL',
                                 root_node=None,
                                 cliffords={})

        if verbose:
            print("Fusion network of the unraveled graph:")
            self.plot_fusion_network()
            plt.show()

        # Set of seed node names where root vertices are connected by
        # external fusions.
        nnames_root_connected = set()
        is_node_not_full = lambda node: node.degree() < (
            2 if node['seed'] and (
                    node['name'] not in nnames_root_connected) else 3)

        def get_nodes_containing_vertex(vname):
            try:
                node = node_groups[vname].find(name=vname)
                is_root = True
                seed_node_name = vname
            except KeyError:
                ngh = graph.vs[graph.neighbors(vname)[0]]
                seed_node_name = ngh['name']
                nodes = node_groups[seed_node_name].select(is_node_not_full)
                node = np.random.choice(nodes)
                is_root = False

            return node, is_root, seed_node_name

        vs_attrs = graph.vs.attributes()

        # Links by external fusions
        if 'ext_fusion' in vs_attrs:
            vnames_to_skip = set()
            for v1 in graph.vs.select(ext_fusion_ne=None):
                vname1 = v1['name']
                if vname1 in vnames_to_skip:
                    continue
                vname2 = v1['ext_fusion']
                v2 = graph.vs.find(name=vname2)
                vnames_to_skip.add(vname2)

                node1, is_root1, _ = get_nodes_containing_vertex(vname1)
                node2, is_root2, _ = get_nodes_containing_vertex(vname2)
                if is_root1 and is_root2:
                    kind = 'RR'
                    root_node = None
                    nnames_root_connected.add(node1['name'])
                    nnames_root_connected.add(node2['name'])
                elif not is_root1 and not is_root2:
                    kind = 'LL'
                    root_node = None
                else:
                    kind = 'RL'
                    root_node = node1['name'] if is_root1 else node2['name']
                    nnames_root_connected.add(root_node)

                cliffords = {}
                cl1 = v1['clifford']
                cl2 = v2['clifford']

                for node, cl in zip([node1, node2], [cl1, cl2]):
                    if cl is not None:
                        cliffords[node['name']] = cl

                network.add_edge(node1,
                                 node2,
                                 kind=kind,
                                 root_node=root_node,
                                 cliffords=cliffords)

        network.es['name'] = [str(eid) for eid in range(network.ecount())]

        if verbose:
            print("Add external fusions:")
            self.plot_fusion_network()
            plt.show()

        # Clifford gates on surviving qubits
        # if 'clifford' in vs_attrs:
        #     cls_in_node_group_leaves = {}
        #     for v_cl in graph.vs.select(clifford_ne=None, ext_fusion=None):
        #         vname = v_cl['name']
        #         _, is_root, seed_node_name = get_nodes_containing_vertex(vname)
        #         seed_node = network.vs.find(name=seed_node_name)
        #         cl = v_cl['clifford']
        #
        #         if is_root:
        #             if seed_node_name not in nnames_root_connected:
        #                 seed_node['clifford_root'] = cl
        #
        #         else:
        #             try:
        #                 cls_in_node_group_leaves[seed_node_name].append(cl)
        #             except KeyError:
        #                 cls_in_node_group_leaves[seed_node_name] = [cl]
        #
        #     for seed_node_name, cls in cls_in_node_group_leaves.items():
        #         node_group = node_groups[seed_node_name]
        #         nums_surviving_leaves = []
        #         for node in node_group:
        #             if node['name'] in nnames_root_connected:
        #                 num_surviving_leaves = 3 - node.degree()
        #             else:
        #                 num_surviving_leaves = 2 - node.degree()
        #             nums_surviving_leaves.append(num_surviving_leaves)
        #         total_num_surviving_leaves = sum(nums_surviving_leaves)
        #
        #         if len(cls) < total_num_surviving_leaves:
        #             cls.extend([None]
        #                        * (total_num_surviving_leaves - len(cls)))
        #         np.random.shuffle(cls)
        #
        #         i_start = 0
        #         for node, num_leaves in zip(node_group, nums_surviving_leaves):
        #             cls_current_node = cls[i_start:i_start + num_leaves]
        #             cls_current_node = [cl for cl in cls_current_node
        #                                 if cl is not None]
        #             node['clifford_leaves'] = cls_current_node
        #             i_start += num_leaves

        # if verbose:
        #     print("Apply Clifford gates:")
        #     self.plot_fusion_network()
        #     plt.show()

        self.fusion_network = network

        if plot:
            print("Final:")
            self.plot_fusion_network()
            plt.show()

    def _contract_edge(self, fusion_network, ename_to_merge):
        ename_to_merge = str(ename_to_merge)

        e_to_merge = fusion_network.es.find(name=ename_to_merge)
        v_merged, v_removed = e_to_merge.source_vertex, e_to_merge.target_vertex
        enames_updated_weight = []

        if v_merged.degree() < v_removed.degree():
            v_merged, v_removed = v_removed, v_merged

        vname_merged = v_merged['name']
        vname_removed = v_removed['name']

        v_merged['weight'] = e_to_merge['weight']
        v_merged['step'] = max(v_merged['step'], v_removed['step']) + 1

        assert vname_merged != vname_removed

        eids_to_delete = list(set(fusion_network.incident(v_removed)))
        v_removed['on'] = False

        for eid_connected in eids_to_delete:
            e_connected = fusion_network.es[eid_connected]
            ename_connected = e_connected['name']
            if ename_connected != ename_to_merge:
                enames_updated_weight.append(ename_connected)
                vs_ngh = e_connected.source_vertex, e_connected.target_vertex
                new_edge = [v_merged if v_ngh['name'] == vname_removed
                            else v_ngh for v_ngh in vs_ngh]
                if new_edge[0] == new_edge[1]:  # If a loop is formed
                    v_vrt = fusion_network.add_vertex(
                        name=f'vrt_{fusion_network.vcount()}',
                        weight=0,
                        step=0
                    )
                    new_edge = [v_merged, v_vrt]

                fusion_network.add_edge(*new_edge,
                                        name=ename_connected,
                                        weight=None, )

        fusion_network.delete_edges(eids_to_delete)

        p_succ = fusion_network['p_succ']
        for eid_connected in list(set(fusion_network.incident(v_merged))):
            e_connected = fusion_network.es[eid_connected]
            v_ngh1, v_ngh2 = e_connected.source_vertex, e_connected.target_vertex

            assert v_ngh1 != v_ngh2
            new_weight = (v_ngh1['weight'] + v_ngh2['weight']) / p_succ
            e_connected['weight'] = new_weight

        self.fusion_network.es.find(name=ename_to_merge)['step'] = v_merged[
            'step']

        return enames_updated_weight

    def calculate_overhead(self,
                           p_succ=0.5,
                           strategy='weight_and_matching',
                           fusion_order=None,
                           get_fusion_order=False, ):
        """
        Calculate the resource overhead from the fusion network.

        `GraphState.build_fusion_network()` must be executed beforehand.

        The resulting data is saved in `GraphState.data`.

        Parameters
        ----------
        p_succ : float (default: 0.5)
            Success probability of a fusion.

        strategy: str, one of ['weight', 'matching', 'weight_and_matching', 'random'] (default: 'weight_and_matching')
            Strategy for determining the edge to contract in each step.

            - `'weight'`: Contract a random one among the edges with the
            smallest weight.
            - `'matching'`: Contract an edge in a maximum matching.
            - `'weight_and_matching'`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `'random'`: Contract a random edge.

        fusion_order : None or list of {int or str} (default: None)
            Fusion order given explicitly as vertex names.

            If it is not `None`, parameter `strategy` is ignored.

        get_fusion_order : bool (default: False)
            Whether to include the determined fusion order in the returned
            data.

        Returns
        -------
        data : dict
            Outcomes of the calculation, which is a shallow copy of
            `GraphState.data`.<br>
            The calculated overhead and number of steps can be obtained from
            `data['overhead']` and `data['step']`, respectively.
        """

        if self.fusion_network is None:
            raise ValueError("No fusion network created")

        # Trivial cases
        node_num = self.fusion_network.vcount()
        if node_num == 0:
            self.data['overhead'] = 0
            self.data['step'] = 0
            return self.data
        elif node_num == 1:
            self.data['overhead'] = 1
            self.data['step'] = 0
            return self.data

        if fusion_order is None:
            fusion_order = []
            is_fusion_order_given = False
        else:
            is_fusion_order_given = True

        self.fusion_network.es['step'] = None

        # Initialize intermediate fusion network
        network = self.fusion_network.copy()
        network['p_succ'] = p_succ
        network.vs['weight'] = 1
        network.vs['step'] = 0
        network.vs['on'] = True
        network.es['weight'] = 2 / p_succ
        del network.es['step']

        turn = 0

        # Iterate until no edges remain in the fusion network
        while True:
            if not network.ecount():
                break

            if is_fusion_order_given:
                enames_curr_step = [str(fusion_order[turn])]
                is_parellel = True

            elif strategy == 'weight':
                min_weight = min(network.es['weight'])
                eids_min_weight = network.es.select(weight=min_weight)
                enames_curr_step = eids_min_weight['name']
                is_parellel = len(enames_curr_step) == 1

            # elif strategy == 'betweenness':
            #     eb = np.array(network.edge_betweenness())
            #     min_eb = np.min(eb)
            #     eids_curr_step = np.nonzero(eb == min_eb)[0]
            #     enames_curr_step = [network.es[eid]['name'] for eid in
            #     eids_curr_step]
            #     is_parellel = len(enames_curr_step) == 1
            #
            # elif strategy == 'weight_and_betweenness':
            #     min_weight = min(network.es['weight'])
            #     eids_min_weight = network.es.select(weight=min_weight)
            #     es_min_ovh = eids_min_weight
            #
            #     eb = network.edge_betweenness()
            #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
            #     min_eb = np.min(ebs_min_ovh)
            #     enames_curr_step = [es_min_ovh[i]['name'] for i in
            #     np.nonzero(ebs_min_ovh == min_eb)[0]]
            #     is_parellel = len(enames_curr_step) == 1

            elif 'matching' in strategy:
                if strategy == 'weight_and_matching':
                    min_weight = min(network.es['weight'])
                    es_min_weight = network.es.select(weight=min_weight)
                    subnetwork = network.subgraph_edges(es_min_weight)
                else:
                    subnetwork = network

                subnetwork_nx = subnetwork.to_networkx()
                if isinstance(subnetwork_nx, nx.MultiGraph):
                    subnetwork_nx = nx.Graph(subnetwork_nx)
                matching = nx.max_weight_matching(subnetwork_nx, weight=None)
                enames_curr_step = \
                    subnetwork.es[subnetwork.get_eids(matching)]['name']

                is_parellel = True

            elif strategy == 'random':
                enames_curr_step = [np.random.choice(network.es['name'])]
                is_parellel = True

            else:
                raise ValueError

            recalculated_enames = []

            if get_fusion_order and not is_fusion_order_given:
                fusion_order_curr_step = set()
                fusion_order.append(fusion_order_curr_step)

            while True:
                if not is_parellel:
                    for rec_ename in recalculated_enames:
                        try:
                            enames_curr_step.remove(rec_ename)
                        except ValueError:
                            pass

                if not enames_curr_step:
                    break

                recalculated_enames.clear()

                if is_parellel:
                    ename_to_merge = enames_curr_step.pop()
                else:
                    ename_to_merge = np.random.choice(enames_curr_step)
                    enames_curr_step.remove(ename_to_merge)

                if get_fusion_order:
                    e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                    v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                    fusion_order_curr_step.add((v1['name'], v2['name'],
                                                ename_to_merge))

                enames_updated_weight = self._contract_edge(network,
                                                            ename_to_merge)

                recalculated_enames.extend(enames_updated_weight)

        v_final = network.vs.select(on=True)
        overhead = sum(v_final['weight'])
        step = max(v_final['step'])

        results = {
            'overhead': overhead,
            'step': step,
            'fusion_order_strategy': strategy,
            'p_succ': p_succ}

        if get_fusion_order:
            results['fusion_order'] = fusion_order

        self.data.update(results)

        return self.data.copy()

    def simulate(self,
                 n_iter,
                 p_succ=0.5,
                 mp=False,
                 n_procs=None,
                 get_all_data=False,
                 get_all_graphs=False,
                 get_all_fusion_networks=False,
                 unravel=True,
                 unravel_bcs_first='random',
                 fusion_order_strategy='weight_and_matching',
                 seed='keep',
                 verbose=True,
                 pbar=False,
                 **kwargs):
        """
        Execute the strategy for a fixed number of iterations and obtain the
        best one only (by default).

        Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
        `GraphState.fusion_network` are updated according to the result of the
        best sample.

        Parameters
        ----------
        n_iter : int
            Iteration number.

        p_succ : float (default: 0.5)
            Success probability of a fusion.

        mp : bool (default: False)
            Whether to use multiprocessing for the iterations.

            Package *parmap* should be installed to use it.

        n_procs : None or int (default: None)
            Maximal number of simultaneous processes for multiprocessing.

            If it is `None`, the number of CPUs is used.

            Ignored when `mp` is `False`.

        get_all_data : bool (default: False)
            Whether to obtain the data (overheads, numbers of steps, etc.) from
            all samples or only the best sample.

        get_all_graphs : bool (default: False)
            Whether to obtain the unraveled graphs from all samples or only the
            best sample.

        get_all_fusion_networks : bool (default: False)
            Whether to obtain the fusion networks from all samples or only the
            best sample.

        unravel : bool (default: True)
            Whether to unravel the graph or not.

        unravel_bcs_first : one of [True, False, 'random'] (default: 'random')
            - `True`: BCSs are unraveled first, then clqiues are unraveled.
            - `False`, cliques are unraveled first, then BCSs are unraveled.
            - `'random'`, the order is randomly chosen.

        fusion_order_strategy : one of ['weight', 'matching', 'weight_and_matching', 'random'] (default: `weight_and_matching')
            Strategy for determining the edge to contract in each step.

            - `'weight'`: Contract a random one among the edges with the
            smallest weight.
            - `'matching'`: Contract an edge in a maximum matching.
            - `'weight_and_matching'`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `'random'`: Contract a random edge.

        seed : 'keep' or None or int (default: 'keep')
            Random seed.

            - `'keep'`: The seed is not initialized.
            - `None`: The current time is used as the random seed.
            - `int`: The given number is used as the random seed.

            If `n_iter>1`, the given seed is used to sample random seeds for
            individual iterations. However, if `n_iter==1`, the given seed is
            used as the random seed for the (only one) iteration itself.

        verbose : bool (default: True)
            Whether to print logs.

        pbar : bool (default: False)
            Whether to show a progress bar.

            Ignored if `mp` is `False`

        kwargs : dict
            Additional keyword arguments for calculating overheads.

            See the description of `GraphState.calculate_overhead()`.

        Returns
        -------
        res : dict
            Result of the iterations.

            By default, only the information of the best sample is returned.
        """

        t0 = time.time()

        if seed != 'keep':
            np.random.seed(seed)

        if mp:
            if n_procs is None:
                n_procs = os.cpu_count()
            mp = mp and n_iter >= n_procs

        if not mp:
            if verbose:
                print("Multiprocessing OFF.")
                print(f"Calculating for n_iter = {n_iter}...")

            if n_iter == 1 and seed is not None and seed != 'keep':
                seeds_samples = [seed]
            else:
                seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

            overheads = [] if get_all_data else None
            steps = [] if get_all_data else None
            seeds = [] if get_all_data else None
            unravalled_graphs = [] if get_all_graphs else None
            fusion_networks = [] if get_all_fusion_networks else None

            best_sample = None
            lowest_overhead = None
            for i_sample in range(n_iter):
                seed_sample = seeds_samples[i_sample]
                np.random.seed(seed_sample)

                if unravel:
                    self.unraveled_graph = None
                    try:
                        self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                    except:
                        print('Error occurs during unraveling')
                        print('seed =', seed_sample)
                        raise ValueError

                try:
                    self.build_fusion_network(use_unraveled_graph=unravel)
                except:
                    print('Error occurs during building fusion network')
                    print('seed =', seed_sample)
                    raise ValueError

                try:
                    data_now = self.calculate_overhead(p_succ=p_succ,
                                                       strategy=fusion_order_strategy,
                                                       **kwargs)
                except:
                    print('Error occurs during calculating overhead')
                    print('seed =', seed_sample)
                    raise ValueError

                overhead_now = data_now['overhead']
                step_now = data_now['step']
                self.data['seed'] = seed_sample

                if lowest_overhead is None or overhead_now < lowest_overhead:
                    best_sample = i_sample
                    lowest_overhead = overhead_now
                    best_ogs = self.copy()

                if get_all_data:
                    overheads.append(overhead_now)
                    steps.append(step_now)
                    seeds.append(seed_sample)

                if get_all_graphs:
                    unravalled_graphs.append(self.unraveled_graph)

                if get_all_fusion_networks:
                    fusion_networks.append(self.fusion_network)

            res = {
                'best_overhead': best_ogs.data['overhead'],
                'best_step': best_ogs.data['step'],
                'best_seed': best_ogs.data['seed'],
                'n_iter': n_iter}

            if unravel:
                res['unravel_bcs_first'] = best_ogs.data['unravel_bcs_first']

            if get_all_data or get_all_graphs or get_all_fusion_networks:
                res['best_sample'] = best_sample

                if get_all_data:
                    res['overheads'] = overheads
                    res['steps'] = steps
                    res['seeds'] = seeds

                if get_all_graphs:
                    res['unraveled_graphs'] = unravalled_graphs

                if get_all_fusion_networks:
                    res['fusion_networks'] = fusion_networks

        else:
            if 'parmap' not in sys.modules:
                raise ModuleNotFoundError("Package parmap is not installed.")

            if verbose:
                print(f"Multiprocessing ON: n_procs = {n_procs}")
                print(f"Calculating for n_iter = {n_iter}... ", end='')

            additional_keys = []
            if get_all_data:
                additional_keys.extend(['overheads', 'steps', 'seeds'])
            if get_all_graphs:
                additional_keys.append('unraveled_graphs')
            if get_all_fusion_networks:
                additional_keys.append('fusion_networks')

            left = n_iter % n_procs
            ns_samples = [n_iter // n_procs] * n_procs
            for i in range(left):
                ns_samples[i] += 1

            seeds = np.random.randint(0, _max_seed(), size=n_procs)

            res_procs = parmap.starmap(_simulate_single,
                                       list(zip(ns_samples, seeds)),
                                       self.graph,
                                       p_succ=p_succ,
                                       get_all_data=get_all_data,
                                       get_all_graphs=get_all_graphs,
                                       get_all_fusion_networks=get_all_fusion_networks,
                                       unravel=unravel,
                                       unravel_bcs_first=unravel_bcs_first,
                                       fusion_order_strategy=fusion_order_strategy,
                                       pm_pbar=pbar,
                                       **kwargs)
            best_overheads = [res_each['best_overhead'] for res_each in
                              res_procs]
            best_proc = np.argmin(best_overheads)
            res = res_procs[best_proc]
            res['n_iter'] = n_iter
            best_ogs = res['best_ogs']
            del res['best_ogs']

            if additional_keys:
                res['best_sample'] += sum(ns_samples[:best_proc])

            for key in additional_keys:
                vals = [res_each[key] for res_each in res_procs]
                res[key] = list(itertools.chain(*vals))

        if verbose:
            print(f"Done. Best: {res['best_overhead']:.2f} "
                  f"({time.time() - t0:.2f} s)")

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.data = best_ogs.data

        return res

    def simulate_adaptive(self,
                          init_n_iter,
                          mul=2,
                          p_succ=0.5,
                          mp=False,
                          n_procs=None,
                          get_all_data=False,
                          get_all_graphs=False,
                          get_all_fusion_networks=False,
                          unravel=True,
                          unravel_bcs_first='random',
                          fusion_order_strategy='weight_and_matching',
                          seed='keep',
                          verbose=True,
                          pbar=False,
                          **kwargs):
        """
        Run the adaptive iteration method for the strategy and obtain the
        best one only (by default).

        The adaptive iteration method looks for the best iteration while
        keeps increasing the iteration number until a certain condition
        meets. In detail, denoting N iterations of the strategy as R(N),
        R(`init_n_iter`) is first executed and `q0` is obtained which is the
        lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
        and `q1` is obtained similarly. If `q0 <= q1`, `q0` is returned. If
        otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
        If `q1 <= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
        is executed, and so on.

        Parameters
        ----------
        init_n_iter : int
            Initial iteration number.

        mul : int (default: 2)
            Multiplicative factor of the iteration number.

        See the description of `GraphState.simulate()` for the other parameters.

        Returns
        -------
        res : dict
            Result of the iterations.

            By default, only the information of the best sample is given.
        """

        if mp and n_procs is None:
            n_procs = os.cpu_count()

        if seed != 'keep':
            np.random.seed(seed)

        additional_keys = []
        if get_all_data:
            additional_keys.extend(['overheads', 'steps'])
        if get_all_graphs:
            additional_keys.append('unraveled_graphs')
        if get_all_fusion_networks:
            additional_keys.append('fusion_networks')

        if verbose:
            if mp:
                print(f"Multiprocessing (n_procs = {n_procs})")
            else:
                print("No multiprocessing")

        n_iter_history = []
        n_iter_now = init_n_iter
        res = None
        while True:
            if verbose:
                print(f"Calculating for n_iter = {n_iter_now}... ", end='')
            t0 = time.time()

            n_iter_history.append(n_iter_now)
            res_now = self.simulate(n_iter=n_iter_now,
                                    p_succ=p_succ,
                                    mp=mp,
                                    n_procs=n_procs,
                                    get_all_data=get_all_data,
                                    get_all_graphs=get_all_graphs,
                                    get_all_fusion_networks=get_all_fusion_networks,
                                    unravel=unravel,
                                    unravel_bcs_first=unravel_bcs_first,
                                    fusion_order_strategy=fusion_order_strategy,
                                    verbose=False,
                                    pbar=pbar,
                                    **kwargs)

            if res is None:
                res = res_now
                best_ogs = self.copy()
                n_iter_now *= mul

            else:
                for key in additional_keys:
                    res[key].extend(res_now[key])

                if res_now['best_overhead'] < res['best_overhead']:
                    for key in additional_keys:
                        res_now[key] = res[key]
                    res = res_now
                    best_ogs = self.copy()

                    n_iter_now *= mul

                else:
                    if verbose:
                        print(f"Done. Best: {res['best_overhead']:.2f} ("
                              f"{time.time() - t0:.2f} s)")
                    break

            if verbose:
                print(f"Done. Best: {res['best_overhead']:.2f} "
                      f"({time.time() - t0:.2f} s)")

        res['n_iter'] = sum(n_iter_history)

        if additional_keys:
            res['best_sample'] += res['best_sample']

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.data = best_ogs.data

        return res

    def _get_graph(self, graph):
        if isinstance(graph, ig.Graph):
            return graph

        if graph == 'graph':
            return self.graph
        elif graph in ['unraveled', 'unraveled_graph']:
            if self.unraveled_graph is None:
                raise ValueError('No unraveled graph created.')
            return self.unraveled_graph
        elif graph in ['network', 'fusion_network']:
            if self.fusion_network is None:
                raise ValueError('No fusion network created')
            return self.fusion_network
        else:
            raise ValueError('Wrong input.')

    def get_instructions(self):
        """
        Get the instruction to generate the desired graph state from multiple
        three-qubit linear graph states.

        One of `GraphState.calculate_overhead()`, `GraphState.simulate()`, and
        `GraphState.simulate_adaptive()` must be executed beforehand.

        Returns
        -------
        node_names : list of str
            List of the names of nodes in the fusion network.

        fusions : dict
            Dictionary that contains the information about required fusions and
            Clifford gates.

            Each required fusion is represented by a 2-tuples of 3-tuple:
            `((n1, q1, cl1), (n2, q2, cl2))`. `n1` and `n2` are the names of
            the nodes involved in the fusion, `q1` and `q2` are `'R'` or `'L'`
            that indicate the qubits undergoing the fusion (`'R'` for a root
            qubit and `'L'` for a leaf qubit), and `cl1` and `cl2` are the
            Clifford gates applied to the qubits before the fusion is
            performed.

            `fusions[i]` for a positive integer `i` is a list of such 2-tuples,
            which indicate fusions that can be done in parallel in the `i`-th
            step.

        qubit_correspondence : dict
            Dictionary that contains the correspondence between the vertices in
            the original graph and the final remaining qubits after performing
            all the fusions.

            For each name (say, `vname`) of a vertex in the original graph,
            `qubit_correspondence[vname]` is a 3-tuple `(node, qubit, cl)`,
            where `node` is the node containing the qubit, `qubit` is either
            `'R'` or `'L'` that indicates whether the qubit is a root or leaf
            qubit, and `cl` is the Clifford gate applied to the qubit.
        """
        network = self.fusion_network

        # Fusions
        fusions = {}
        steps = network.es['step']
        max_step = max(steps)
        for step in range(1, max_step + 1):
            inst_same_step = []
            links = network.es.select(step=step)
            for link in links:
                nname1 = link.source_vertex['name']
                nname2 = link.target_vertex['name']
                kind = link['kind']
                if kind == 'RR':
                    qubit1 = qubit2 = 'R'
                elif kind == 'LL':
                    qubit1 = qubit2 = 'L'
                else:
                    root_node = link['root_node']
                    qubit1 = 'R' if root_node == nname1 else 'L'
                    qubit2 = 'L' if qubit1 == 'R' else 'R'
                cliffords = link['cliffords']
                try:
                    cl1 = cliffords[nname1]
                except KeyError:
                    cl1 = None
                try:
                    cl2 = cliffords[nname2]
                except KeyError:
                    cl2 = None

                inst_same_step.append(((nname1, qubit1, cl1),
                                       (nname2, qubit2, cl2)))

            fusions[step] = inst_same_step

        # Final remaining qubits & Clifford gates on them
        qubit_correspondence = {}
        remaining_leaves = {}
        for vname in self.graph.vs['name']:
            v_unrv: ig.Vertex = self.unraveled_graph.vs.find(name=vname)
            cl = v_unrv['clifford']

            if v_unrv.degree() > 1:
                corr = (vname, 'R', cl)

            else:
                v_ngh_unrv = v_unrv.neighbors()[0]
                seed_node_name = v_ngh_unrv['name']
                try:
                    remaining_leaves_curr \
                        = remaining_leaves[seed_node_name]
                except KeyError:
                    node_group \
                        = network.vs.select(node_group=seed_node_name)
                    remaining_leaves_curr = {}
                    for node in node_group:
                        num_remaining_leaves = 2
                        for link in node.incident():
                            kind = link['kind']
                            if kind == 'LL' \
                                    or (kind == 'RL'
                                        and link['root_node'] != node['name']):
                                num_remaining_leaves -= 1
                        remaining_leaves_curr[node['name']] \
                            = num_remaining_leaves
                    remaining_leaves[seed_node_name] = remaining_leaves_curr

                corr = None
                for node_name, num_remaining_leaves in remaining_leaves_curr.items():
                    if num_remaining_leaves:
                        corr = (node_name, 'L', cl)
                        remaining_leaves_curr[node_name] -= 1

                assert corr is not None

            qubit_correspondence[vname] = corr

        node_names = network.vs['name']

        return node_names, fusions, qubit_correspondence

    def get_vertex_clifford(self, vertex, unraveled=True):
        """
        Get the Clifford gate applied to a vertex in the unraveled graph
        (by default) or the original graph.

        Each Clifford gate is represented by a string. For example, `'RX'`
        and `'RZ'` respectively mean pi/2 X-rotation (Z-rotation). If a qubit
        is subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
        represented by `'RX-RZ'`.

        Parameters
        ----------
        vertex : int or str
            Name of the vertex.

        unraveled : bool (default: True)
            Whether to find the vertex in the unraveled or original graph.

        Returns
        -------
        clifford : None or str
            Clifford gate applied to the vertex.
        """

        graph = self.unraveled_graph if unraveled else self.graph
        if 'clifford' in graph.vertex_attributes():
            cl = graph.vs.find(name=str(vertex))['clifford']
            return cl
        else:
            return None

    def get_link_clifford(self, n1, n2):
        """
        Get the Clifford gates that need to be applied to two qubits involved
        in the fusion of a given link.

        Each Clifford gate is represented by a string. For example, `'RX'` and
        `'RZ'` respectively mean pi/2 X-rotation (Z-rotation). If a qubit is
        subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
        represented by `'RX-RZ'`.

        Parameters
        ----------
        n1, n2 : int or str
            Names of the nodes connected by the link.

        Returns
        -------
        cl1, cl2 : None or str
            Clifford gates applied on the two qubits involved in the fusion
            of the link.
        """

        network = self.fusion_network
        n1 = str(n1)
        n2 = str(n2)

        link = network.es[network.get_eid(n1, n2)]
        cliffords = link['cliffords']
        cls = []
        for n in [n1, n2]:
            try:
                cls.append(cliffords[n])
            except KeyError:
                cls.append(None)

        return tuple(cls)

    def plot_graph(self, unraveled=False, **kwargs):
        """
        Plot the original or unraveled graph.

        If the unraveled graph is plotted, edges in the unraveled graph are
        drawn as black solid lines while external fusions are drawn as red
        dashed lines (by default).

        Vertices with Clifford gates are colored in orange (by default).
        These Clifford gates can be obtained by using
        `GraphState.get_clifford_in_graph()`.

        Parameters
        ----------
        unraveled : bool (default: False)
            Whether to plot the unraveled graph or the original graph.

        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: 'auto')
            Layout algorithm for plotting.

            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (5, 5))
            Size of the figure in inches.

        save : None or str (default: None)
            Path to save the figure.

        show_vertex_name : bool (default: True)
            Whether to show vertex names.

        vertex_color_normal : str (default: 'white')
            Color of vertices without Clifford gates.

        vertex_color_clifford : str (default: 'orange')
            Color of vertices with Clifford gates.

        vertices_to_highlight : None or list of {str or int} (default: None)
            Name of vertices to highlight.

        vertex_color_highlight : str (default: purple)
            Color of the highlighted vertices.

            Ignored if `vertices_to_highlight` is `None`.

        edge_color_normal : str (default: black)
            Color of edges in the graph.

        edge_color_fusion : str (default: red)
            Color of lines for external fusions.

            Ignored if `unraveled` is `False`.

        edge_style_fusion : str (default: '--')
            Style of lines for external fusions.

        Any other keyword arguments in `igraph.plot()` can be directly used.
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting
        If they are given, they override the above parameters.

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        """

        graph = self.unraveled_graph if unraveled else self.graph
        if graph is None:
            raise ValueError("No unraveled graph created.")

        fig, ax = plot_graph(graph, **kwargs)

        return fig, ax

    def plot_fusion_network(self, **kwargs):
        """
        Plot the fusion network.

        Links have different styles depending on their types:

        - 'LL': Solid line
        - 'RR': Dotted line
        - 'RL': Arrow from leaf to root.

        The number placed on each link indicates the step of the fusion. It is
        presented only when the resource overhead has been computed beforehand.

        An red link indicates that particular Clifford gates should be
        applied to the qubits involved in the fusion before it is performed.

        These Clifford gates can be obtained by using
        `GraphState.get_clifford_in_fusion_network()`.

        Parameters
        ----------
        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: 'auto')
            Layout algorithm for plotting.<br>
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (5, 5))
            Size of the figure in inches.

        save : None or str (default: None)
            Path to save the figure.

        show_node_name : bool (default: True)
            Whether to show node names.

        node_color : str (default: 'white')
            Color of nodes.

        show_link_name : bool (default: False)
            Whether to show link names.

        show_fusion_order : bool (default: True)
            Whether to show fusion orders on links.<br>
            If both `show_link_name` and `show_fusion_order` are `True`,
            it is shown as `'{link name}-{fusion order}'`

        link_color : str (default: 'black')
            Color of links.

        link_color_clifford : str (default: 'orange')
            Color of links with Clifford gates.

        Any other keyword arguments in igraph.plot can be directly used.<br>
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting <br>
        If they are given, they override the above parameters.<br>

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        """

        network = self.fusion_network
        if network is None:
            raise ValueError('No fusion network created.')

        fig, ax = plot_fusion_network(network, **kwargs)

        return fig, ax

    def copy(self):
        """
        Return a **shallow** copy of this object.

        Returns
        -------
        copy : GraphState
            Copied instance of itself.
        """

        copy = GraphState(graph=self.graph,
                          unraveled_graph=self.unraveled_graph,
                          fusion_network=self.fusion_network)

        copy.data = self.data.copy()

        return copy


def _simulate_single(n_iter, seed, graph, **kwargs):
    ogs = GraphState(graph=graph)
    res = ogs.simulate(n_iter=n_iter, seed=seed, verbose=False, **kwargs)
    res['best_ogs'] = ogs

    return res
