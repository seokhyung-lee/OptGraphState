<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>optgraphstate API documentation</title>
<meta name="description" content="**Version 0.1.2** â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>optgraphstate</code></h1>
</header>
<section id="section-intro">
<p><strong>Version 0.1.2</strong></p>
<p><strong>OptGraphState</strong> is a python package that implements the graph-theoretical
strategy to optimize the fusion-based generation of any graph state.
The package has the following features:</p>
<ul>
<li>Finding a resource-efficient method of generating a given graph state through
type-II fusions from multiple basic resource states, which are three-qubit
linear graph states.</li>
<li>Computing the corresponding resource overhead, which is quantified by the
average number of required basic resource states or fusion attempts.</li>
<li>Visualizing the original graph (of the graph state you want to generate),
unraveled graphs, and fusion networks. An unraveled graph is a simplified graph
where the corresponding graph state is equivalent to the desired graph state up
to fusions and single-qubit Clifford operations. A fusion network is a graph
that instructs the fusions between basic resource states required to generate
the desired graph state.</li>
<li>Various predefined sample graphs for input.</li>
</ul>
<p>Github: <a href="https://github.com/seokhyung-lee/OptGraphState">https://github.com/seokhyung-lee/OptGraphState</a></p>
<p>Tutorials: <a href="https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf">https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf</a></p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
**Version 0.1.2**

**OptGraphState** is a python package that implements the graph-theoretical
strategy to optimize the fusion-based generation of any graph state.
The package has the following features:

- Finding a resource-efficient method of generating a given graph state through
type-II fusions from multiple basic resource states, which are three-qubit
linear graph states.
- Computing the corresponding resource overhead, which is quantified by the
average number of required basic resource states or fusion attempts.
- Visualizing the original graph (of the graph state you want to generate),
unraveled graphs, and fusion networks. An unraveled graph is a simplified graph
where the corresponding graph state is equivalent to the desired graph state up
to fusions and single-qubit Clifford operations. A fusion network is a graph
that instructs the fusions between basic resource states required to generate
the desired graph state.
- Various predefined sample graphs for input.

Github: https://github.com/seokhyung-lee/OptGraphState

Tutorials: https://github.com/seokhyung-lee/OptGraphState/raw/main/tutorials.pdf
&#34;&#34;&#34;

import time
import os
import sys

import networkx as nx

from .graph_tools import *
from .visualization import *

try:
    import parmap
except ModuleNotFoundError:
    pass


def _max_seed():
    return 2**32


class GraphState:
    #: Graph of the graph state to investigate.
    graph: ig.Graph
    #: Unraveled graph generated by unraveling the original graph/
    #:
    #: It is `None` before the unraveled graph is created.
    #: See Sec. 7 of our tutorial for the list of its vertex attributes.
    unraveled_graph: ig.Graph
    #: Fuson network constructed from the unraveled or original graph.
    #:
    #: It is `None` before the fusion network is created.
    #: See Sec. 7 of our tutorial for the list of its vertex and edge
    #: attributes.
    fusion_network: ig.Graph
    #: Any data obtained during unraveling the graph, constructing the fusion
    #: network, and calculating the resource overhead.
    data: dict

    def __init__(self,
                 graph=None,
                 edges=None,
                 shape=None,
                 prms=None,
                 cliffords=None,
                 unraveled_graph=None,
                 fusion_network=None):
        &#34;&#34;&#34;
        Class for calculating and optimizing the resource overhead of the
        fusion-based generation of a graph state.

        The graph of the graph state can be given by the following
        three ways:

        1. Given explicitly by [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html) or [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html).
        2. Given by a list of edges.
        3. Chosen among predefined graphs.

        Parameters
        ----------
        graph : None or igraph.Graph or networkx.Graph (default: None)
            Graph of the concerned graph.

            If it is given, `edges`, `shape`, and `prms` are ignored.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html), it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        edges : None or list of 2-tuple of int (default: None)
            List of edges that form the concerned graph.

            Each integer in the tuples indicates a vertex label.

            If it is given and `graph` is `None`, `shape` and `prms` are
            ignored.

        shape : None or str (default: None)
            Shape of the concerned graph chosen among predefined graphs.

            One of `[None, &#39;random&#39;, &#39;complete&#39;, &#39;star&#39;, &#39;linear&#39;, &#39;cycle&#39;,
            &#39;lattice&#39;, &#39;tree&#39;, &#39;rhg&#39;, &#39;repeater&#39;, &#39;parity_encoding&#39;, &#39;ptqc&#39;]`.

            - `shape=&#39;random&#39;` : Random graph for fixed numbers of vertices
            and edges, sampled by the ErdÃ¶s-Renyi model.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
                - `prms[1]` &lt;`int`&gt; : Number of edges.
                - [Optional] `prms[2]` &lt;`None` or `int`&gt; : Random seed. If
                `None`, the current system time is used as the seed. If not
                given, the random number generator is not initialized.
            - `shape=&#39;complete&#39;`, `&#39;star&#39;`, `&#39;linear&#39;`, or `&#39;cycle&#39;` :
            Complete, star, linear, or cycle graph, respectively.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
            - `shape=&#39;lattice&#39;` : Lattice graph.
                - `prms` &lt;`tuple` of `int`&gt; : Numbers of repeated vertices
                along the axes. The dimension of the lattice is
                automatically set as `len(prms)`.
            - `shape=&#39;tree&#39;` : Tree graph where all branches in each
            generation have an equal number of children.
                - `prms[0]` &lt;`int`&gt; : Degree of the root vertex.
                - `prms[i]` (&lt;`int`&gt;, i &gt;= 1) : Number of the children of each
                `i`th-generation branch.
            - `shape=&#39;rhg&#39;` : Raussendorf-Harrington-Goyal lattice with primal
            boundaries only.
                - `prms[0]`, `prms[1]`, `prms[2]` &lt;`int`&gt; : Size of the lattice
                along the three axes in the unit of a cell.
            - `shape=&#39;repeater&#39;` : Repeater graph with 4m vertices.
                - `prms[0]` &lt;`int`&gt; : Parameter m.
            - `shape=&#39;parity_encoding&#39;` : (n, m) parity-encoded graph.
                - `prms[0]` &lt;[`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html)&gt; : Logical-level graph. Can be
                generated with python-igraph library directly or from the
                function `get_graph_from_edges()` or `get_sample_graph`.
                - `prms[1]`, `prms[2]` &lt;`int`&gt; : Parameters n and m of the
                parity encoding.
            - `shape=&#39;ptqc&#39;` : Microcluster for parity-encoding-based
            topological quantum computing protocol.
                - `prms[0]`, `prms[1]` &lt;`int`&gt; : Parameter n and m of the
                parity encoding.
                - `prms[2]` &lt;`bool`&gt; : Whether the H-configuration is
                HIC (`True`) or HIS (`False`).
                - `prms[3]` &lt;`bool`&gt; : Whether the microcluster is
                central (`True`) or side (`False`) one.

        prms : None or tuple or int (default: None)
            Parameters for a predefined graph.

            See the description for parameter `shape`.

            If only one parameter is required, it can be given as a number, not
            a tuple.

        cliffords : None or list of str (default: None)
            Local Clifford gates applied on the qubits of the graph
            state.

            If it is `None`, no Clifford gates are applied on the qubits.

            If it is a `list` of `str`, its length should be equal to the
            number of vertices in the graph. Its i-th element indicates the
            Clifford gate applied on the i-th qubit. For example,
            if it is `&#39;H&#39;`, it means that a Hadamard gate is applied on the
            qubit. If it is `&#39;H-S-Z&#39;`, it means that Hadamard, phase,
            and Z gates are applied in order.

        unraveled_graph : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven unraveled graph.

            The code does not check the validity of the given unraveled graph.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html),
            it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        fusion_network : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven fusion network.

            The code does not check the validity of the given fusion network.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html),
            it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).
        &#34;&#34;&#34;

        def convert_type(g, varname):
            if g is None:
                return None
            elif isinstance(g, ig.Graph):
                return g
            elif isinstance(g, nx.Graph):
                return ig.Graph.from_networkx(g)
            else:
                raise TypeError(f&#39;Parameter {varname} should be igraph.Graph &#39;
                                f&#39;or networkx.Graph.&#39;)

        if graph is not None:
            self.graph = convert_type(graph, &#39;graph&#39;)

        elif edges is not None:
            self.graph = ig.Graph(edges=edges)

        elif shape is not None:
            try:
                prms[0]
            except TypeError:
                prms = (prms,)

            self.graph = get_sample_graph(shape, *prms)

        else:
            raise ValueError(
                &#34;At least one of graph, edges, and shape should be given.&#34;)

        self.graph.vs[&#39;name&#39;] = [str(vid) for vid in
                                 range(self.graph.vcount())]

        if cliffords is not None and edges is None:
            self.graph.vs[&#39;clifford&#39;] = cliffords

        self.unraveled_graph = convert_type(unraveled_graph, &#39;unraveled_graph&#39;)

        self.fusion_network = convert_type(fusion_network, &#39;fusion_network&#39;)

        self.data = {}

    def initialize(self):
        &#34;&#34;&#34;
        Initialize the created unraveled graph and fusion network and the
        calculation data.
        &#34;&#34;&#34;
        self.unraveled_graph = None
        self.fusion_network = None
        self.data = {}

    def unravel_graph(self,
                      unravel_bcs_first=&#39;random&#39;,
                      plot=False,
                      verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

        The unraveled graph is saved in `self.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are
            unraveled.
            - `False`: cliques are unraveled first, then BCSs are
            unraveled.&lt;br&gt;
            - `&#39;random&#39;`: the order is randomly chosen.

        plot : bool (default: False)
            Whether to plot the unraveled graph after unraveling.

        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Information on the unraveled BCSs.

            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.

        cliques : list of list of set of str
            Information on the unraveled cliques.

            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        &#34;&#34;&#34;

        if unravel_bcs_first == &#39;random&#39;:
            unravel_bcs_first = np.random.choice([True, False])

        if unravel_bcs_first:
            bcss = self.unravel_bcss(verbose=verbose)
            cliques = self.unravel_cliques(verbose=verbose)
        else:
            cliques = self.unravel_cliques(verbose=verbose)
            bcss = self.unravel_bcss(verbose=verbose)

        if plot or verbose:
            if verbose:
                print(&#39;[Final]&#39;)
            self.plot_graph(unraveled=True)
            plt.show()

        self.data[&#39;unravel&#39;] = True
        self.data[&#39;unravel_bcs_first&#39;] = unravel_bcs_first

        return bcss, cliques

    def unravel_bcss(self, verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Information on the unraveled BCSs.

            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.
        &#34;&#34;&#34;

        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_bcss = []

        new_vertex_name = graph.vcount()

        while True:
            # Repeat until there are no bipartitely-complete subgraphs
            bcs_exist = False
            while True:
                bcss = find_nonoverlapping_bcss(graph, get_name=True)
                if bcss:
                    bcs_exist = True
                else:
                    break

                unraveled_bcss.append(bcss)
                eids_to_remove = []
                for part1, part2 in bcss:
                    if verbose:
                        graph.delete_edges(eids_to_remove)
                        eids_to_remove.clear()
                        print(&#39;bcs to unravel =&#39;, part1, &#39;&amp;&#39;, part2)
                        vertex_color = []
                        for v in graph.vs:
                            if v[&#39;name&#39;] in part1:
                                vertex_color.append(&#39;orange&#39;)
                            elif v[&#39;name&#39;] in part2:
                                vertex_color.append(&#39;blue&#39;)
                            else:
                                vertex_color.append(&#39;white&#39;)
                        self.plot_graph(unraveled=True,
                                        vertex_color=vertex_color)
                        plt.show()

                    eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                           vname1, vname2 in
                                           itertools.product(part1, part2)])

                    vname1 = str(new_vertex_name)
                    vname2 = str(new_vertex_name + 1)
                    new_v1 = graph.add_vertex(name=vname1,
                                              ext_fusion=vname2,
                                              clifford=None)
                    new_v2 = graph.add_vertex(name=vname2,
                                              ext_fusion=vname1,
                                              clifford=None)
                    new_vertex_name += 2

                    graph.add_edges(itertools.product([new_v1], part1))
                    graph.add_edges(itertools.product([new_v2], part2))

                graph.delete_edges(eids_to_remove)

            if not bcs_exist:
                break

        return unraveled_bcss

    def unravel_cliques(self, verbose=False):
        &#34;&#34;&#34;
        Unravel cliques of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        cliques : list of list of set of str
            Information on the unraveled cliques.

            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        &#34;&#34;&#34;
        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_cliques = []

        def apply_clifford(v, clifford):
            org_clifford = v[&#39;clifford&#39;]
            if org_clifford is None:
                new_clifford = clifford
            else:
                new_clifford = &#39;-&#39;.join([clifford, org_clifford])
            v[&#39;clifford&#39;] = new_clifford

        while True:
            cliques = find_nonoverlapping_cliques(graph, get_name=True)

            if not cliques:
                break

            unraveled_cliques.append(cliques)

            for clique in cliques:
                if verbose:
                    print(&#39;clique to unravel =&#39;, clique)
                    vertex_color = [&#39;orange&#39; if vname in clique else &#39;white&#39;
                                    for vname in graph.vs[&#39;name&#39;]]
                    self.plot_graph(unraveled=True, vertex_color=vertex_color)
                    plt.show()
                clique = list(clique)
                clique_size = len(clique)

                # Choose a vertex to apply LC
                degrees = graph.degree(clique)
                min_degree = min(degrees)
                if min_degree == clique_size - 1:
                    # There exists a vertex in the clique that doesn&#39;t have
                    # outer edges
                    vname_LC = [vname for vname, deg in zip(clique, degrees) if
                                deg == min_degree]
                    need_to_separate = False
                else:
                    vname_LC = clique
                    need_to_separate = True

                if len(vname_LC) &gt; 1:
                    vname_LC = np.random.choice(vname_LC)
                else:
                    vname_LC = vname_LC[0]
                v_LC = graph.vs.find(name=vname_LC)

                # Separate the edges (E) incident to v_LC outside the clique
                # from v_LC
                eids_to_delete = []
                if need_to_separate:
                    # Vertex connected with E
                    new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=v_LC[&#39;clifford&#39;],
                                              ext_fusion=v_LC[&#39;ext_fusion&#39;])

                    # Vertex having an external fusion with v_LC
                    new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=None,
                                              ext_fusion=v_LC[&#39;name&#39;])

                    graph.add_edge(new_v1, new_v2)

                    ngh_vids = graph.neighbors(vname_LC)
                    for ngh_vid in ngh_vids:
                        if graph.vs[ngh_vid][&#39;name&#39;] not in clique:
                            graph.add_edge(ngh_vid, new_v1)
                            eids_to_delete.append(graph.get_eid(vname_LC,
                                                                ngh_vid))

                    vname_org_ext_fusion = v_LC[&#39;ext_fusion&#39;]
                    if vname_org_ext_fusion is not None:
                        v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                        v_org_ext_fusion[&#39;ext_fusion&#39;] = new_v1[&#39;name&#39;]

                    v_LC[&#39;ext_fusion&#39;] = new_v2[&#39;name&#39;]

                    v_LC[&#39;name&#39;], new_v1[&#39;name&#39;] = new_v1[&#39;name&#39;], vname_LC

                # Apply LC
                adj_vnames = set(clique) - {vname_LC}
                apply_clifford(v_LC, &#39;RX&#39;)
                for adj_vname in adj_vnames:
                    adj_v = graph.vs.find(name=adj_vname)
                    apply_clifford(adj_v, &#39;RZ&#39;)

                new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                      vname1, vname2 in
                                      itertools.combinations(adj_vnames, r=2)]
                eids_to_delete.extend(new_eids_to_delete)
                graph.delete_edges(eids_to_delete)

        return unraveled_cliques

    def build_fusion_network(self,
                             use_unraveled_graph=True,
                             plot=False,
                             verbose=False):
        &#34;&#34;&#34;
        Build a fusion network from the original graph or unraveled graph.

        If you want to build it from the unraveled graph, at least one of
        `GraphState.unravel_graph()`, `GraphState.unravel_bcss()`, and
        `GraphState.unravel_cliques()` must be executed beforehand.

        The constructed fusion network is saved in `GraphState.fusion_network`
        as [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        use_unraveled_graph : bool (default: True)
            Whether to use the unraveled graph or the original graph for
            building a fusion network.

        plot : bool (default: False)
            Whether to plot the fusion network after building it.

        verbose : bool (default: False)
            Whether to print logs.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if use_unraveled_graph else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled qubit graph created.&#34;)

        # Fusion network
        network = ig.Graph()
        self.fusion_network = network
        node_groups = {}

        # Links inside star graphs
        for v in graph.vs:
            num_internal_nodes = v.degree() - 1
            vname = v[&#39;name&#39;]
            if num_internal_nodes &gt;= 1:

                # Add nodes
                nid_init = network.vcount()
                seed = np.random.randint(0, num_internal_nodes)
                node_names = [vname if i == 0 else f&#39;{vname}-{i}&#39; for
                              i in itertools.chain(range(seed, -1, -1),
                                                   range(seed + 1,
                                                         num_internal_nodes))]
                attr = {
                    &#39;name&#39;: node_names,
                    &#39;seed&#39;: [True if i == seed else False for i in
                             range(num_internal_nodes)],
                    &#39;node_group&#39;: vname,
                    # &#39;clifford_root&#39;: None,
                    # &#39;clifford_leaves&#39;: None
                }
                network.add_vertices(num_internal_nodes, attributes=attr)
                node_groups[vname] \
                    = network.vs[nid_init:nid_init + num_internal_nodes]

                if num_internal_nodes &gt;= 2:
                    # Connect internal links
                    links = [(nid, nid + 1) for nid
                             in range(nid_init,
                                      nid_init + num_internal_nodes - 1)]
                    attr = {
                        &#39;kind&#39;: &#34;RL&#34;,
                        &#39;root_node&#39;: [
                            node_names[i] if i &lt; seed else node_names[i + 1]
                            for i in range(num_internal_nodes - 1)],
                        &#39;cliffords&#39;: {}
                    }
                    network.add_edges(links, attributes=attr)

        # Links between star graphs
        for e in graph.es:
            vs = [e.source_vertex, e.target_vertex]
            deg_vs = graph.degree(vs)

            if deg_vs[0] &gt; 1 and deg_vs[1] &gt; 1:
                nodes_to_connect = []
                for v in vs:
                    vname = v[&#39;name&#39;]
                    nodes = node_groups[vname].select(
                        lambda node: node.degree() &lt; (2 if node[&#39;seed&#39;] else 3)
                    )
                    nodes_to_connect.append(np.random.choice(nodes))
                network.add_edge(*nodes_to_connect,
                                 kind=&#39;LL&#39;,
                                 root_node=None,
                                 cliffords={})

        if verbose:
            print(&#34;Fusion network of the unraveled graph:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Set of seed node names where root vertices are connected by
        # external fusions.
        nnames_root_connected = set()
        is_node_not_full = lambda node: node.degree() &lt; (
            2 if node[&#39;seed&#39;] and (
                    node[&#39;name&#39;] not in nnames_root_connected) else 3)

        def get_nodes_containing_vertex(vname):
            try:
                node = node_groups[vname].find(name=vname)
                is_root = True
                seed_node_name = vname
            except KeyError:
                ngh = graph.vs[graph.neighbors(vname)[0]]
                seed_node_name = ngh[&#39;name&#39;]
                nodes = node_groups[seed_node_name].select(is_node_not_full)
                node = np.random.choice(nodes)
                is_root = False

            return node, is_root, seed_node_name

        vs_attrs = graph.vs.attributes()

        # Links by external fusions
        if &#39;ext_fusion&#39; in vs_attrs:
            vnames_to_skip = set()
            for v1 in graph.vs.select(ext_fusion_ne=None):
                vname1 = v1[&#39;name&#39;]
                if vname1 in vnames_to_skip:
                    continue
                vname2 = v1[&#39;ext_fusion&#39;]
                v2 = graph.vs.find(name=vname2)
                vnames_to_skip.add(vname2)

                node1, is_root1, _ = get_nodes_containing_vertex(vname1)
                node2, is_root2, _ = get_nodes_containing_vertex(vname2)
                if is_root1 and is_root2:
                    kind = &#39;RR&#39;
                    root_node = None
                    nnames_root_connected.add(node1[&#39;name&#39;])
                    nnames_root_connected.add(node2[&#39;name&#39;])
                elif not is_root1 and not is_root2:
                    kind = &#39;LL&#39;
                    root_node = None
                else:
                    kind = &#39;RL&#39;
                    root_node = node1[&#39;name&#39;] if is_root1 else node2[&#39;name&#39;]
                    nnames_root_connected.add(root_node)

                cliffords = {}
                cl1 = v1[&#39;clifford&#39;]
                cl2 = v2[&#39;clifford&#39;]

                for node, cl in zip([node1, node2], [cl1, cl2]):
                    if cl is not None:
                        cliffords[node[&#39;name&#39;]] = cl

                network.add_edge(node1,
                                 node2,
                                 kind=kind,
                                 root_node=root_node,
                                 cliffords=cliffords)

        network.es[&#39;name&#39;] = [str(eid) for eid in range(network.ecount())]

        if verbose:
            print(&#34;Add external fusions:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Clifford gates on surviving qubits
        # if &#39;clifford&#39; in vs_attrs:
        #     cls_in_node_group_leaves = {}
        #     for v_cl in graph.vs.select(clifford_ne=None, ext_fusion=None):
        #         vname = v_cl[&#39;name&#39;]
        #         _, is_root, seed_node_name = get_nodes_containing_vertex(vname)
        #         seed_node = network.vs.find(name=seed_node_name)
        #         cl = v_cl[&#39;clifford&#39;]
        #
        #         if is_root:
        #             if seed_node_name not in nnames_root_connected:
        #                 seed_node[&#39;clifford_root&#39;] = cl
        #
        #         else:
        #             try:
        #                 cls_in_node_group_leaves[seed_node_name].append(cl)
        #             except KeyError:
        #                 cls_in_node_group_leaves[seed_node_name] = [cl]
        #
        #     for seed_node_name, cls in cls_in_node_group_leaves.items():
        #         node_group = node_groups[seed_node_name]
        #         nums_surviving_leaves = []
        #         for node in node_group:
        #             if node[&#39;name&#39;] in nnames_root_connected:
        #                 num_surviving_leaves = 3 - node.degree()
        #             else:
        #                 num_surviving_leaves = 2 - node.degree()
        #             nums_surviving_leaves.append(num_surviving_leaves)
        #         total_num_surviving_leaves = sum(nums_surviving_leaves)
        #
        #         if len(cls) &lt; total_num_surviving_leaves:
        #             cls.extend([None]
        #                        * (total_num_surviving_leaves - len(cls)))
        #         np.random.shuffle(cls)
        #
        #         i_start = 0
        #         for node, num_leaves in zip(node_group, nums_surviving_leaves):
        #             cls_current_node = cls[i_start:i_start + num_leaves]
        #             cls_current_node = [cl for cl in cls_current_node
        #                                 if cl is not None]
        #             node[&#39;clifford_leaves&#39;] = cls_current_node
        #             i_start += num_leaves

        # if verbose:
        #     print(&#34;Apply Clifford gates:&#34;)
        #     self.plot_fusion_network()
        #     plt.show()

        self.fusion_network = network

        if plot:
            print(&#34;Final:&#34;)
            self.plot_fusion_network()
            plt.show()

    def _contract_edge(self,
                       fusion_network,
                       ename_to_merge):
        ename_to_merge = str(ename_to_merge)

        e_to_merge = fusion_network.es.find(name=ename_to_merge)
        v_merged, v_removed \
            = e_to_merge.source_vertex, e_to_merge.target_vertex
        enames_updated_weight = []

        if v_merged.degree() &lt; v_removed.degree():
            v_merged, v_removed = v_removed, v_merged

        vname_merged = v_merged[&#39;name&#39;]
        vname_removed = v_removed[&#39;name&#39;]

        v_merged[&#39;weight&#39;] = e_to_merge[&#39;weight&#39;]
        v_merged[&#39;weight_f&#39;] = e_to_merge[&#39;weight_f&#39;]
        v_merged[&#39;order&#39;] = max(v_merged[&#39;order&#39;], v_removed[&#39;order&#39;]) + 1

        assert vname_merged != vname_removed

        eids_to_delete = list(set(fusion_network.incident(v_removed)))
        v_removed[&#39;on&#39;] = False

        for eid_connected in eids_to_delete:
            e_connected = fusion_network.es[eid_connected]
            ename_connected = e_connected[&#39;name&#39;]
            if ename_connected != ename_to_merge:
                enames_updated_weight.append(ename_connected)
                vs_ngh = e_connected.source_vertex, e_connected.target_vertex
                new_edge = [v_merged if v_ngh[&#39;name&#39;] == vname_removed
                            else v_ngh for v_ngh in vs_ngh]
                if new_edge[0] == new_edge[1]:  # If a loop is formed
                    v_vrt = fusion_network.add_vertex(
                        name=f&#39;vrt_{fusion_network.vcount()}&#39;,
                        weight=0,
                        weight_f=0,
                        order=0
                    )
                    new_edge = [v_merged, v_vrt]

                fusion_network.add_edge(*new_edge,
                                        name=ename_connected,
                                        weight=None,
                                        weight_f=None)

        fusion_network.delete_edges(eids_to_delete)

        p_succ = fusion_network[&#39;p_succ&#39;]
        for eid_connected in list(set(fusion_network.incident(v_merged))):
            e_connected = fusion_network.es[eid_connected]
            v_ngh1, v_ngh2 = e_connected.source_vertex, e_connected.target_vertex

            assert v_ngh1 != v_ngh2
            e_connected[&#39;weight&#39;] \
                = (v_ngh1[&#39;weight&#39;] + v_ngh2[&#39;weight&#39;]) / p_succ
            e_connected[&#39;weight_f&#39;] \
                = (v_ngh1[&#39;weight_f&#39;] + v_ngh2[&#39;weight_f&#39;] + 1) / p_succ

        self.fusion_network.es.find(name=ename_to_merge)[&#39;order&#39;] \
            = v_merged[&#39;order&#39;]

        return enames_updated_weight

    def calculate_overhead(self,
                           p_succ=0.5,
                           strategy=&#39;weight_and_matching&#39;,
                           optimize_num_fusions=False,
                           fusion_order=None):
        &#34;&#34;&#34;
        Calculate the resource overhead from the fusion network.

        `GraphState.build_fusion_network()` must be executed beforehand.

        The resulting data is saved in `GraphState.data`.

        Parameters
        ----------
        p_succ : float (default: 0.5)
            Success probability of a fusion.

        strategy: str, one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: &#39;weight_and_matching&#39;)
            Strategy for determining the edge to contract.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        optimize_num_fusions : bool
            If `True`, the average number of required fusion attempts are used
            to quantify resource overheads instead of the average number of
            required basic resource states.

        fusion_order : None or list of {int or str} (default: None)
            Fusion order given explicitly as vertex names.

            If it is not `None`, parameter `strategy` is ignored.

        Returns
        -------
        data : dict
            Outcomes of the calculation, which is a shallow copy of
            `GraphState.data`.&lt;br&gt;
            The calculated overhead and number of steps can be obtained from
            `data[&#39;overhead&#39;]` and `data[&#39;num_steps&#39;]`, respectively.
        &#34;&#34;&#34;

        if self.fusion_network is None:
            raise ValueError(&#34;No fusion network created&#34;)

        # Trivial cases
        node_num = self.fusion_network.vcount()
        if node_num == 0:
            self.data[&#39;overhead&#39;] = 0
            self.data[&#39;num_fusions&#39;] = 0
            self.data[&#39;num_steps&#39;] = 0
            return self.data
        elif node_num == 1:
            self.data[&#39;overhead&#39;] = 1
            self.data[&#39;num_fusions&#39;] = 0
            self.data[&#39;num_steps&#39;] = 0
            return self.data

        if fusion_order is None:
            fusion_order = []
            is_fusion_order_given = False
        else:
            is_fusion_order_given = True

        self.fusion_network.es[&#39;order&#39;] = None

        # Initialize intermediate fusion network
        network = self.fusion_network.copy()
        network[&#39;p_succ&#39;] = p_succ
        network.vs[&#39;weight&#39;] = 1
        network.vs[&#39;weight_f&#39;] = 0
        network.vs[&#39;order&#39;] = 0
        network.vs[&#39;on&#39;] = True
        network.es[&#39;weight&#39;] = 2 / p_succ
        network.es[&#39;weight_f&#39;] = 1 / p_succ
        del network.es[&#39;order&#39;]

        turn = 0

        weight_key = &#39;weight_f&#39; if optimize_num_fusions else &#39;weight&#39;

        # Iterate until no edges remain in the fusion network
        while True:
            if not network.ecount():
                break

            if is_fusion_order_given:
                enames_curr_step = [str(fusion_order[turn])]
                is_parellel = True

            elif strategy == &#39;weight&#39;:
                min_weight = min(network.es[weight_key])
                eids_min_weight = network.es.select(weight=min_weight)
                enames_curr_step = eids_min_weight[&#39;name&#39;]
                is_parellel = len(enames_curr_step) == 1

            # elif strategy == &#39;betweenness&#39;:
            #     eb = np.array(network.edge_betweenness())
            #     min_eb = np.min(eb)
            #     eids_curr_step = np.nonzero(eb == min_eb)[0]
            #     enames_curr_step = [network.es[eid][&#39;name&#39;] for eid in
            #     eids_curr_step]
            #     is_parellel = len(enames_curr_step) == 1
            #
            # elif strategy == &#39;weight_and_betweenness&#39;:
            #     min_weight = min(network.es[&#39;weight&#39;])
            #     eids_min_weight = network.es.select(weight=min_weight)
            #     es_min_ovh = eids_min_weight
            #
            #     eb = network.edge_betweenness()
            #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
            #     min_eb = np.min(ebs_min_ovh)
            #     enames_curr_step = [es_min_ovh[i][&#39;name&#39;] for i in
            #     np.nonzero(ebs_min_ovh == min_eb)[0]]
            #     is_parellel = len(enames_curr_step) == 1

            elif &#39;matching&#39; in strategy:
                if strategy == &#39;weight_and_matching&#39;:
                    min_weight = min(network.es[weight_key])
                    if optimize_num_fusions:
                        es_min_weight = network.es.select(weight_f=min_weight)
                    else:
                        es_min_weight = network.es.select(weight=min_weight)
                    subnetwork = network.subgraph_edges(es_min_weight)
                else:
                    subnetwork = network

                subnetwork_nx = subnetwork.to_networkx()
                if isinstance(subnetwork_nx, nx.MultiGraph):
                    subnetwork_nx = nx.Graph(subnetwork_nx)
                matching = nx.max_weight_matching(subnetwork_nx, weight=None)
                enames_curr_step = \
                    subnetwork.es[subnetwork.get_eids(matching)][&#39;name&#39;]

                is_parellel = True

            elif strategy == &#39;random&#39;:
                enames_curr_step = [np.random.choice(network.es[&#39;name&#39;])]
                is_parellel = True

            else:
                raise ValueError

            recalculated_enames = []

            # if get_fusion_order and not is_fusion_order_given:
            #     fusion_order_curr_step = set()
            #     fusion_order.append(fusion_order_curr_step)

            while True:
                if not is_parellel:
                    for rec_ename in recalculated_enames:
                        try:
                            enames_curr_step.remove(rec_ename)
                        except ValueError:
                            pass

                if not enames_curr_step:
                    break

                recalculated_enames.clear()

                if is_parellel:
                    ename_to_merge = enames_curr_step.pop()
                else:
                    ename_to_merge = np.random.choice(enames_curr_step)
                    enames_curr_step.remove(ename_to_merge)

                # if get_fusion_order:
                #     e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                #     v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                #     fusion_order_curr_step.add((v1[&#39;name&#39;], v2[&#39;name&#39;],
                #                                 ename_to_merge))

                enames_updated_weight \
                    = self._contract_edge(network,
                                          ename_to_merge)

                recalculated_enames.extend(enames_updated_weight)

        v_final = network.vs.select(on=True)
        overhead = sum(v_final[&#39;weight&#39;])
        num_fusions = sum(v_final[&#39;weight_f&#39;])
        num_steps = max(v_final[&#39;order&#39;])

        results = {
            &#39;overhead&#39;: overhead,
            &#39;num_fusions&#39;: num_fusions,
            &#39;num_steps&#39;: num_steps,
            &#39;fusion_order_strategy&#39;: strategy,
            &#39;p_succ&#39;: p_succ,
        }

        if optimize_num_fusions:
            results[&#39;optimize_num_fusions&#39;] = True

        # if get_fusion_order:
        #     results[&#39;fusion_order&#39;] = fusion_order

        self.data.update(results)

        return self.data.copy()

    def simulate(self,
                 n_iter,
                 p_succ=0.5,
                 mp=False,
                 n_procs=None,
                 get_all_data=False,
                 get_all_graphs=False,
                 get_all_fusion_networks=False,
                 unravel=True,
                 unravel_bcs_first=&#39;random&#39;,
                 fusion_order_strategy=&#39;weight_and_matching&#39;,
                 optimize_num_fusions=False,
                 seed=&#39;keep&#39;,
                 verbose=True,
                 pbar=False,
                 **kwargs):
        &#34;&#34;&#34;
        Execute the strategy for a fixed number of iterations and obtain the
        best one only (by default).

        Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
        `GraphState.fusion_network` are updated according to the result of the
        best sample.

        Parameters
        ----------
        n_iter : int
            Iteration number.

        p_succ : float (default: 0.5)
            Success probability of a fusion.

        mp : bool (default: False)
            Whether to use multiprocessing for the iterations.

            Package *parmap* should be installed to use it.

        n_procs : None or int (default: None)
            Maximal number of simultaneous processes for multiprocessing.

            If it is `None`, the number of CPUs is used.

            Ignored when `mp` is `False`.

        get_all_data : bool (default: False)
            Whether to obtain the data (overheads, numbers of steps, etc.) from
            all samples or only the best sample.

        get_all_graphs : bool (default: False)
            Whether to obtain the unraveled graphs from all samples or only the
            best sample.

        get_all_fusion_networks : bool (default: False)
            Whether to obtain the fusion networks from all samples or only the
            best sample.

        unravel : bool (default: True)
            Whether to unravel the graph or not.

        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are unraveled.
            - `False`, cliques are unraveled first, then BCSs are unraveled.
            - `&#39;random&#39;`, the order is randomly chosen.

        fusion_order_strategy : one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: `weight_and_matching&#39;)
            Strategy for determining the edge to contract in each step.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        optimize_num_fusions : bool
            If `True`, use the averagte number of fusion attempts to quantify
            resource overheads instead of the average number of basic resource
            states.

        seed : &#39;keep&#39; or None or int (default: &#39;keep&#39;)
            Random seed.

            - `&#39;keep&#39;`: The seed is not initialized.
            - `None`: The current time is used as the random seed.
            - `int`: The given number is used as the random seed.

            If `n_iter&gt;1`, the given seed is used to sample random seeds for
            individual iterations. However, if `n_iter==1`, the given seed is
            used as the random seed for the (only one) iteration itself.

        verbose : bool (default: True)
            Whether to print logs.

        pbar : bool (default: False)
            Whether to show a progress bar.

            Ignored if `mp` is `False`

        kwargs : dict
            Additional keyword arguments for calculating overheads.

            See the description of `GraphState.calculate_overhead()`.

        Returns
        -------
        res : dict
            Result of the iterations.

            By default, only the information of the best sample is returned.
        &#34;&#34;&#34;

        t0 = time.time()

        overhead_key = &#39;num_fusions&#39; if optimize_num_fusions else &#39;overhead&#39;

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        if mp:
            if n_procs is None:
                n_procs = os.cpu_count()
            mp = mp and n_iter &gt;= n_procs

        if not mp:
            if verbose:
                print(&#34;Multiprocessing OFF.&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}...&#34;)

            if n_iter == 1 and seed is not None and seed != &#39;keep&#39;:
                seeds_samples = [seed]
            else:
                seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

            overheads = [] if get_all_data else None
            nums_fusions = [] if get_all_data else None
            nums_steps = [] if get_all_data else None
            seeds = [] if get_all_data else None
            unravalled_graphs = [] if get_all_graphs else None
            fusion_networks = [] if get_all_fusion_networks else None

            best_sample = None
            lowest_overhead = None
            for i_sample in range(n_iter):
                seed_sample = seeds_samples[i_sample]
                np.random.seed(seed_sample)

                if unravel:
                    self.unraveled_graph = None
                    try:
                        self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                    except:
                        print(&#39;Error occurs during unraveling&#39;)
                        print(&#39;seed =&#39;, seed_sample)
                        raise ValueError

                try:
                    self.build_fusion_network(use_unraveled_graph=unravel)
                except:
                    print(&#39;Error occurs during building fusion network&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                try:
                    data_now = self.calculate_overhead(
                        p_succ=p_succ,
                        strategy=fusion_order_strategy,
                        optimize_num_fusions=optimize_num_fusions,
                        **kwargs)
                except:
                    print(&#39;Error occurs during calculating overhead&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                overhead_now = data_now[overhead_key]
                num_steps_now = data_now[&#39;num_steps&#39;]
                self.data[&#39;seed&#39;] = seed_sample

                if lowest_overhead is None or overhead_now &lt; lowest_overhead:
                    best_sample = i_sample
                    lowest_overhead = overhead_now
                    best_ogs = self.copy()

                if get_all_data:
                    overheads.append(data_now[&#39;overhead&#39;])
                    nums_fusions.append(data_now[&#39;num_fusions&#39;])
                    nums_steps.append(num_steps_now)
                    seeds.append(seed_sample)

                if get_all_graphs:
                    unravalled_graphs.append(self.unraveled_graph)

                if get_all_fusion_networks:
                    fusion_networks.append(self.fusion_network)

            res = {
                &#39;best_overhead&#39;: best_ogs.data[&#39;overhead&#39;],
                &#39;best_num_fusions&#39;: best_ogs.data[&#39;num_fusions&#39;],
                &#39;best_num_steps&#39;: best_ogs.data[&#39;num_steps&#39;],
                &#39;best_seed&#39;: best_ogs.data[&#39;seed&#39;],
                &#39;n_iter&#39;: n_iter}

            if unravel:
                res[&#39;unravel_bcs_first&#39;] = best_ogs.data[&#39;unravel_bcs_first&#39;]

            if get_all_data or get_all_graphs or get_all_fusion_networks:
                res[&#39;best_sample&#39;] = best_sample

                if get_all_data:
                    res[&#39;overheads&#39;] = overheads
                    res[&#39;nums_fusions&#39;] = nums_fusions
                    res[&#39;nums_steps&#39;] = nums_steps
                    res[&#39;seeds&#39;] = seeds

                if get_all_graphs:
                    res[&#39;unraveled_graphs&#39;] = unravalled_graphs

                if get_all_fusion_networks:
                    res[&#39;fusion_networks&#39;] = fusion_networks

        else:
            if &#39;parmap&#39; not in sys.modules:
                raise ModuleNotFoundError(&#34;Package parmap is not installed.&#34;)

            if verbose:
                print(f&#34;Multiprocessing ON: n_procs = {n_procs}&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}... &#34;, end=&#39;&#39;)

            additional_keys = []
            if get_all_data:
                additional_keys.extend([&#39;overheads&#39;, &#39;nums_fusions&#39;,
                                        &#39;nums_steps&#39;, &#39;seeds&#39;])
            if get_all_graphs:
                additional_keys.append(&#39;unraveled_graphs&#39;)
            if get_all_fusion_networks:
                additional_keys.append(&#39;fusion_networks&#39;)

            left = n_iter % n_procs
            ns_samples = [n_iter // n_procs] * n_procs
            for i in range(left):
                ns_samples[i] += 1

            seeds = np.random.randint(0, _max_seed(), size=n_procs)

            res_procs = parmap.starmap(
                _simulate_single,
                list(zip(ns_samples, seeds)),
                self.graph,
                p_succ=p_succ,
                get_all_data=get_all_data,
                get_all_graphs=get_all_graphs,
                get_all_fusion_networks=get_all_fusion_networks,
                unravel=unravel,
                unravel_bcs_first=unravel_bcs_first,
                fusion_order_strategy=fusion_order_strategy,
                optimize_num_fusions=optimize_num_fusions,
                pm_pbar=pbar,
                **kwargs)
            best_proc = np.argmin(
                [res_each[f&#39;best_{overhead_key}&#39;] for res_each in res_procs]
            )
            res = res_procs[best_proc]
            res[&#39;n_iter&#39;] = n_iter
            best_ogs = res[&#39;best_ogs&#39;]
            del res[&#39;best_ogs&#39;]

            if additional_keys:
                res[&#39;best_sample&#39;] += sum(ns_samples[:best_proc])

            for key in additional_keys:
                vals = [res_each[key] for res_each in res_procs]
                res[key] = list(itertools.chain(*vals))

        if verbose:
            print(f&#34;Done. Best: {res[f&#39;best_{overhead_key}&#39;]:.2f} &#34;
                  f&#34;({time.time() - t0:.2f} s)&#34;)

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.data = best_ogs.data

        return res

    def simulate_adaptive(self,
                          init_n_iter,
                          mul=2,
                          p_succ=0.5,
                          mp=False,
                          n_procs=None,
                          get_all_data=False,
                          get_all_graphs=False,
                          get_all_fusion_networks=False,
                          unravel=True,
                          unravel_bcs_first=&#39;random&#39;,
                          fusion_order_strategy=&#39;weight_and_matching&#39;,
                          optimize_num_fusions=False,
                          seed=&#39;keep&#39;,
                          verbose=True,
                          pbar=False,
                          **kwargs):
        &#34;&#34;&#34;
        Run the adaptive iteration method for the strategy and obtain the
        best one only (by default).

        The adaptive iteration method looks for the best iteration while
        keeps increasing the iteration number until a certain condition
        meets. In detail, denoting N iterations of the strategy as R(N),
        R(`init_n_iter`) is first executed and `q0` is obtained which is the
        lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
        and `q1` is obtained similarly. If `q0 &lt;= q1`, `q0` is returned. If
        otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
        If `q1 &lt;= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
        is executed, and so on.

        Parameters
        ----------
        init_n_iter : int
            Initial iteration number.

        mul : int (default: 2)
            Multiplicative factor of the iteration number.

        See the description of `GraphState.simulate()` for the other parameters.

        Returns
        -------
        res : dict
            Result of the iterations.

            By default, only the information of the best sample is given.
        &#34;&#34;&#34;

        if mp and n_procs is None:
            n_procs = os.cpu_count()

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        additional_keys = []
        if get_all_data:
            additional_keys.extend([&#39;overheads&#39;, &#39;nums_fusions&#39;, &#39;nums_steps&#39;])
        if get_all_graphs:
            additional_keys.append(&#39;unraveled_graphs&#39;)
        if get_all_fusion_networks:
            additional_keys.append(&#39;fusion_networks&#39;)

        if verbose:
            if mp:
                print(f&#34;Multiprocessing (n_procs = {n_procs})&#34;)
            else:
                print(&#34;No multiprocessing&#34;)

        best_overhead_key \
            = &#39;best_num_fusions&#39; if optimize_num_fusions else &#39;best_overhead&#39;

        n_iter_history = []
        n_iter_now = init_n_iter
        res = None

        while True:
            if verbose:
                print(f&#34;Calculating for n_iter = {n_iter_now}... &#34;, end=&#39;&#39;)
            t0 = time.time()

            n_iter_history.append(n_iter_now)
            res_now = self.simulate(
                n_iter=n_iter_now,
                p_succ=p_succ,
                mp=mp,
                n_procs=n_procs,
                get_all_data=get_all_data,
                get_all_graphs=get_all_graphs,
                get_all_fusion_networks=get_all_fusion_networks,
                unravel=unravel,
                unravel_bcs_first=unravel_bcs_first,
                fusion_order_strategy=fusion_order_strategy,
                optimize_num_fusions=optimize_num_fusions,
                verbose=False,
                pbar=pbar,
                **kwargs
            )

            if res is None:
                res = res_now
                best_ogs = self.copy()
                n_iter_now *= mul

            else:
                for key in additional_keys:
                    res[key].extend(res_now[key])

                if res_now[best_overhead_key] &lt; res[best_overhead_key]:
                    for key in additional_keys:
                        res_now[key] = res[key]
                    res = res_now
                    best_ogs = self.copy()

                    n_iter_now *= mul

                else:
                    if verbose:
                        print(f&#34;Done. Best: {res[best_overhead_key]:.2f} (&#34;
                              f&#34;{time.time() - t0:.2f} s)&#34;)
                    break

            if verbose:
                print(f&#34;Done. Best: {res[best_overhead_key]:.2f} &#34;
                      f&#34;({time.time() - t0:.2f} s)&#34;)

        res[&#39;n_iter&#39;] = sum(n_iter_history)

        if additional_keys:
            res[&#39;best_sample&#39;] += res[&#39;best_sample&#39;]

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.data = best_ogs.data

        return res

    def get_instructions(self):
        &#34;&#34;&#34;
        Get the instruction to generate the desired graph state from multiple
        three-qubit linear graph states.

        One of `GraphState.calculate_overhead()`, `GraphState.simulate()`, and
        `GraphState.simulate_adaptive()` must be executed beforehand.

        Returns
        -------
        node_names : list of str
            List of the names of nodes in the fusion network.

        fusions : dict
            Dictionary that contains the information about required fusions and
            Clifford gates.

            Each required fusion is represented by a 2-tuple of 3-tuples:
            `((n1, q1, cl1), (n2, q2, cl2))`. `n1` and `n2` are the names of
            the nodes involved in the fusion, `q1` and `q2` are `&#39;R&#39;` or `&#39;L&#39;`
            that indicate the qubits undergoing the fusion (`&#39;R&#39;` for a root
            qubit and `&#39;L&#39;` for a leaf qubit), and `cl1` and `cl2` are the
            Clifford gates applied to the qubits before the fusion is
            performed.

            `fusions[i]` for a positive integer `i` is a list of such 2-tuples,
            which indicate fusions that can be done in parallel in the `i`-th
            step.

        qubit_correspondence : dict
            Dictionary that contains the correspondence between the vertices in
            the original graph and the final remaining qubits after performing
            all the fusions.

            For each name (say, `vname`) of a vertex in the original graph,
            `qubit_correspondence[vname]` is a 3-tuple `(node, qubit, cl)`,
            where `node` is the node containing the qubit, `qubit` is either
            `&#39;R&#39;` or `&#39;L&#39;` that indicates whether the qubit is a root or leaf
            qubit, and `cl` is the Clifford gate applied to the qubit.
        &#34;&#34;&#34;
        network = self.fusion_network

        # Fusions
        fusions = {}
        orders = network.es[&#39;order&#39;]
        num_steps = max(orders)
        for order in range(1, num_steps + 1):
            inst_same_order = []
            links = network.es.select(order=order)
            for link in links:
                nname1 = link.source_vertex[&#39;name&#39;]
                nname2 = link.target_vertex[&#39;name&#39;]
                kind = link[&#39;kind&#39;]
                if kind == &#39;RR&#39;:
                    qubit1 = qubit2 = &#39;R&#39;
                elif kind == &#39;LL&#39;:
                    qubit1 = qubit2 = &#39;L&#39;
                else:
                    root_node = link[&#39;root_node&#39;]
                    qubit1 = &#39;R&#39; if root_node == nname1 else &#39;L&#39;
                    qubit2 = &#39;L&#39; if qubit1 == &#39;R&#39; else &#39;R&#39;
                cliffords = link[&#39;cliffords&#39;]
                try:
                    cl1 = cliffords[nname1]
                except KeyError:
                    cl1 = None
                try:
                    cl2 = cliffords[nname2]
                except KeyError:
                    cl2 = None

                inst_same_order.append(((nname1, qubit1, cl1),
                                        (nname2, qubit2, cl2)))

            fusions[order] = inst_same_order

        # Final remaining qubits &amp; Clifford gates on them
        qubit_correspondence = {}
        remaining_leaves = {}
        for vname in self.graph.vs[&#39;name&#39;]:
            v_unrv: ig.Vertex = self.unraveled_graph.vs.find(name=vname)
            cl = v_unrv[&#39;clifford&#39;]

            if v_unrv.degree() &gt; 1:
                corr = (vname, &#39;R&#39;, cl)

            else:
                v_ngh_unrv = v_unrv.neighbors()[0]
                seed_node_name = v_ngh_unrv[&#39;name&#39;]
                try:
                    remaining_leaves_curr \
                        = remaining_leaves[seed_node_name]
                except KeyError:
                    node_group \
                        = network.vs.select(node_group=seed_node_name)
                    remaining_leaves_curr = {}
                    for node in node_group:
                        num_remaining_leaves = 2
                        for link in node.incident():
                            kind = link[&#39;kind&#39;]
                            if kind == &#39;LL&#39; \
                                    or (kind == &#39;RL&#39;
                                        and link[&#39;root_node&#39;] != node[&#39;name&#39;]):
                                num_remaining_leaves -= 1
                        remaining_leaves_curr[node[&#39;name&#39;]] \
                            = num_remaining_leaves
                    remaining_leaves[seed_node_name] = remaining_leaves_curr

                corr = None
                for node_name, num_remaining_leaves in remaining_leaves_curr.items():
                    if num_remaining_leaves:
                        corr = (node_name, &#39;L&#39;, cl)
                        remaining_leaves_curr[node_name] -= 1

                assert corr is not None

            qubit_correspondence[vname] = corr

        node_names = network.vs[&#39;name&#39;]

        return node_names, fusions, qubit_correspondence

    def get_vertex_clifford(self, vertex, unraveled=True):
        &#34;&#34;&#34;
        Get the Clifford gate applied to a vertex in the unraveled graph
        (by default) or the original graph.

        Each Clifford gate is represented by a string. For example, `&#39;RX&#39;`
        and `&#39;RZ&#39;` respectively mean pi/2 X-rotation (Z-rotation). If a qubit
        is subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
        represented by `&#39;RX-RZ&#39;`.

        Parameters
        ----------
        vertex : int or str
            Name of the vertex.

        unraveled : bool (default: True)
            Whether to find the vertex in the unraveled or original graph.

        Returns
        -------
        clifford : None or str
            Clifford gate applied to the vertex.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if unraveled else self.graph
        if &#39;clifford&#39; in graph.vertex_attributes():
            cl = graph.vs.find(name=str(vertex))[&#39;clifford&#39;]
            return cl
        else:
            return None

    def get_link_clifford(self, n1, n2):
        &#34;&#34;&#34;
        Get the Clifford gates that need to be applied to two qubits involved
        in the fusion of a given link.

        Each Clifford gate is represented by a string. For example, `&#39;RX&#39;` and
        `&#39;RZ&#39;` respectively mean pi/2 X-rotation (Z-rotation). If a qubit is
        subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
        represented by `&#39;RX-RZ&#39;`.

        Parameters
        ----------
        n1, n2 : int or str
            Names of the nodes connected by the link.

        Returns
        -------
        cl1, cl2 : None or str
            Clifford gates applied on the two qubits involved in the fusion
            of the link.
        &#34;&#34;&#34;

        network = self.fusion_network
        n1 = str(n1)
        n2 = str(n2)

        link = network.es[network.get_eid(n1, n2)]
        cliffords = link[&#39;cliffords&#39;]
        cls = []
        for n in [n1, n2]:
            try:
                cls.append(cliffords[n])
            except KeyError:
                cls.append(None)

        return tuple(cls)

    def plot_graph(self, unraveled=False, **kwargs):
        &#34;&#34;&#34;
        Plot the original or unraveled graph.

        If the unraveled graph is plotted, edges in the unraveled graph are
        drawn as black solid lines while external fusions are drawn as red
        dashed lines (by default).

        Vertices with Clifford gates are colored in orange (by default).
        These Clifford gates can be obtained by using
        `GraphState.get_vertex_clifford()`.

        Parameters
        ----------
        unraveled : bool (default: False)
            Whether to plot the unraveled graph or the original graph.

        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.

            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (5, 5))
            Size of the figure in inches.

        save : None or str (default: None)
            Path to save the figure.

        show_vertex_names : bool (default: True)
            If `True`, vertex names are shown.

        vertex_color_normal : str (default: &#39;white&#39;)
            Color of vertices without Clifford gates.

        vertex_color_clifford : str (default: &#39;orange&#39;)
            Color of vertices with Clifford gates.

        vertices_to_highlight : None or list of {str or int} (default: None)
            Name of vertices to highlight.

        vertex_color_highlight : str (default: purple)
            Color of the highlighted vertices.

            Ignored if `vertices_to_highlight` is `None`.

        edge_color_normal : str (default: black)
            Color of edges in the graph.

        edge_color_fusion : str (default: red)
            Color of lines for external fusions.

            Ignored if `unraveled` is `False`.

        edge_style_fusion : str (default: &#39;--&#39;)
            Style of lines for external fusions.

        Any other keyword arguments in `igraph.plot()` can be directly used.
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting
        If they are given, they override the above parameters.

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if unraveled else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled graph created.&#34;)

        fig, ax = plot_graph(graph, **kwargs)

        return fig, ax

    def plot_fusion_network(self, **kwargs):
        &#34;&#34;&#34;
        Plot the fusion network.

        Links have different styles and colors depending on their types:

        - &#39;LL&#39;: Black solid line.
        - &#39;RR&#39;: Red dashed line.
        - &#39;RL&#39;: Blue arrow from leaf to root.

        The number placed on each link indicates the order of the fusion. It is
        presented only when the resource overhead has been computed beforehand.

        Links with `&#39;C&#39;` written on them indicate fusions accompanied by
        non-trivial Clifford gates. These Clifford gates can be obtained by
        using `GraphState.get_link_clifford()`.

        Parameters
        ----------
        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.&lt;br&gt;
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (5, 5))
            Size of the figure in inches.

        save : None or str (default: None)
            Path to save the figure.

        show_node_names : bool (default: True)
            If `True`, node names are shown.

        node_color : str (default: &#39;white&#39;)
            Color of nodes.

        show_link_names : bool (default: False)
            If `True`, link names are shown.

        show_fusion_orders : bool (default: True)
            If `True`, fusion orders are shown on links.

            If both `show_link_names` and `show_fusion_orders` are `True`,
            it is shown as `&#39;{link name}-{fusion order}&#39;`

        show_link_cliffords : bool (default: True)
            If `True`, links that correspond to fusions accompanied by
            non-trivial Clifford gates are marked as `&#39;C&#39;`.

            If `show_link_names` or `show_fusion_orders` are `True`, `&#39;C&#39;` is
            appended to the end of the label.

        link_color_ll : str (default: &#39;black&#39;)
            Color of leaf-to-leaf links.

        link_color_rl : str (default: &#39;blue&#39;)
            Color of root-to-leaf links.

        link_color_rr : str (default: &#39;red&#39;)
            Color of root-to-root links.

        arrow_size : float (default: 0.02)
            Size of arrows for root-to-leaf links.

        Any other keyword arguments in igraph.plot can be directly used.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
        If they are given, they override the above parameters.&lt;br&gt;

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        network = self.fusion_network
        if network is None:
            raise ValueError(&#39;No fusion network created.&#39;)

        fig, ax = plot_fusion_network(network, **kwargs)

        return fig, ax

    def copy(self):
        &#34;&#34;&#34;
        Return a **shallow** copy of this object.

        Use `copy.deepcopy()` to get a deep copy.

        Returns
        -------
        copy : GraphState
            Copied instance of itself.
        &#34;&#34;&#34;

        copy = GraphState(graph=self.graph,
                          unraveled_graph=self.unraveled_graph,
                          fusion_network=self.fusion_network)

        copy.data = self.data.copy()

        return copy


def _simulate_single(n_iter, seed, graph, **kwargs):
    ogs = GraphState(graph=graph)
    res = ogs.simulate(n_iter=n_iter, seed=seed, verbose=False, **kwargs)
    res[&#39;best_ogs&#39;] = ogs

    return res</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="optgraphstate.graph_tools" href="graph_tools.html">optgraphstate.graph_tools</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="optgraphstate.utils" href="utils.html">optgraphstate.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="optgraphstate.visualization" href="visualization.html">optgraphstate.visualization</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="optgraphstate.GraphState"><code class="flex name class">
<span>class <span class="ident">GraphState</span></span>
<span>(</span><span>graph=None, edges=None, shape=None, prms=None, cliffords=None, unraveled_graph=None, fusion_network=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for calculating and optimizing the resource overhead of the
fusion-based generation of a graph state.</p>
<p>The graph of the graph state can be given by the following
three ways:</p>
<ol>
<li>Given explicitly by <a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a> or <a href="https://networkx.org/documentation/stable/reference/classes/graph.html"><code>networkx.Graph</code></a>.</li>
<li>Given by a list of edges.</li>
<li>Chosen among predefined graphs.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>None</code> or <code>igraph.Graph</code> or <code>networkx.Graph (default: None)</code></dt>
<dd>
<p>Graph of the concerned graph.</p>
<p>If it is given, <code>edges</code>, <code>shape</code>, and <code>prms</code> are ignored.</p>
<p>If it is <a href="https://networkx.org/documentation/stable/reference/classes/graph.html"><code>networkx.Graph</code></a>, it is internally converted to <a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>2-tuple</code> of <code>int (default: None)</code></dt>
<dd>
<p>List of edges that form the concerned graph.</p>
<p>Each integer in the tuples indicates a vertex label.</p>
<p>If it is given and <code>graph</code> is <code>None</code>, <code>shape</code> and <code>prms</code> are
ignored.</p>
</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>None</code> or <code>str (default: None)</code></dt>
<dd>
<p>Shape of the concerned graph chosen among predefined graphs.</p>
<p>One of <code>[None, 'random', 'complete', 'star', 'linear', 'cycle',
'lattice', 'tree', 'rhg', 'repeater', 'parity_encoding', 'ptqc']</code>.</p>
<ul>
<li><code>shape='random'</code> : Random graph for fixed numbers of vertices
and edges, sampled by the ErdÃ¶s-Renyi model.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Number of vertices.</li>
<li><code>prms[1]</code> &lt;<code>int</code>&gt; : Number of edges.</li>
<li>[Optional] <code>prms[2]</code> &lt;<code>None</code> or <code>int</code>&gt; : Random seed. If
<code>None</code>, the current system time is used as the seed. If not
given, the random number generator is not initialized.</li>
</ul>
</li>
<li><code>shape='complete'</code>, <code>'star'</code>, <code>'linear'</code>, or <code>'cycle'</code> :
Complete, star, linear, or cycle graph, respectively.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Number of vertices.</li>
</ul>
</li>
<li><code>shape='lattice'</code> : Lattice graph.<ul>
<li><code>prms</code> &lt;<code>tuple</code> of <code>int</code>&gt; : Numbers of repeated vertices
along the axes. The dimension of the lattice is
automatically set as <code>len(prms)</code>.</li>
</ul>
</li>
<li><code>shape='tree'</code> : Tree graph where all branches in each
generation have an equal number of children.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Degree of the root vertex.</li>
<li><code>prms[i]</code> (&lt;<code>int</code>&gt;, i &gt;= 1) : Number of the children of each
<code>i</code>th-generation branch.</li>
</ul>
</li>
<li><code>shape='rhg'</code> : Raussendorf-Harrington-Goyal lattice with primal
boundaries only.<ul>
<li><code>prms[0]</code>, <code>prms[1]</code>, <code>prms[2]</code> &lt;<code>int</code>&gt; : Size of the lattice
along the three axes in the unit of a cell.</li>
</ul>
</li>
<li><code>shape='repeater'</code> : Repeater graph with 4m vertices.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Parameter m.</li>
</ul>
</li>
<li><code>shape='parity_encoding'</code> : (n, m) parity-encoded graph.<ul>
<li><code>prms[0]</code> &lt;<a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>&gt; : Logical-level graph. Can be
generated with python-igraph library directly or from the
function <code>get_graph_from_edges()</code> or <code>get_sample_graph</code>.</li>
<li><code>prms[1]</code>, <code>prms[2]</code> &lt;<code>int</code>&gt; : Parameters n and m of the
parity encoding.</li>
</ul>
</li>
<li><code>shape='ptqc'</code> : Microcluster for parity-encoding-based
topological quantum computing protocol.<ul>
<li><code>prms[0]</code>, <code>prms[1]</code> &lt;<code>int</code>&gt; : Parameter n and m of the
parity encoding.</li>
<li><code>prms[2]</code> &lt;<code>bool</code>&gt; : Whether the H-configuration is
HIC (<code>True</code>) or HIS (<code>False</code>).</li>
<li><code>prms[3]</code> &lt;<code>bool</code>&gt; : Whether the microcluster is
central (<code>True</code>) or side (<code>False</code>) one.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>prms</code></strong> :&ensp;<code>None</code> or <code>tuple</code> or <code>int (default: None)</code></dt>
<dd>
<p>Parameters for a predefined graph.</p>
<p>See the description for parameter <code>shape</code>.</p>
<p>If only one parameter is required, it can be given as a number, not
a tuple.</p>
</dd>
<dt><strong><code>cliffords</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>str (default: None)</code></dt>
<dd>
<p>Local Clifford gates applied on the qubits of the graph
state.</p>
<p>If it is <code>None</code>, no Clifford gates are applied on the qubits.</p>
<p>If it is a <code>list</code> of <code>str</code>, its length should be equal to the
number of vertices in the graph. Its i-th element indicates the
Clifford gate applied on the i-th qubit. For example,
if it is <code>'H'</code>, it means that a Hadamard gate is applied on the
qubit. If it is <code>'H-S-Z'</code>, it means that Hadamard, phase,
and Z gates are applied in order.</p>
</dd>
<dt><strong><code>unraveled_graph</code></strong> :&ensp;<code>None</code> or <code>igraph.Graph</code> or <code>networkx.Graph (default: None)</code></dt>
<dd>
<p>Pregiven unraveled graph.</p>
<p>The code does not check the validity of the given unraveled graph.</p>
<p>If it is <a href="https://networkx.org/documentation/stable/reference/classes/graph.html"><code>networkx.Graph</code></a>,
it is internally converted to <a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
</dd>
<dt><strong><code>fusion_network</code></strong> :&ensp;<code>None</code> or <code>igraph.Graph</code> or <code>networkx.Graph (default: None)</code></dt>
<dd>
<p>Pregiven fusion network.</p>
<p>The code does not check the validity of the given fusion network.</p>
<p>If it is <a href="https://networkx.org/documentation/stable/reference/classes/graph.html"><code>networkx.Graph</code></a>,
it is internally converted to <a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphState:
    #: Graph of the graph state to investigate.
    graph: ig.Graph
    #: Unraveled graph generated by unraveling the original graph/
    #:
    #: It is `None` before the unraveled graph is created.
    #: See Sec. 7 of our tutorial for the list of its vertex attributes.
    unraveled_graph: ig.Graph
    #: Fuson network constructed from the unraveled or original graph.
    #:
    #: It is `None` before the fusion network is created.
    #: See Sec. 7 of our tutorial for the list of its vertex and edge
    #: attributes.
    fusion_network: ig.Graph
    #: Any data obtained during unraveling the graph, constructing the fusion
    #: network, and calculating the resource overhead.
    data: dict

    def __init__(self,
                 graph=None,
                 edges=None,
                 shape=None,
                 prms=None,
                 cliffords=None,
                 unraveled_graph=None,
                 fusion_network=None):
        &#34;&#34;&#34;
        Class for calculating and optimizing the resource overhead of the
        fusion-based generation of a graph state.

        The graph of the graph state can be given by the following
        three ways:

        1. Given explicitly by [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html) or [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html).
        2. Given by a list of edges.
        3. Chosen among predefined graphs.

        Parameters
        ----------
        graph : None or igraph.Graph or networkx.Graph (default: None)
            Graph of the concerned graph.

            If it is given, `edges`, `shape`, and `prms` are ignored.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html), it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        edges : None or list of 2-tuple of int (default: None)
            List of edges that form the concerned graph.

            Each integer in the tuples indicates a vertex label.

            If it is given and `graph` is `None`, `shape` and `prms` are
            ignored.

        shape : None or str (default: None)
            Shape of the concerned graph chosen among predefined graphs.

            One of `[None, &#39;random&#39;, &#39;complete&#39;, &#39;star&#39;, &#39;linear&#39;, &#39;cycle&#39;,
            &#39;lattice&#39;, &#39;tree&#39;, &#39;rhg&#39;, &#39;repeater&#39;, &#39;parity_encoding&#39;, &#39;ptqc&#39;]`.

            - `shape=&#39;random&#39;` : Random graph for fixed numbers of vertices
            and edges, sampled by the ErdÃ¶s-Renyi model.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
                - `prms[1]` &lt;`int`&gt; : Number of edges.
                - [Optional] `prms[2]` &lt;`None` or `int`&gt; : Random seed. If
                `None`, the current system time is used as the seed. If not
                given, the random number generator is not initialized.
            - `shape=&#39;complete&#39;`, `&#39;star&#39;`, `&#39;linear&#39;`, or `&#39;cycle&#39;` :
            Complete, star, linear, or cycle graph, respectively.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
            - `shape=&#39;lattice&#39;` : Lattice graph.
                - `prms` &lt;`tuple` of `int`&gt; : Numbers of repeated vertices
                along the axes. The dimension of the lattice is
                automatically set as `len(prms)`.
            - `shape=&#39;tree&#39;` : Tree graph where all branches in each
            generation have an equal number of children.
                - `prms[0]` &lt;`int`&gt; : Degree of the root vertex.
                - `prms[i]` (&lt;`int`&gt;, i &gt;= 1) : Number of the children of each
                `i`th-generation branch.
            - `shape=&#39;rhg&#39;` : Raussendorf-Harrington-Goyal lattice with primal
            boundaries only.
                - `prms[0]`, `prms[1]`, `prms[2]` &lt;`int`&gt; : Size of the lattice
                along the three axes in the unit of a cell.
            - `shape=&#39;repeater&#39;` : Repeater graph with 4m vertices.
                - `prms[0]` &lt;`int`&gt; : Parameter m.
            - `shape=&#39;parity_encoding&#39;` : (n, m) parity-encoded graph.
                - `prms[0]` &lt;[`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html)&gt; : Logical-level graph. Can be
                generated with python-igraph library directly or from the
                function `get_graph_from_edges()` or `get_sample_graph`.
                - `prms[1]`, `prms[2]` &lt;`int`&gt; : Parameters n and m of the
                parity encoding.
            - `shape=&#39;ptqc&#39;` : Microcluster for parity-encoding-based
            topological quantum computing protocol.
                - `prms[0]`, `prms[1]` &lt;`int`&gt; : Parameter n and m of the
                parity encoding.
                - `prms[2]` &lt;`bool`&gt; : Whether the H-configuration is
                HIC (`True`) or HIS (`False`).
                - `prms[3]` &lt;`bool`&gt; : Whether the microcluster is
                central (`True`) or side (`False`) one.

        prms : None or tuple or int (default: None)
            Parameters for a predefined graph.

            See the description for parameter `shape`.

            If only one parameter is required, it can be given as a number, not
            a tuple.

        cliffords : None or list of str (default: None)
            Local Clifford gates applied on the qubits of the graph
            state.

            If it is `None`, no Clifford gates are applied on the qubits.

            If it is a `list` of `str`, its length should be equal to the
            number of vertices in the graph. Its i-th element indicates the
            Clifford gate applied on the i-th qubit. For example,
            if it is `&#39;H&#39;`, it means that a Hadamard gate is applied on the
            qubit. If it is `&#39;H-S-Z&#39;`, it means that Hadamard, phase,
            and Z gates are applied in order.

        unraveled_graph : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven unraveled graph.

            The code does not check the validity of the given unraveled graph.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html),
            it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        fusion_network : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven fusion network.

            The code does not check the validity of the given fusion network.

            If it is [`networkx.Graph`](https://networkx.org/documentation/stable/reference/classes/graph.html),
            it is internally converted to [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).
        &#34;&#34;&#34;

        def convert_type(g, varname):
            if g is None:
                return None
            elif isinstance(g, ig.Graph):
                return g
            elif isinstance(g, nx.Graph):
                return ig.Graph.from_networkx(g)
            else:
                raise TypeError(f&#39;Parameter {varname} should be igraph.Graph &#39;
                                f&#39;or networkx.Graph.&#39;)

        if graph is not None:
            self.graph = convert_type(graph, &#39;graph&#39;)

        elif edges is not None:
            self.graph = ig.Graph(edges=edges)

        elif shape is not None:
            try:
                prms[0]
            except TypeError:
                prms = (prms,)

            self.graph = get_sample_graph(shape, *prms)

        else:
            raise ValueError(
                &#34;At least one of graph, edges, and shape should be given.&#34;)

        self.graph.vs[&#39;name&#39;] = [str(vid) for vid in
                                 range(self.graph.vcount())]

        if cliffords is not None and edges is None:
            self.graph.vs[&#39;clifford&#39;] = cliffords

        self.unraveled_graph = convert_type(unraveled_graph, &#39;unraveled_graph&#39;)

        self.fusion_network = convert_type(fusion_network, &#39;fusion_network&#39;)

        self.data = {}

    def initialize(self):
        &#34;&#34;&#34;
        Initialize the created unraveled graph and fusion network and the
        calculation data.
        &#34;&#34;&#34;
        self.unraveled_graph = None
        self.fusion_network = None
        self.data = {}

    def unravel_graph(self,
                      unravel_bcs_first=&#39;random&#39;,
                      plot=False,
                      verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

        The unraveled graph is saved in `self.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are
            unraveled.
            - `False`: cliques are unraveled first, then BCSs are
            unraveled.&lt;br&gt;
            - `&#39;random&#39;`: the order is randomly chosen.

        plot : bool (default: False)
            Whether to plot the unraveled graph after unraveling.

        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Information on the unraveled BCSs.

            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.

        cliques : list of list of set of str
            Information on the unraveled cliques.

            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        &#34;&#34;&#34;

        if unravel_bcs_first == &#39;random&#39;:
            unravel_bcs_first = np.random.choice([True, False])

        if unravel_bcs_first:
            bcss = self.unravel_bcss(verbose=verbose)
            cliques = self.unravel_cliques(verbose=verbose)
        else:
            cliques = self.unravel_cliques(verbose=verbose)
            bcss = self.unravel_bcss(verbose=verbose)

        if plot or verbose:
            if verbose:
                print(&#39;[Final]&#39;)
            self.plot_graph(unraveled=True)
            plt.show()

        self.data[&#39;unravel&#39;] = True
        self.data[&#39;unravel_bcs_first&#39;] = unravel_bcs_first

        return bcss, cliques

    def unravel_bcss(self, verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Information on the unraveled BCSs.

            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.
        &#34;&#34;&#34;

        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_bcss = []

        new_vertex_name = graph.vcount()

        while True:
            # Repeat until there are no bipartitely-complete subgraphs
            bcs_exist = False
            while True:
                bcss = find_nonoverlapping_bcss(graph, get_name=True)
                if bcss:
                    bcs_exist = True
                else:
                    break

                unraveled_bcss.append(bcss)
                eids_to_remove = []
                for part1, part2 in bcss:
                    if verbose:
                        graph.delete_edges(eids_to_remove)
                        eids_to_remove.clear()
                        print(&#39;bcs to unravel =&#39;, part1, &#39;&amp;&#39;, part2)
                        vertex_color = []
                        for v in graph.vs:
                            if v[&#39;name&#39;] in part1:
                                vertex_color.append(&#39;orange&#39;)
                            elif v[&#39;name&#39;] in part2:
                                vertex_color.append(&#39;blue&#39;)
                            else:
                                vertex_color.append(&#39;white&#39;)
                        self.plot_graph(unraveled=True,
                                        vertex_color=vertex_color)
                        plt.show()

                    eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                           vname1, vname2 in
                                           itertools.product(part1, part2)])

                    vname1 = str(new_vertex_name)
                    vname2 = str(new_vertex_name + 1)
                    new_v1 = graph.add_vertex(name=vname1,
                                              ext_fusion=vname2,
                                              clifford=None)
                    new_v2 = graph.add_vertex(name=vname2,
                                              ext_fusion=vname1,
                                              clifford=None)
                    new_vertex_name += 2

                    graph.add_edges(itertools.product([new_v1], part1))
                    graph.add_edges(itertools.product([new_v2], part2))

                graph.delete_edges(eids_to_remove)

            if not bcs_exist:
                break

        return unraveled_bcss

    def unravel_cliques(self, verbose=False):
        &#34;&#34;&#34;
        Unravel cliques of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        cliques : list of list of set of str
            Information on the unraveled cliques.

            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        &#34;&#34;&#34;
        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_cliques = []

        def apply_clifford(v, clifford):
            org_clifford = v[&#39;clifford&#39;]
            if org_clifford is None:
                new_clifford = clifford
            else:
                new_clifford = &#39;-&#39;.join([clifford, org_clifford])
            v[&#39;clifford&#39;] = new_clifford

        while True:
            cliques = find_nonoverlapping_cliques(graph, get_name=True)

            if not cliques:
                break

            unraveled_cliques.append(cliques)

            for clique in cliques:
                if verbose:
                    print(&#39;clique to unravel =&#39;, clique)
                    vertex_color = [&#39;orange&#39; if vname in clique else &#39;white&#39;
                                    for vname in graph.vs[&#39;name&#39;]]
                    self.plot_graph(unraveled=True, vertex_color=vertex_color)
                    plt.show()
                clique = list(clique)
                clique_size = len(clique)

                # Choose a vertex to apply LC
                degrees = graph.degree(clique)
                min_degree = min(degrees)
                if min_degree == clique_size - 1:
                    # There exists a vertex in the clique that doesn&#39;t have
                    # outer edges
                    vname_LC = [vname for vname, deg in zip(clique, degrees) if
                                deg == min_degree]
                    need_to_separate = False
                else:
                    vname_LC = clique
                    need_to_separate = True

                if len(vname_LC) &gt; 1:
                    vname_LC = np.random.choice(vname_LC)
                else:
                    vname_LC = vname_LC[0]
                v_LC = graph.vs.find(name=vname_LC)

                # Separate the edges (E) incident to v_LC outside the clique
                # from v_LC
                eids_to_delete = []
                if need_to_separate:
                    # Vertex connected with E
                    new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=v_LC[&#39;clifford&#39;],
                                              ext_fusion=v_LC[&#39;ext_fusion&#39;])

                    # Vertex having an external fusion with v_LC
                    new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=None,
                                              ext_fusion=v_LC[&#39;name&#39;])

                    graph.add_edge(new_v1, new_v2)

                    ngh_vids = graph.neighbors(vname_LC)
                    for ngh_vid in ngh_vids:
                        if graph.vs[ngh_vid][&#39;name&#39;] not in clique:
                            graph.add_edge(ngh_vid, new_v1)
                            eids_to_delete.append(graph.get_eid(vname_LC,
                                                                ngh_vid))

                    vname_org_ext_fusion = v_LC[&#39;ext_fusion&#39;]
                    if vname_org_ext_fusion is not None:
                        v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                        v_org_ext_fusion[&#39;ext_fusion&#39;] = new_v1[&#39;name&#39;]

                    v_LC[&#39;ext_fusion&#39;] = new_v2[&#39;name&#39;]

                    v_LC[&#39;name&#39;], new_v1[&#39;name&#39;] = new_v1[&#39;name&#39;], vname_LC

                # Apply LC
                adj_vnames = set(clique) - {vname_LC}
                apply_clifford(v_LC, &#39;RX&#39;)
                for adj_vname in adj_vnames:
                    adj_v = graph.vs.find(name=adj_vname)
                    apply_clifford(adj_v, &#39;RZ&#39;)

                new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                      vname1, vname2 in
                                      itertools.combinations(adj_vnames, r=2)]
                eids_to_delete.extend(new_eids_to_delete)
                graph.delete_edges(eids_to_delete)

        return unraveled_cliques

    def build_fusion_network(self,
                             use_unraveled_graph=True,
                             plot=False,
                             verbose=False):
        &#34;&#34;&#34;
        Build a fusion network from the original graph or unraveled graph.

        If you want to build it from the unraveled graph, at least one of
        `GraphState.unravel_graph()`, `GraphState.unravel_bcss()`, and
        `GraphState.unravel_cliques()` must be executed beforehand.

        The constructed fusion network is saved in `GraphState.fusion_network`
        as [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

        Parameters
        ----------
        use_unraveled_graph : bool (default: True)
            Whether to use the unraveled graph or the original graph for
            building a fusion network.

        plot : bool (default: False)
            Whether to plot the fusion network after building it.

        verbose : bool (default: False)
            Whether to print logs.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if use_unraveled_graph else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled qubit graph created.&#34;)

        # Fusion network
        network = ig.Graph()
        self.fusion_network = network
        node_groups = {}

        # Links inside star graphs
        for v in graph.vs:
            num_internal_nodes = v.degree() - 1
            vname = v[&#39;name&#39;]
            if num_internal_nodes &gt;= 1:

                # Add nodes
                nid_init = network.vcount()
                seed = np.random.randint(0, num_internal_nodes)
                node_names = [vname if i == 0 else f&#39;{vname}-{i}&#39; for
                              i in itertools.chain(range(seed, -1, -1),
                                                   range(seed + 1,
                                                         num_internal_nodes))]
                attr = {
                    &#39;name&#39;: node_names,
                    &#39;seed&#39;: [True if i == seed else False for i in
                             range(num_internal_nodes)],
                    &#39;node_group&#39;: vname,
                    # &#39;clifford_root&#39;: None,
                    # &#39;clifford_leaves&#39;: None
                }
                network.add_vertices(num_internal_nodes, attributes=attr)
                node_groups[vname] \
                    = network.vs[nid_init:nid_init + num_internal_nodes]

                if num_internal_nodes &gt;= 2:
                    # Connect internal links
                    links = [(nid, nid + 1) for nid
                             in range(nid_init,
                                      nid_init + num_internal_nodes - 1)]
                    attr = {
                        &#39;kind&#39;: &#34;RL&#34;,
                        &#39;root_node&#39;: [
                            node_names[i] if i &lt; seed else node_names[i + 1]
                            for i in range(num_internal_nodes - 1)],
                        &#39;cliffords&#39;: {}
                    }
                    network.add_edges(links, attributes=attr)

        # Links between star graphs
        for e in graph.es:
            vs = [e.source_vertex, e.target_vertex]
            deg_vs = graph.degree(vs)

            if deg_vs[0] &gt; 1 and deg_vs[1] &gt; 1:
                nodes_to_connect = []
                for v in vs:
                    vname = v[&#39;name&#39;]
                    nodes = node_groups[vname].select(
                        lambda node: node.degree() &lt; (2 if node[&#39;seed&#39;] else 3)
                    )
                    nodes_to_connect.append(np.random.choice(nodes))
                network.add_edge(*nodes_to_connect,
                                 kind=&#39;LL&#39;,
                                 root_node=None,
                                 cliffords={})

        if verbose:
            print(&#34;Fusion network of the unraveled graph:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Set of seed node names where root vertices are connected by
        # external fusions.
        nnames_root_connected = set()
        is_node_not_full = lambda node: node.degree() &lt; (
            2 if node[&#39;seed&#39;] and (
                    node[&#39;name&#39;] not in nnames_root_connected) else 3)

        def get_nodes_containing_vertex(vname):
            try:
                node = node_groups[vname].find(name=vname)
                is_root = True
                seed_node_name = vname
            except KeyError:
                ngh = graph.vs[graph.neighbors(vname)[0]]
                seed_node_name = ngh[&#39;name&#39;]
                nodes = node_groups[seed_node_name].select(is_node_not_full)
                node = np.random.choice(nodes)
                is_root = False

            return node, is_root, seed_node_name

        vs_attrs = graph.vs.attributes()

        # Links by external fusions
        if &#39;ext_fusion&#39; in vs_attrs:
            vnames_to_skip = set()
            for v1 in graph.vs.select(ext_fusion_ne=None):
                vname1 = v1[&#39;name&#39;]
                if vname1 in vnames_to_skip:
                    continue
                vname2 = v1[&#39;ext_fusion&#39;]
                v2 = graph.vs.find(name=vname2)
                vnames_to_skip.add(vname2)

                node1, is_root1, _ = get_nodes_containing_vertex(vname1)
                node2, is_root2, _ = get_nodes_containing_vertex(vname2)
                if is_root1 and is_root2:
                    kind = &#39;RR&#39;
                    root_node = None
                    nnames_root_connected.add(node1[&#39;name&#39;])
                    nnames_root_connected.add(node2[&#39;name&#39;])
                elif not is_root1 and not is_root2:
                    kind = &#39;LL&#39;
                    root_node = None
                else:
                    kind = &#39;RL&#39;
                    root_node = node1[&#39;name&#39;] if is_root1 else node2[&#39;name&#39;]
                    nnames_root_connected.add(root_node)

                cliffords = {}
                cl1 = v1[&#39;clifford&#39;]
                cl2 = v2[&#39;clifford&#39;]

                for node, cl in zip([node1, node2], [cl1, cl2]):
                    if cl is not None:
                        cliffords[node[&#39;name&#39;]] = cl

                network.add_edge(node1,
                                 node2,
                                 kind=kind,
                                 root_node=root_node,
                                 cliffords=cliffords)

        network.es[&#39;name&#39;] = [str(eid) for eid in range(network.ecount())]

        if verbose:
            print(&#34;Add external fusions:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Clifford gates on surviving qubits
        # if &#39;clifford&#39; in vs_attrs:
        #     cls_in_node_group_leaves = {}
        #     for v_cl in graph.vs.select(clifford_ne=None, ext_fusion=None):
        #         vname = v_cl[&#39;name&#39;]
        #         _, is_root, seed_node_name = get_nodes_containing_vertex(vname)
        #         seed_node = network.vs.find(name=seed_node_name)
        #         cl = v_cl[&#39;clifford&#39;]
        #
        #         if is_root:
        #             if seed_node_name not in nnames_root_connected:
        #                 seed_node[&#39;clifford_root&#39;] = cl
        #
        #         else:
        #             try:
        #                 cls_in_node_group_leaves[seed_node_name].append(cl)
        #             except KeyError:
        #                 cls_in_node_group_leaves[seed_node_name] = [cl]
        #
        #     for seed_node_name, cls in cls_in_node_group_leaves.items():
        #         node_group = node_groups[seed_node_name]
        #         nums_surviving_leaves = []
        #         for node in node_group:
        #             if node[&#39;name&#39;] in nnames_root_connected:
        #                 num_surviving_leaves = 3 - node.degree()
        #             else:
        #                 num_surviving_leaves = 2 - node.degree()
        #             nums_surviving_leaves.append(num_surviving_leaves)
        #         total_num_surviving_leaves = sum(nums_surviving_leaves)
        #
        #         if len(cls) &lt; total_num_surviving_leaves:
        #             cls.extend([None]
        #                        * (total_num_surviving_leaves - len(cls)))
        #         np.random.shuffle(cls)
        #
        #         i_start = 0
        #         for node, num_leaves in zip(node_group, nums_surviving_leaves):
        #             cls_current_node = cls[i_start:i_start + num_leaves]
        #             cls_current_node = [cl for cl in cls_current_node
        #                                 if cl is not None]
        #             node[&#39;clifford_leaves&#39;] = cls_current_node
        #             i_start += num_leaves

        # if verbose:
        #     print(&#34;Apply Clifford gates:&#34;)
        #     self.plot_fusion_network()
        #     plt.show()

        self.fusion_network = network

        if plot:
            print(&#34;Final:&#34;)
            self.plot_fusion_network()
            plt.show()

    def _contract_edge(self,
                       fusion_network,
                       ename_to_merge):
        ename_to_merge = str(ename_to_merge)

        e_to_merge = fusion_network.es.find(name=ename_to_merge)
        v_merged, v_removed \
            = e_to_merge.source_vertex, e_to_merge.target_vertex
        enames_updated_weight = []

        if v_merged.degree() &lt; v_removed.degree():
            v_merged, v_removed = v_removed, v_merged

        vname_merged = v_merged[&#39;name&#39;]
        vname_removed = v_removed[&#39;name&#39;]

        v_merged[&#39;weight&#39;] = e_to_merge[&#39;weight&#39;]
        v_merged[&#39;weight_f&#39;] = e_to_merge[&#39;weight_f&#39;]
        v_merged[&#39;order&#39;] = max(v_merged[&#39;order&#39;], v_removed[&#39;order&#39;]) + 1

        assert vname_merged != vname_removed

        eids_to_delete = list(set(fusion_network.incident(v_removed)))
        v_removed[&#39;on&#39;] = False

        for eid_connected in eids_to_delete:
            e_connected = fusion_network.es[eid_connected]
            ename_connected = e_connected[&#39;name&#39;]
            if ename_connected != ename_to_merge:
                enames_updated_weight.append(ename_connected)
                vs_ngh = e_connected.source_vertex, e_connected.target_vertex
                new_edge = [v_merged if v_ngh[&#39;name&#39;] == vname_removed
                            else v_ngh for v_ngh in vs_ngh]
                if new_edge[0] == new_edge[1]:  # If a loop is formed
                    v_vrt = fusion_network.add_vertex(
                        name=f&#39;vrt_{fusion_network.vcount()}&#39;,
                        weight=0,
                        weight_f=0,
                        order=0
                    )
                    new_edge = [v_merged, v_vrt]

                fusion_network.add_edge(*new_edge,
                                        name=ename_connected,
                                        weight=None,
                                        weight_f=None)

        fusion_network.delete_edges(eids_to_delete)

        p_succ = fusion_network[&#39;p_succ&#39;]
        for eid_connected in list(set(fusion_network.incident(v_merged))):
            e_connected = fusion_network.es[eid_connected]
            v_ngh1, v_ngh2 = e_connected.source_vertex, e_connected.target_vertex

            assert v_ngh1 != v_ngh2
            e_connected[&#39;weight&#39;] \
                = (v_ngh1[&#39;weight&#39;] + v_ngh2[&#39;weight&#39;]) / p_succ
            e_connected[&#39;weight_f&#39;] \
                = (v_ngh1[&#39;weight_f&#39;] + v_ngh2[&#39;weight_f&#39;] + 1) / p_succ

        self.fusion_network.es.find(name=ename_to_merge)[&#39;order&#39;] \
            = v_merged[&#39;order&#39;]

        return enames_updated_weight

    def calculate_overhead(self,
                           p_succ=0.5,
                           strategy=&#39;weight_and_matching&#39;,
                           optimize_num_fusions=False,
                           fusion_order=None):
        &#34;&#34;&#34;
        Calculate the resource overhead from the fusion network.

        `GraphState.build_fusion_network()` must be executed beforehand.

        The resulting data is saved in `GraphState.data`.

        Parameters
        ----------
        p_succ : float (default: 0.5)
            Success probability of a fusion.

        strategy: str, one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: &#39;weight_and_matching&#39;)
            Strategy for determining the edge to contract.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        optimize_num_fusions : bool
            If `True`, the average number of required fusion attempts are used
            to quantify resource overheads instead of the average number of
            required basic resource states.

        fusion_order : None or list of {int or str} (default: None)
            Fusion order given explicitly as vertex names.

            If it is not `None`, parameter `strategy` is ignored.

        Returns
        -------
        data : dict
            Outcomes of the calculation, which is a shallow copy of
            `GraphState.data`.&lt;br&gt;
            The calculated overhead and number of steps can be obtained from
            `data[&#39;overhead&#39;]` and `data[&#39;num_steps&#39;]`, respectively.
        &#34;&#34;&#34;

        if self.fusion_network is None:
            raise ValueError(&#34;No fusion network created&#34;)

        # Trivial cases
        node_num = self.fusion_network.vcount()
        if node_num == 0:
            self.data[&#39;overhead&#39;] = 0
            self.data[&#39;num_fusions&#39;] = 0
            self.data[&#39;num_steps&#39;] = 0
            return self.data
        elif node_num == 1:
            self.data[&#39;overhead&#39;] = 1
            self.data[&#39;num_fusions&#39;] = 0
            self.data[&#39;num_steps&#39;] = 0
            return self.data

        if fusion_order is None:
            fusion_order = []
            is_fusion_order_given = False
        else:
            is_fusion_order_given = True

        self.fusion_network.es[&#39;order&#39;] = None

        # Initialize intermediate fusion network
        network = self.fusion_network.copy()
        network[&#39;p_succ&#39;] = p_succ
        network.vs[&#39;weight&#39;] = 1
        network.vs[&#39;weight_f&#39;] = 0
        network.vs[&#39;order&#39;] = 0
        network.vs[&#39;on&#39;] = True
        network.es[&#39;weight&#39;] = 2 / p_succ
        network.es[&#39;weight_f&#39;] = 1 / p_succ
        del network.es[&#39;order&#39;]

        turn = 0

        weight_key = &#39;weight_f&#39; if optimize_num_fusions else &#39;weight&#39;

        # Iterate until no edges remain in the fusion network
        while True:
            if not network.ecount():
                break

            if is_fusion_order_given:
                enames_curr_step = [str(fusion_order[turn])]
                is_parellel = True

            elif strategy == &#39;weight&#39;:
                min_weight = min(network.es[weight_key])
                eids_min_weight = network.es.select(weight=min_weight)
                enames_curr_step = eids_min_weight[&#39;name&#39;]
                is_parellel = len(enames_curr_step) == 1

            # elif strategy == &#39;betweenness&#39;:
            #     eb = np.array(network.edge_betweenness())
            #     min_eb = np.min(eb)
            #     eids_curr_step = np.nonzero(eb == min_eb)[0]
            #     enames_curr_step = [network.es[eid][&#39;name&#39;] for eid in
            #     eids_curr_step]
            #     is_parellel = len(enames_curr_step) == 1
            #
            # elif strategy == &#39;weight_and_betweenness&#39;:
            #     min_weight = min(network.es[&#39;weight&#39;])
            #     eids_min_weight = network.es.select(weight=min_weight)
            #     es_min_ovh = eids_min_weight
            #
            #     eb = network.edge_betweenness()
            #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
            #     min_eb = np.min(ebs_min_ovh)
            #     enames_curr_step = [es_min_ovh[i][&#39;name&#39;] for i in
            #     np.nonzero(ebs_min_ovh == min_eb)[0]]
            #     is_parellel = len(enames_curr_step) == 1

            elif &#39;matching&#39; in strategy:
                if strategy == &#39;weight_and_matching&#39;:
                    min_weight = min(network.es[weight_key])
                    if optimize_num_fusions:
                        es_min_weight = network.es.select(weight_f=min_weight)
                    else:
                        es_min_weight = network.es.select(weight=min_weight)
                    subnetwork = network.subgraph_edges(es_min_weight)
                else:
                    subnetwork = network

                subnetwork_nx = subnetwork.to_networkx()
                if isinstance(subnetwork_nx, nx.MultiGraph):
                    subnetwork_nx = nx.Graph(subnetwork_nx)
                matching = nx.max_weight_matching(subnetwork_nx, weight=None)
                enames_curr_step = \
                    subnetwork.es[subnetwork.get_eids(matching)][&#39;name&#39;]

                is_parellel = True

            elif strategy == &#39;random&#39;:
                enames_curr_step = [np.random.choice(network.es[&#39;name&#39;])]
                is_parellel = True

            else:
                raise ValueError

            recalculated_enames = []

            # if get_fusion_order and not is_fusion_order_given:
            #     fusion_order_curr_step = set()
            #     fusion_order.append(fusion_order_curr_step)

            while True:
                if not is_parellel:
                    for rec_ename in recalculated_enames:
                        try:
                            enames_curr_step.remove(rec_ename)
                        except ValueError:
                            pass

                if not enames_curr_step:
                    break

                recalculated_enames.clear()

                if is_parellel:
                    ename_to_merge = enames_curr_step.pop()
                else:
                    ename_to_merge = np.random.choice(enames_curr_step)
                    enames_curr_step.remove(ename_to_merge)

                # if get_fusion_order:
                #     e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                #     v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                #     fusion_order_curr_step.add((v1[&#39;name&#39;], v2[&#39;name&#39;],
                #                                 ename_to_merge))

                enames_updated_weight \
                    = self._contract_edge(network,
                                          ename_to_merge)

                recalculated_enames.extend(enames_updated_weight)

        v_final = network.vs.select(on=True)
        overhead = sum(v_final[&#39;weight&#39;])
        num_fusions = sum(v_final[&#39;weight_f&#39;])
        num_steps = max(v_final[&#39;order&#39;])

        results = {
            &#39;overhead&#39;: overhead,
            &#39;num_fusions&#39;: num_fusions,
            &#39;num_steps&#39;: num_steps,
            &#39;fusion_order_strategy&#39;: strategy,
            &#39;p_succ&#39;: p_succ,
        }

        if optimize_num_fusions:
            results[&#39;optimize_num_fusions&#39;] = True

        # if get_fusion_order:
        #     results[&#39;fusion_order&#39;] = fusion_order

        self.data.update(results)

        return self.data.copy()

    def simulate(self,
                 n_iter,
                 p_succ=0.5,
                 mp=False,
                 n_procs=None,
                 get_all_data=False,
                 get_all_graphs=False,
                 get_all_fusion_networks=False,
                 unravel=True,
                 unravel_bcs_first=&#39;random&#39;,
                 fusion_order_strategy=&#39;weight_and_matching&#39;,
                 optimize_num_fusions=False,
                 seed=&#39;keep&#39;,
                 verbose=True,
                 pbar=False,
                 **kwargs):
        &#34;&#34;&#34;
        Execute the strategy for a fixed number of iterations and obtain the
        best one only (by default).

        Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
        `GraphState.fusion_network` are updated according to the result of the
        best sample.

        Parameters
        ----------
        n_iter : int
            Iteration number.

        p_succ : float (default: 0.5)
            Success probability of a fusion.

        mp : bool (default: False)
            Whether to use multiprocessing for the iterations.

            Package *parmap* should be installed to use it.

        n_procs : None or int (default: None)
            Maximal number of simultaneous processes for multiprocessing.

            If it is `None`, the number of CPUs is used.

            Ignored when `mp` is `False`.

        get_all_data : bool (default: False)
            Whether to obtain the data (overheads, numbers of steps, etc.) from
            all samples or only the best sample.

        get_all_graphs : bool (default: False)
            Whether to obtain the unraveled graphs from all samples or only the
            best sample.

        get_all_fusion_networks : bool (default: False)
            Whether to obtain the fusion networks from all samples or only the
            best sample.

        unravel : bool (default: True)
            Whether to unravel the graph or not.

        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are unraveled.
            - `False`, cliques are unraveled first, then BCSs are unraveled.
            - `&#39;random&#39;`, the order is randomly chosen.

        fusion_order_strategy : one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: `weight_and_matching&#39;)
            Strategy for determining the edge to contract in each step.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        optimize_num_fusions : bool
            If `True`, use the averagte number of fusion attempts to quantify
            resource overheads instead of the average number of basic resource
            states.

        seed : &#39;keep&#39; or None or int (default: &#39;keep&#39;)
            Random seed.

            - `&#39;keep&#39;`: The seed is not initialized.
            - `None`: The current time is used as the random seed.
            - `int`: The given number is used as the random seed.

            If `n_iter&gt;1`, the given seed is used to sample random seeds for
            individual iterations. However, if `n_iter==1`, the given seed is
            used as the random seed for the (only one) iteration itself.

        verbose : bool (default: True)
            Whether to print logs.

        pbar : bool (default: False)
            Whether to show a progress bar.

            Ignored if `mp` is `False`

        kwargs : dict
            Additional keyword arguments for calculating overheads.

            See the description of `GraphState.calculate_overhead()`.

        Returns
        -------
        res : dict
            Result of the iterations.

            By default, only the information of the best sample is returned.
        &#34;&#34;&#34;

        t0 = time.time()

        overhead_key = &#39;num_fusions&#39; if optimize_num_fusions else &#39;overhead&#39;

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        if mp:
            if n_procs is None:
                n_procs = os.cpu_count()
            mp = mp and n_iter &gt;= n_procs

        if not mp:
            if verbose:
                print(&#34;Multiprocessing OFF.&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}...&#34;)

            if n_iter == 1 and seed is not None and seed != &#39;keep&#39;:
                seeds_samples = [seed]
            else:
                seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

            overheads = [] if get_all_data else None
            nums_fusions = [] if get_all_data else None
            nums_steps = [] if get_all_data else None
            seeds = [] if get_all_data else None
            unravalled_graphs = [] if get_all_graphs else None
            fusion_networks = [] if get_all_fusion_networks else None

            best_sample = None
            lowest_overhead = None
            for i_sample in range(n_iter):
                seed_sample = seeds_samples[i_sample]
                np.random.seed(seed_sample)

                if unravel:
                    self.unraveled_graph = None
                    try:
                        self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                    except:
                        print(&#39;Error occurs during unraveling&#39;)
                        print(&#39;seed =&#39;, seed_sample)
                        raise ValueError

                try:
                    self.build_fusion_network(use_unraveled_graph=unravel)
                except:
                    print(&#39;Error occurs during building fusion network&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                try:
                    data_now = self.calculate_overhead(
                        p_succ=p_succ,
                        strategy=fusion_order_strategy,
                        optimize_num_fusions=optimize_num_fusions,
                        **kwargs)
                except:
                    print(&#39;Error occurs during calculating overhead&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                overhead_now = data_now[overhead_key]
                num_steps_now = data_now[&#39;num_steps&#39;]
                self.data[&#39;seed&#39;] = seed_sample

                if lowest_overhead is None or overhead_now &lt; lowest_overhead:
                    best_sample = i_sample
                    lowest_overhead = overhead_now
                    best_ogs = self.copy()

                if get_all_data:
                    overheads.append(data_now[&#39;overhead&#39;])
                    nums_fusions.append(data_now[&#39;num_fusions&#39;])
                    nums_steps.append(num_steps_now)
                    seeds.append(seed_sample)

                if get_all_graphs:
                    unravalled_graphs.append(self.unraveled_graph)

                if get_all_fusion_networks:
                    fusion_networks.append(self.fusion_network)

            res = {
                &#39;best_overhead&#39;: best_ogs.data[&#39;overhead&#39;],
                &#39;best_num_fusions&#39;: best_ogs.data[&#39;num_fusions&#39;],
                &#39;best_num_steps&#39;: best_ogs.data[&#39;num_steps&#39;],
                &#39;best_seed&#39;: best_ogs.data[&#39;seed&#39;],
                &#39;n_iter&#39;: n_iter}

            if unravel:
                res[&#39;unravel_bcs_first&#39;] = best_ogs.data[&#39;unravel_bcs_first&#39;]

            if get_all_data or get_all_graphs or get_all_fusion_networks:
                res[&#39;best_sample&#39;] = best_sample

                if get_all_data:
                    res[&#39;overheads&#39;] = overheads
                    res[&#39;nums_fusions&#39;] = nums_fusions
                    res[&#39;nums_steps&#39;] = nums_steps
                    res[&#39;seeds&#39;] = seeds

                if get_all_graphs:
                    res[&#39;unraveled_graphs&#39;] = unravalled_graphs

                if get_all_fusion_networks:
                    res[&#39;fusion_networks&#39;] = fusion_networks

        else:
            if &#39;parmap&#39; not in sys.modules:
                raise ModuleNotFoundError(&#34;Package parmap is not installed.&#34;)

            if verbose:
                print(f&#34;Multiprocessing ON: n_procs = {n_procs}&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}... &#34;, end=&#39;&#39;)

            additional_keys = []
            if get_all_data:
                additional_keys.extend([&#39;overheads&#39;, &#39;nums_fusions&#39;,
                                        &#39;nums_steps&#39;, &#39;seeds&#39;])
            if get_all_graphs:
                additional_keys.append(&#39;unraveled_graphs&#39;)
            if get_all_fusion_networks:
                additional_keys.append(&#39;fusion_networks&#39;)

            left = n_iter % n_procs
            ns_samples = [n_iter // n_procs] * n_procs
            for i in range(left):
                ns_samples[i] += 1

            seeds = np.random.randint(0, _max_seed(), size=n_procs)

            res_procs = parmap.starmap(
                _simulate_single,
                list(zip(ns_samples, seeds)),
                self.graph,
                p_succ=p_succ,
                get_all_data=get_all_data,
                get_all_graphs=get_all_graphs,
                get_all_fusion_networks=get_all_fusion_networks,
                unravel=unravel,
                unravel_bcs_first=unravel_bcs_first,
                fusion_order_strategy=fusion_order_strategy,
                optimize_num_fusions=optimize_num_fusions,
                pm_pbar=pbar,
                **kwargs)
            best_proc = np.argmin(
                [res_each[f&#39;best_{overhead_key}&#39;] for res_each in res_procs]
            )
            res = res_procs[best_proc]
            res[&#39;n_iter&#39;] = n_iter
            best_ogs = res[&#39;best_ogs&#39;]
            del res[&#39;best_ogs&#39;]

            if additional_keys:
                res[&#39;best_sample&#39;] += sum(ns_samples[:best_proc])

            for key in additional_keys:
                vals = [res_each[key] for res_each in res_procs]
                res[key] = list(itertools.chain(*vals))

        if verbose:
            print(f&#34;Done. Best: {res[f&#39;best_{overhead_key}&#39;]:.2f} &#34;
                  f&#34;({time.time() - t0:.2f} s)&#34;)

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.data = best_ogs.data

        return res

    def simulate_adaptive(self,
                          init_n_iter,
                          mul=2,
                          p_succ=0.5,
                          mp=False,
                          n_procs=None,
                          get_all_data=False,
                          get_all_graphs=False,
                          get_all_fusion_networks=False,
                          unravel=True,
                          unravel_bcs_first=&#39;random&#39;,
                          fusion_order_strategy=&#39;weight_and_matching&#39;,
                          optimize_num_fusions=False,
                          seed=&#39;keep&#39;,
                          verbose=True,
                          pbar=False,
                          **kwargs):
        &#34;&#34;&#34;
        Run the adaptive iteration method for the strategy and obtain the
        best one only (by default).

        The adaptive iteration method looks for the best iteration while
        keeps increasing the iteration number until a certain condition
        meets. In detail, denoting N iterations of the strategy as R(N),
        R(`init_n_iter`) is first executed and `q0` is obtained which is the
        lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
        and `q1` is obtained similarly. If `q0 &lt;= q1`, `q0` is returned. If
        otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
        If `q1 &lt;= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
        is executed, and so on.

        Parameters
        ----------
        init_n_iter : int
            Initial iteration number.

        mul : int (default: 2)
            Multiplicative factor of the iteration number.

        See the description of `GraphState.simulate()` for the other parameters.

        Returns
        -------
        res : dict
            Result of the iterations.

            By default, only the information of the best sample is given.
        &#34;&#34;&#34;

        if mp and n_procs is None:
            n_procs = os.cpu_count()

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        additional_keys = []
        if get_all_data:
            additional_keys.extend([&#39;overheads&#39;, &#39;nums_fusions&#39;, &#39;nums_steps&#39;])
        if get_all_graphs:
            additional_keys.append(&#39;unraveled_graphs&#39;)
        if get_all_fusion_networks:
            additional_keys.append(&#39;fusion_networks&#39;)

        if verbose:
            if mp:
                print(f&#34;Multiprocessing (n_procs = {n_procs})&#34;)
            else:
                print(&#34;No multiprocessing&#34;)

        best_overhead_key \
            = &#39;best_num_fusions&#39; if optimize_num_fusions else &#39;best_overhead&#39;

        n_iter_history = []
        n_iter_now = init_n_iter
        res = None

        while True:
            if verbose:
                print(f&#34;Calculating for n_iter = {n_iter_now}... &#34;, end=&#39;&#39;)
            t0 = time.time()

            n_iter_history.append(n_iter_now)
            res_now = self.simulate(
                n_iter=n_iter_now,
                p_succ=p_succ,
                mp=mp,
                n_procs=n_procs,
                get_all_data=get_all_data,
                get_all_graphs=get_all_graphs,
                get_all_fusion_networks=get_all_fusion_networks,
                unravel=unravel,
                unravel_bcs_first=unravel_bcs_first,
                fusion_order_strategy=fusion_order_strategy,
                optimize_num_fusions=optimize_num_fusions,
                verbose=False,
                pbar=pbar,
                **kwargs
            )

            if res is None:
                res = res_now
                best_ogs = self.copy()
                n_iter_now *= mul

            else:
                for key in additional_keys:
                    res[key].extend(res_now[key])

                if res_now[best_overhead_key] &lt; res[best_overhead_key]:
                    for key in additional_keys:
                        res_now[key] = res[key]
                    res = res_now
                    best_ogs = self.copy()

                    n_iter_now *= mul

                else:
                    if verbose:
                        print(f&#34;Done. Best: {res[best_overhead_key]:.2f} (&#34;
                              f&#34;{time.time() - t0:.2f} s)&#34;)
                    break

            if verbose:
                print(f&#34;Done. Best: {res[best_overhead_key]:.2f} &#34;
                      f&#34;({time.time() - t0:.2f} s)&#34;)

        res[&#39;n_iter&#39;] = sum(n_iter_history)

        if additional_keys:
            res[&#39;best_sample&#39;] += res[&#39;best_sample&#39;]

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.data = best_ogs.data

        return res

    def get_instructions(self):
        &#34;&#34;&#34;
        Get the instruction to generate the desired graph state from multiple
        three-qubit linear graph states.

        One of `GraphState.calculate_overhead()`, `GraphState.simulate()`, and
        `GraphState.simulate_adaptive()` must be executed beforehand.

        Returns
        -------
        node_names : list of str
            List of the names of nodes in the fusion network.

        fusions : dict
            Dictionary that contains the information about required fusions and
            Clifford gates.

            Each required fusion is represented by a 2-tuple of 3-tuples:
            `((n1, q1, cl1), (n2, q2, cl2))`. `n1` and `n2` are the names of
            the nodes involved in the fusion, `q1` and `q2` are `&#39;R&#39;` or `&#39;L&#39;`
            that indicate the qubits undergoing the fusion (`&#39;R&#39;` for a root
            qubit and `&#39;L&#39;` for a leaf qubit), and `cl1` and `cl2` are the
            Clifford gates applied to the qubits before the fusion is
            performed.

            `fusions[i]` for a positive integer `i` is a list of such 2-tuples,
            which indicate fusions that can be done in parallel in the `i`-th
            step.

        qubit_correspondence : dict
            Dictionary that contains the correspondence between the vertices in
            the original graph and the final remaining qubits after performing
            all the fusions.

            For each name (say, `vname`) of a vertex in the original graph,
            `qubit_correspondence[vname]` is a 3-tuple `(node, qubit, cl)`,
            where `node` is the node containing the qubit, `qubit` is either
            `&#39;R&#39;` or `&#39;L&#39;` that indicates whether the qubit is a root or leaf
            qubit, and `cl` is the Clifford gate applied to the qubit.
        &#34;&#34;&#34;
        network = self.fusion_network

        # Fusions
        fusions = {}
        orders = network.es[&#39;order&#39;]
        num_steps = max(orders)
        for order in range(1, num_steps + 1):
            inst_same_order = []
            links = network.es.select(order=order)
            for link in links:
                nname1 = link.source_vertex[&#39;name&#39;]
                nname2 = link.target_vertex[&#39;name&#39;]
                kind = link[&#39;kind&#39;]
                if kind == &#39;RR&#39;:
                    qubit1 = qubit2 = &#39;R&#39;
                elif kind == &#39;LL&#39;:
                    qubit1 = qubit2 = &#39;L&#39;
                else:
                    root_node = link[&#39;root_node&#39;]
                    qubit1 = &#39;R&#39; if root_node == nname1 else &#39;L&#39;
                    qubit2 = &#39;L&#39; if qubit1 == &#39;R&#39; else &#39;R&#39;
                cliffords = link[&#39;cliffords&#39;]
                try:
                    cl1 = cliffords[nname1]
                except KeyError:
                    cl1 = None
                try:
                    cl2 = cliffords[nname2]
                except KeyError:
                    cl2 = None

                inst_same_order.append(((nname1, qubit1, cl1),
                                        (nname2, qubit2, cl2)))

            fusions[order] = inst_same_order

        # Final remaining qubits &amp; Clifford gates on them
        qubit_correspondence = {}
        remaining_leaves = {}
        for vname in self.graph.vs[&#39;name&#39;]:
            v_unrv: ig.Vertex = self.unraveled_graph.vs.find(name=vname)
            cl = v_unrv[&#39;clifford&#39;]

            if v_unrv.degree() &gt; 1:
                corr = (vname, &#39;R&#39;, cl)

            else:
                v_ngh_unrv = v_unrv.neighbors()[0]
                seed_node_name = v_ngh_unrv[&#39;name&#39;]
                try:
                    remaining_leaves_curr \
                        = remaining_leaves[seed_node_name]
                except KeyError:
                    node_group \
                        = network.vs.select(node_group=seed_node_name)
                    remaining_leaves_curr = {}
                    for node in node_group:
                        num_remaining_leaves = 2
                        for link in node.incident():
                            kind = link[&#39;kind&#39;]
                            if kind == &#39;LL&#39; \
                                    or (kind == &#39;RL&#39;
                                        and link[&#39;root_node&#39;] != node[&#39;name&#39;]):
                                num_remaining_leaves -= 1
                        remaining_leaves_curr[node[&#39;name&#39;]] \
                            = num_remaining_leaves
                    remaining_leaves[seed_node_name] = remaining_leaves_curr

                corr = None
                for node_name, num_remaining_leaves in remaining_leaves_curr.items():
                    if num_remaining_leaves:
                        corr = (node_name, &#39;L&#39;, cl)
                        remaining_leaves_curr[node_name] -= 1

                assert corr is not None

            qubit_correspondence[vname] = corr

        node_names = network.vs[&#39;name&#39;]

        return node_names, fusions, qubit_correspondence

    def get_vertex_clifford(self, vertex, unraveled=True):
        &#34;&#34;&#34;
        Get the Clifford gate applied to a vertex in the unraveled graph
        (by default) or the original graph.

        Each Clifford gate is represented by a string. For example, `&#39;RX&#39;`
        and `&#39;RZ&#39;` respectively mean pi/2 X-rotation (Z-rotation). If a qubit
        is subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
        represented by `&#39;RX-RZ&#39;`.

        Parameters
        ----------
        vertex : int or str
            Name of the vertex.

        unraveled : bool (default: True)
            Whether to find the vertex in the unraveled or original graph.

        Returns
        -------
        clifford : None or str
            Clifford gate applied to the vertex.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if unraveled else self.graph
        if &#39;clifford&#39; in graph.vertex_attributes():
            cl = graph.vs.find(name=str(vertex))[&#39;clifford&#39;]
            return cl
        else:
            return None

    def get_link_clifford(self, n1, n2):
        &#34;&#34;&#34;
        Get the Clifford gates that need to be applied to two qubits involved
        in the fusion of a given link.

        Each Clifford gate is represented by a string. For example, `&#39;RX&#39;` and
        `&#39;RZ&#39;` respectively mean pi/2 X-rotation (Z-rotation). If a qubit is
        subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
        represented by `&#39;RX-RZ&#39;`.

        Parameters
        ----------
        n1, n2 : int or str
            Names of the nodes connected by the link.

        Returns
        -------
        cl1, cl2 : None or str
            Clifford gates applied on the two qubits involved in the fusion
            of the link.
        &#34;&#34;&#34;

        network = self.fusion_network
        n1 = str(n1)
        n2 = str(n2)

        link = network.es[network.get_eid(n1, n2)]
        cliffords = link[&#39;cliffords&#39;]
        cls = []
        for n in [n1, n2]:
            try:
                cls.append(cliffords[n])
            except KeyError:
                cls.append(None)

        return tuple(cls)

    def plot_graph(self, unraveled=False, **kwargs):
        &#34;&#34;&#34;
        Plot the original or unraveled graph.

        If the unraveled graph is plotted, edges in the unraveled graph are
        drawn as black solid lines while external fusions are drawn as red
        dashed lines (by default).

        Vertices with Clifford gates are colored in orange (by default).
        These Clifford gates can be obtained by using
        `GraphState.get_vertex_clifford()`.

        Parameters
        ----------
        unraveled : bool (default: False)
            Whether to plot the unraveled graph or the original graph.

        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.

            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (5, 5))
            Size of the figure in inches.

        save : None or str (default: None)
            Path to save the figure.

        show_vertex_names : bool (default: True)
            If `True`, vertex names are shown.

        vertex_color_normal : str (default: &#39;white&#39;)
            Color of vertices without Clifford gates.

        vertex_color_clifford : str (default: &#39;orange&#39;)
            Color of vertices with Clifford gates.

        vertices_to_highlight : None or list of {str or int} (default: None)
            Name of vertices to highlight.

        vertex_color_highlight : str (default: purple)
            Color of the highlighted vertices.

            Ignored if `vertices_to_highlight` is `None`.

        edge_color_normal : str (default: black)
            Color of edges in the graph.

        edge_color_fusion : str (default: red)
            Color of lines for external fusions.

            Ignored if `unraveled` is `False`.

        edge_style_fusion : str (default: &#39;--&#39;)
            Style of lines for external fusions.

        Any other keyword arguments in `igraph.plot()` can be directly used.
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting
        If they are given, they override the above parameters.

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if unraveled else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled graph created.&#34;)

        fig, ax = plot_graph(graph, **kwargs)

        return fig, ax

    def plot_fusion_network(self, **kwargs):
        &#34;&#34;&#34;
        Plot the fusion network.

        Links have different styles and colors depending on their types:

        - &#39;LL&#39;: Black solid line.
        - &#39;RR&#39;: Red dashed line.
        - &#39;RL&#39;: Blue arrow from leaf to root.

        The number placed on each link indicates the order of the fusion. It is
        presented only when the resource overhead has been computed beforehand.

        Links with `&#39;C&#39;` written on them indicate fusions accompanied by
        non-trivial Clifford gates. These Clifford gates can be obtained by
        using `GraphState.get_link_clifford()`.

        Parameters
        ----------
        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.&lt;br&gt;
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (5, 5))
            Size of the figure in inches.

        save : None or str (default: None)
            Path to save the figure.

        show_node_names : bool (default: True)
            If `True`, node names are shown.

        node_color : str (default: &#39;white&#39;)
            Color of nodes.

        show_link_names : bool (default: False)
            If `True`, link names are shown.

        show_fusion_orders : bool (default: True)
            If `True`, fusion orders are shown on links.

            If both `show_link_names` and `show_fusion_orders` are `True`,
            it is shown as `&#39;{link name}-{fusion order}&#39;`

        show_link_cliffords : bool (default: True)
            If `True`, links that correspond to fusions accompanied by
            non-trivial Clifford gates are marked as `&#39;C&#39;`.

            If `show_link_names` or `show_fusion_orders` are `True`, `&#39;C&#39;` is
            appended to the end of the label.

        link_color_ll : str (default: &#39;black&#39;)
            Color of leaf-to-leaf links.

        link_color_rl : str (default: &#39;blue&#39;)
            Color of root-to-leaf links.

        link_color_rr : str (default: &#39;red&#39;)
            Color of root-to-root links.

        arrow_size : float (default: 0.02)
            Size of arrows for root-to-leaf links.

        Any other keyword arguments in igraph.plot can be directly used.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
        If they are given, they override the above parameters.&lt;br&gt;

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        network = self.fusion_network
        if network is None:
            raise ValueError(&#39;No fusion network created.&#39;)

        fig, ax = plot_fusion_network(network, **kwargs)

        return fig, ax

    def copy(self):
        &#34;&#34;&#34;
        Return a **shallow** copy of this object.

        Use `copy.deepcopy()` to get a deep copy.

        Returns
        -------
        copy : GraphState
            Copied instance of itself.
        &#34;&#34;&#34;

        copy = GraphState(graph=self.graph,
                          unraveled_graph=self.unraveled_graph,
                          fusion_network=self.fusion_network)

        copy.data = self.data.copy()

        return copy</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="optgraphstate.GraphState.data"><code class="name">var <span class="ident">data</span> :Â dict</code></dt>
<dd>
<div class="desc"><p>Any data obtained during unraveling the graph, constructing the fusion
network, and calculating the resource overhead.</p></div>
</dd>
<dt id="optgraphstate.GraphState.fusion_network"><code class="name">var <span class="ident">fusion_network</span> :Â igraph.Graph</code></dt>
<dd>
<div class="desc"><p>It is <code>None</code> before the fusion network is created.
See Sec. 7 of our tutorial for the list of its vertex and edge
attributes.</p></div>
</dd>
<dt id="optgraphstate.GraphState.graph"><code class="name">var <span class="ident">graph</span> :Â igraph.Graph</code></dt>
<dd>
<div class="desc"><p>Graph of the graph state to investigate.</p></div>
</dd>
<dt id="optgraphstate.GraphState.unraveled_graph"><code class="name">var <span class="ident">unraveled_graph</span> :Â igraph.Graph</code></dt>
<dd>
<div class="desc"><p>It is <code>None</code> before the unraveled graph is created.
See Sec. 7 of our tutorial for the list of its vertex attributes.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optgraphstate.GraphState.build_fusion_network"><code class="name flex">
<span>def <span class="ident">build_fusion_network</span></span>(<span>self, use_unraveled_graph=True, plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a fusion network from the original graph or unraveled graph.</p>
<p>If you want to build it from the unraveled graph, at least one of
<code><a title="optgraphstate.GraphState.unravel_graph" href="#optgraphstate.GraphState.unravel_graph">GraphState.unravel_graph()</a></code>, <code><a title="optgraphstate.GraphState.unravel_bcss" href="#optgraphstate.GraphState.unravel_bcss">GraphState.unravel_bcss()</a></code>, and
<code><a title="optgraphstate.GraphState.unravel_cliques" href="#optgraphstate.GraphState.unravel_cliques">GraphState.unravel_cliques()</a></code> must be executed beforehand.</p>
<p>The constructed fusion network is saved in <code><a title="optgraphstate.GraphState.fusion_network" href="#optgraphstate.GraphState.fusion_network">GraphState.fusion_network</a></code>
as <a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>use_unraveled_graph</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to use the unraveled graph or the original graph for
building a fusion network.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to plot the fusion network after building it.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_fusion_network(self,
                         use_unraveled_graph=True,
                         plot=False,
                         verbose=False):
    &#34;&#34;&#34;
    Build a fusion network from the original graph or unraveled graph.

    If you want to build it from the unraveled graph, at least one of
    `GraphState.unravel_graph()`, `GraphState.unravel_bcss()`, and
    `GraphState.unravel_cliques()` must be executed beforehand.

    The constructed fusion network is saved in `GraphState.fusion_network`
    as [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

    Parameters
    ----------
    use_unraveled_graph : bool (default: True)
        Whether to use the unraveled graph or the original graph for
        building a fusion network.

    plot : bool (default: False)
        Whether to plot the fusion network after building it.

    verbose : bool (default: False)
        Whether to print logs.
    &#34;&#34;&#34;

    graph = self.unraveled_graph if use_unraveled_graph else self.graph
    if graph is None:
        raise ValueError(&#34;No unraveled qubit graph created.&#34;)

    # Fusion network
    network = ig.Graph()
    self.fusion_network = network
    node_groups = {}

    # Links inside star graphs
    for v in graph.vs:
        num_internal_nodes = v.degree() - 1
        vname = v[&#39;name&#39;]
        if num_internal_nodes &gt;= 1:

            # Add nodes
            nid_init = network.vcount()
            seed = np.random.randint(0, num_internal_nodes)
            node_names = [vname if i == 0 else f&#39;{vname}-{i}&#39; for
                          i in itertools.chain(range(seed, -1, -1),
                                               range(seed + 1,
                                                     num_internal_nodes))]
            attr = {
                &#39;name&#39;: node_names,
                &#39;seed&#39;: [True if i == seed else False for i in
                         range(num_internal_nodes)],
                &#39;node_group&#39;: vname,
                # &#39;clifford_root&#39;: None,
                # &#39;clifford_leaves&#39;: None
            }
            network.add_vertices(num_internal_nodes, attributes=attr)
            node_groups[vname] \
                = network.vs[nid_init:nid_init + num_internal_nodes]

            if num_internal_nodes &gt;= 2:
                # Connect internal links
                links = [(nid, nid + 1) for nid
                         in range(nid_init,
                                  nid_init + num_internal_nodes - 1)]
                attr = {
                    &#39;kind&#39;: &#34;RL&#34;,
                    &#39;root_node&#39;: [
                        node_names[i] if i &lt; seed else node_names[i + 1]
                        for i in range(num_internal_nodes - 1)],
                    &#39;cliffords&#39;: {}
                }
                network.add_edges(links, attributes=attr)

    # Links between star graphs
    for e in graph.es:
        vs = [e.source_vertex, e.target_vertex]
        deg_vs = graph.degree(vs)

        if deg_vs[0] &gt; 1 and deg_vs[1] &gt; 1:
            nodes_to_connect = []
            for v in vs:
                vname = v[&#39;name&#39;]
                nodes = node_groups[vname].select(
                    lambda node: node.degree() &lt; (2 if node[&#39;seed&#39;] else 3)
                )
                nodes_to_connect.append(np.random.choice(nodes))
            network.add_edge(*nodes_to_connect,
                             kind=&#39;LL&#39;,
                             root_node=None,
                             cliffords={})

    if verbose:
        print(&#34;Fusion network of the unraveled graph:&#34;)
        self.plot_fusion_network()
        plt.show()

    # Set of seed node names where root vertices are connected by
    # external fusions.
    nnames_root_connected = set()
    is_node_not_full = lambda node: node.degree() &lt; (
        2 if node[&#39;seed&#39;] and (
                node[&#39;name&#39;] not in nnames_root_connected) else 3)

    def get_nodes_containing_vertex(vname):
        try:
            node = node_groups[vname].find(name=vname)
            is_root = True
            seed_node_name = vname
        except KeyError:
            ngh = graph.vs[graph.neighbors(vname)[0]]
            seed_node_name = ngh[&#39;name&#39;]
            nodes = node_groups[seed_node_name].select(is_node_not_full)
            node = np.random.choice(nodes)
            is_root = False

        return node, is_root, seed_node_name

    vs_attrs = graph.vs.attributes()

    # Links by external fusions
    if &#39;ext_fusion&#39; in vs_attrs:
        vnames_to_skip = set()
        for v1 in graph.vs.select(ext_fusion_ne=None):
            vname1 = v1[&#39;name&#39;]
            if vname1 in vnames_to_skip:
                continue
            vname2 = v1[&#39;ext_fusion&#39;]
            v2 = graph.vs.find(name=vname2)
            vnames_to_skip.add(vname2)

            node1, is_root1, _ = get_nodes_containing_vertex(vname1)
            node2, is_root2, _ = get_nodes_containing_vertex(vname2)
            if is_root1 and is_root2:
                kind = &#39;RR&#39;
                root_node = None
                nnames_root_connected.add(node1[&#39;name&#39;])
                nnames_root_connected.add(node2[&#39;name&#39;])
            elif not is_root1 and not is_root2:
                kind = &#39;LL&#39;
                root_node = None
            else:
                kind = &#39;RL&#39;
                root_node = node1[&#39;name&#39;] if is_root1 else node2[&#39;name&#39;]
                nnames_root_connected.add(root_node)

            cliffords = {}
            cl1 = v1[&#39;clifford&#39;]
            cl2 = v2[&#39;clifford&#39;]

            for node, cl in zip([node1, node2], [cl1, cl2]):
                if cl is not None:
                    cliffords[node[&#39;name&#39;]] = cl

            network.add_edge(node1,
                             node2,
                             kind=kind,
                             root_node=root_node,
                             cliffords=cliffords)

    network.es[&#39;name&#39;] = [str(eid) for eid in range(network.ecount())]

    if verbose:
        print(&#34;Add external fusions:&#34;)
        self.plot_fusion_network()
        plt.show()

    # Clifford gates on surviving qubits
    # if &#39;clifford&#39; in vs_attrs:
    #     cls_in_node_group_leaves = {}
    #     for v_cl in graph.vs.select(clifford_ne=None, ext_fusion=None):
    #         vname = v_cl[&#39;name&#39;]
    #         _, is_root, seed_node_name = get_nodes_containing_vertex(vname)
    #         seed_node = network.vs.find(name=seed_node_name)
    #         cl = v_cl[&#39;clifford&#39;]
    #
    #         if is_root:
    #             if seed_node_name not in nnames_root_connected:
    #                 seed_node[&#39;clifford_root&#39;] = cl
    #
    #         else:
    #             try:
    #                 cls_in_node_group_leaves[seed_node_name].append(cl)
    #             except KeyError:
    #                 cls_in_node_group_leaves[seed_node_name] = [cl]
    #
    #     for seed_node_name, cls in cls_in_node_group_leaves.items():
    #         node_group = node_groups[seed_node_name]
    #         nums_surviving_leaves = []
    #         for node in node_group:
    #             if node[&#39;name&#39;] in nnames_root_connected:
    #                 num_surviving_leaves = 3 - node.degree()
    #             else:
    #                 num_surviving_leaves = 2 - node.degree()
    #             nums_surviving_leaves.append(num_surviving_leaves)
    #         total_num_surviving_leaves = sum(nums_surviving_leaves)
    #
    #         if len(cls) &lt; total_num_surviving_leaves:
    #             cls.extend([None]
    #                        * (total_num_surviving_leaves - len(cls)))
    #         np.random.shuffle(cls)
    #
    #         i_start = 0
    #         for node, num_leaves in zip(node_group, nums_surviving_leaves):
    #             cls_current_node = cls[i_start:i_start + num_leaves]
    #             cls_current_node = [cl for cl in cls_current_node
    #                                 if cl is not None]
    #             node[&#39;clifford_leaves&#39;] = cls_current_node
    #             i_start += num_leaves

    # if verbose:
    #     print(&#34;Apply Clifford gates:&#34;)
    #     self.plot_fusion_network()
    #     plt.show()

    self.fusion_network = network

    if plot:
        print(&#34;Final:&#34;)
        self.plot_fusion_network()
        plt.show()</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.calculate_overhead"><code class="name flex">
<span>def <span class="ident">calculate_overhead</span></span>(<span>self, p_succ=0.5, strategy='weight_and_matching', optimize_num_fusions=False, fusion_order=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the resource overhead from the fusion network.</p>
<p><code><a title="optgraphstate.GraphState.build_fusion_network" href="#optgraphstate.GraphState.build_fusion_network">GraphState.build_fusion_network()</a></code> must be executed beforehand.</p>
<p>The resulting data is saved in <code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">GraphState.data</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_succ</code></strong> :&ensp;<code>float (default: 0.5)</code></dt>
<dd>Success probability of a fusion.</dd>
<dt><strong><code>strategy</code></strong> :&ensp;<code>str, one</code> of <code>['weight', 'matching', 'weight_and_matching', 'random'] (default: 'weight_and_matching')</code></dt>
<dd>
<p>Strategy for determining the edge to contract.</p>
<ul>
<li><code>'weight'</code>: Contract a random one among the edges with the
smallest weight.</li>
<li><code>'matching'</code>: Contract an edge in a maximum matching.</li>
<li><code>'weight_and_matching'</code>: Contract an edge in a maximum matching
of the subgraph of the intermediate fusion network induced by
the edges with the smallest weight.</li>
<li><code>'random'</code>: Contract a random edge.</li>
</ul>
</dd>
<dt><strong><code>optimize_num_fusions</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, the average number of required fusion attempts are used
to quantify resource overheads instead of the average number of
required basic resource states.</dd>
<dt><strong><code>fusion_order</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>{int</code> or <code>str} (default: None)</code></dt>
<dd>
<p>Fusion order given explicitly as vertex names.</p>
<p>If it is not <code>None</code>, parameter <code>strategy</code> is ignored.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Outcomes of the calculation, which is a shallow copy of
<code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">GraphState.data</a></code>.<br>
The calculated overhead and number of steps can be obtained from
<code>data['overhead']</code> and <code>data['num_steps']</code>, respectively.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_overhead(self,
                       p_succ=0.5,
                       strategy=&#39;weight_and_matching&#39;,
                       optimize_num_fusions=False,
                       fusion_order=None):
    &#34;&#34;&#34;
    Calculate the resource overhead from the fusion network.

    `GraphState.build_fusion_network()` must be executed beforehand.

    The resulting data is saved in `GraphState.data`.

    Parameters
    ----------
    p_succ : float (default: 0.5)
        Success probability of a fusion.

    strategy: str, one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: &#39;weight_and_matching&#39;)
        Strategy for determining the edge to contract.

        - `&#39;weight&#39;`: Contract a random one among the edges with the
        smallest weight.
        - `&#39;matching&#39;`: Contract an edge in a maximum matching.
        - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
        of the subgraph of the intermediate fusion network induced by
        the edges with the smallest weight.
        - `&#39;random&#39;`: Contract a random edge.

    optimize_num_fusions : bool
        If `True`, the average number of required fusion attempts are used
        to quantify resource overheads instead of the average number of
        required basic resource states.

    fusion_order : None or list of {int or str} (default: None)
        Fusion order given explicitly as vertex names.

        If it is not `None`, parameter `strategy` is ignored.

    Returns
    -------
    data : dict
        Outcomes of the calculation, which is a shallow copy of
        `GraphState.data`.&lt;br&gt;
        The calculated overhead and number of steps can be obtained from
        `data[&#39;overhead&#39;]` and `data[&#39;num_steps&#39;]`, respectively.
    &#34;&#34;&#34;

    if self.fusion_network is None:
        raise ValueError(&#34;No fusion network created&#34;)

    # Trivial cases
    node_num = self.fusion_network.vcount()
    if node_num == 0:
        self.data[&#39;overhead&#39;] = 0
        self.data[&#39;num_fusions&#39;] = 0
        self.data[&#39;num_steps&#39;] = 0
        return self.data
    elif node_num == 1:
        self.data[&#39;overhead&#39;] = 1
        self.data[&#39;num_fusions&#39;] = 0
        self.data[&#39;num_steps&#39;] = 0
        return self.data

    if fusion_order is None:
        fusion_order = []
        is_fusion_order_given = False
    else:
        is_fusion_order_given = True

    self.fusion_network.es[&#39;order&#39;] = None

    # Initialize intermediate fusion network
    network = self.fusion_network.copy()
    network[&#39;p_succ&#39;] = p_succ
    network.vs[&#39;weight&#39;] = 1
    network.vs[&#39;weight_f&#39;] = 0
    network.vs[&#39;order&#39;] = 0
    network.vs[&#39;on&#39;] = True
    network.es[&#39;weight&#39;] = 2 / p_succ
    network.es[&#39;weight_f&#39;] = 1 / p_succ
    del network.es[&#39;order&#39;]

    turn = 0

    weight_key = &#39;weight_f&#39; if optimize_num_fusions else &#39;weight&#39;

    # Iterate until no edges remain in the fusion network
    while True:
        if not network.ecount():
            break

        if is_fusion_order_given:
            enames_curr_step = [str(fusion_order[turn])]
            is_parellel = True

        elif strategy == &#39;weight&#39;:
            min_weight = min(network.es[weight_key])
            eids_min_weight = network.es.select(weight=min_weight)
            enames_curr_step = eids_min_weight[&#39;name&#39;]
            is_parellel = len(enames_curr_step) == 1

        # elif strategy == &#39;betweenness&#39;:
        #     eb = np.array(network.edge_betweenness())
        #     min_eb = np.min(eb)
        #     eids_curr_step = np.nonzero(eb == min_eb)[0]
        #     enames_curr_step = [network.es[eid][&#39;name&#39;] for eid in
        #     eids_curr_step]
        #     is_parellel = len(enames_curr_step) == 1
        #
        # elif strategy == &#39;weight_and_betweenness&#39;:
        #     min_weight = min(network.es[&#39;weight&#39;])
        #     eids_min_weight = network.es.select(weight=min_weight)
        #     es_min_ovh = eids_min_weight
        #
        #     eb = network.edge_betweenness()
        #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
        #     min_eb = np.min(ebs_min_ovh)
        #     enames_curr_step = [es_min_ovh[i][&#39;name&#39;] for i in
        #     np.nonzero(ebs_min_ovh == min_eb)[0]]
        #     is_parellel = len(enames_curr_step) == 1

        elif &#39;matching&#39; in strategy:
            if strategy == &#39;weight_and_matching&#39;:
                min_weight = min(network.es[weight_key])
                if optimize_num_fusions:
                    es_min_weight = network.es.select(weight_f=min_weight)
                else:
                    es_min_weight = network.es.select(weight=min_weight)
                subnetwork = network.subgraph_edges(es_min_weight)
            else:
                subnetwork = network

            subnetwork_nx = subnetwork.to_networkx()
            if isinstance(subnetwork_nx, nx.MultiGraph):
                subnetwork_nx = nx.Graph(subnetwork_nx)
            matching = nx.max_weight_matching(subnetwork_nx, weight=None)
            enames_curr_step = \
                subnetwork.es[subnetwork.get_eids(matching)][&#39;name&#39;]

            is_parellel = True

        elif strategy == &#39;random&#39;:
            enames_curr_step = [np.random.choice(network.es[&#39;name&#39;])]
            is_parellel = True

        else:
            raise ValueError

        recalculated_enames = []

        # if get_fusion_order and not is_fusion_order_given:
        #     fusion_order_curr_step = set()
        #     fusion_order.append(fusion_order_curr_step)

        while True:
            if not is_parellel:
                for rec_ename in recalculated_enames:
                    try:
                        enames_curr_step.remove(rec_ename)
                    except ValueError:
                        pass

            if not enames_curr_step:
                break

            recalculated_enames.clear()

            if is_parellel:
                ename_to_merge = enames_curr_step.pop()
            else:
                ename_to_merge = np.random.choice(enames_curr_step)
                enames_curr_step.remove(ename_to_merge)

            # if get_fusion_order:
            #     e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
            #     v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
            #     fusion_order_curr_step.add((v1[&#39;name&#39;], v2[&#39;name&#39;],
            #                                 ename_to_merge))

            enames_updated_weight \
                = self._contract_edge(network,
                                      ename_to_merge)

            recalculated_enames.extend(enames_updated_weight)

    v_final = network.vs.select(on=True)
    overhead = sum(v_final[&#39;weight&#39;])
    num_fusions = sum(v_final[&#39;weight_f&#39;])
    num_steps = max(v_final[&#39;order&#39;])

    results = {
        &#39;overhead&#39;: overhead,
        &#39;num_fusions&#39;: num_fusions,
        &#39;num_steps&#39;: num_steps,
        &#39;fusion_order_strategy&#39;: strategy,
        &#39;p_succ&#39;: p_succ,
    }

    if optimize_num_fusions:
        results[&#39;optimize_num_fusions&#39;] = True

    # if get_fusion_order:
    #     results[&#39;fusion_order&#39;] = fusion_order

    self.data.update(results)

    return self.data.copy()</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a <strong>shallow</strong> copy of this object.</p>
<p>Use <code>copy.deepcopy()</code> to get a deep copy.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>copy</code></strong> :&ensp;<code><a title="optgraphstate.GraphState" href="#optgraphstate.GraphState">GraphState</a></code></dt>
<dd>Copied instance of itself.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Return a **shallow** copy of this object.

    Use `copy.deepcopy()` to get a deep copy.

    Returns
    -------
    copy : GraphState
        Copied instance of itself.
    &#34;&#34;&#34;

    copy = GraphState(graph=self.graph,
                      unraveled_graph=self.unraveled_graph,
                      fusion_network=self.fusion_network)

    copy.data = self.data.copy()

    return copy</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.get_instructions"><code class="name flex">
<span>def <span class="ident">get_instructions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the instruction to generate the desired graph state from multiple
three-qubit linear graph states.</p>
<p>One of <code><a title="optgraphstate.GraphState.calculate_overhead" href="#optgraphstate.GraphState.calculate_overhead">GraphState.calculate_overhead()</a></code>, <code><a title="optgraphstate.GraphState.simulate" href="#optgraphstate.GraphState.simulate">GraphState.simulate()</a></code>, and
<code><a title="optgraphstate.GraphState.simulate_adaptive" href="#optgraphstate.GraphState.simulate_adaptive">GraphState.simulate_adaptive()</a></code> must be executed beforehand.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>node_names</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>List of the names of nodes in the fusion network.</dd>
<dt><strong><code>fusions</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Dictionary that contains the information about required fusions and
Clifford gates.</p>
<p>Each required fusion is represented by a 2-tuple of 3-tuples:
<code>((n1, q1, cl1), (n2, q2, cl2))</code>. <code>n1</code> and <code>n2</code> are the names of
the nodes involved in the fusion, <code>q1</code> and <code>q2</code> are <code>'R'</code> or <code>'L'</code>
that indicate the qubits undergoing the fusion (<code>'R'</code> for a root
qubit and <code>'L'</code> for a leaf qubit), and <code>cl1</code> and <code>cl2</code> are the
Clifford gates applied to the qubits before the fusion is
performed.</p>
<p><code>fusions[i]</code> for a positive integer <code>i</code> is a list of such 2-tuples,
which indicate fusions that can be done in parallel in the <code>i</code>-th
step.</p>
</dd>
<dt><strong><code>qubit_correspondence</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Dictionary that contains the correspondence between the vertices in
the original graph and the final remaining qubits after performing
all the fusions.</p>
<p>For each name (say, <code>vname</code>) of a vertex in the original graph,
<code>qubit_correspondence[vname]</code> is a 3-tuple <code>(node, qubit, cl)</code>,
where <code>node</code> is the node containing the qubit, <code>qubit</code> is either
<code>'R'</code> or <code>'L'</code> that indicates whether the qubit is a root or leaf
qubit, and <code>cl</code> is the Clifford gate applied to the qubit.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_instructions(self):
    &#34;&#34;&#34;
    Get the instruction to generate the desired graph state from multiple
    three-qubit linear graph states.

    One of `GraphState.calculate_overhead()`, `GraphState.simulate()`, and
    `GraphState.simulate_adaptive()` must be executed beforehand.

    Returns
    -------
    node_names : list of str
        List of the names of nodes in the fusion network.

    fusions : dict
        Dictionary that contains the information about required fusions and
        Clifford gates.

        Each required fusion is represented by a 2-tuple of 3-tuples:
        `((n1, q1, cl1), (n2, q2, cl2))`. `n1` and `n2` are the names of
        the nodes involved in the fusion, `q1` and `q2` are `&#39;R&#39;` or `&#39;L&#39;`
        that indicate the qubits undergoing the fusion (`&#39;R&#39;` for a root
        qubit and `&#39;L&#39;` for a leaf qubit), and `cl1` and `cl2` are the
        Clifford gates applied to the qubits before the fusion is
        performed.

        `fusions[i]` for a positive integer `i` is a list of such 2-tuples,
        which indicate fusions that can be done in parallel in the `i`-th
        step.

    qubit_correspondence : dict
        Dictionary that contains the correspondence between the vertices in
        the original graph and the final remaining qubits after performing
        all the fusions.

        For each name (say, `vname`) of a vertex in the original graph,
        `qubit_correspondence[vname]` is a 3-tuple `(node, qubit, cl)`,
        where `node` is the node containing the qubit, `qubit` is either
        `&#39;R&#39;` or `&#39;L&#39;` that indicates whether the qubit is a root or leaf
        qubit, and `cl` is the Clifford gate applied to the qubit.
    &#34;&#34;&#34;
    network = self.fusion_network

    # Fusions
    fusions = {}
    orders = network.es[&#39;order&#39;]
    num_steps = max(orders)
    for order in range(1, num_steps + 1):
        inst_same_order = []
        links = network.es.select(order=order)
        for link in links:
            nname1 = link.source_vertex[&#39;name&#39;]
            nname2 = link.target_vertex[&#39;name&#39;]
            kind = link[&#39;kind&#39;]
            if kind == &#39;RR&#39;:
                qubit1 = qubit2 = &#39;R&#39;
            elif kind == &#39;LL&#39;:
                qubit1 = qubit2 = &#39;L&#39;
            else:
                root_node = link[&#39;root_node&#39;]
                qubit1 = &#39;R&#39; if root_node == nname1 else &#39;L&#39;
                qubit2 = &#39;L&#39; if qubit1 == &#39;R&#39; else &#39;R&#39;
            cliffords = link[&#39;cliffords&#39;]
            try:
                cl1 = cliffords[nname1]
            except KeyError:
                cl1 = None
            try:
                cl2 = cliffords[nname2]
            except KeyError:
                cl2 = None

            inst_same_order.append(((nname1, qubit1, cl1),
                                    (nname2, qubit2, cl2)))

        fusions[order] = inst_same_order

    # Final remaining qubits &amp; Clifford gates on them
    qubit_correspondence = {}
    remaining_leaves = {}
    for vname in self.graph.vs[&#39;name&#39;]:
        v_unrv: ig.Vertex = self.unraveled_graph.vs.find(name=vname)
        cl = v_unrv[&#39;clifford&#39;]

        if v_unrv.degree() &gt; 1:
            corr = (vname, &#39;R&#39;, cl)

        else:
            v_ngh_unrv = v_unrv.neighbors()[0]
            seed_node_name = v_ngh_unrv[&#39;name&#39;]
            try:
                remaining_leaves_curr \
                    = remaining_leaves[seed_node_name]
            except KeyError:
                node_group \
                    = network.vs.select(node_group=seed_node_name)
                remaining_leaves_curr = {}
                for node in node_group:
                    num_remaining_leaves = 2
                    for link in node.incident():
                        kind = link[&#39;kind&#39;]
                        if kind == &#39;LL&#39; \
                                or (kind == &#39;RL&#39;
                                    and link[&#39;root_node&#39;] != node[&#39;name&#39;]):
                            num_remaining_leaves -= 1
                    remaining_leaves_curr[node[&#39;name&#39;]] \
                        = num_remaining_leaves
                remaining_leaves[seed_node_name] = remaining_leaves_curr

            corr = None
            for node_name, num_remaining_leaves in remaining_leaves_curr.items():
                if num_remaining_leaves:
                    corr = (node_name, &#39;L&#39;, cl)
                    remaining_leaves_curr[node_name] -= 1

            assert corr is not None

        qubit_correspondence[vname] = corr

    node_names = network.vs[&#39;name&#39;]

    return node_names, fusions, qubit_correspondence</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.get_link_clifford"><code class="name flex">
<span>def <span class="ident">get_link_clifford</span></span>(<span>self, n1, n2)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Clifford gates that need to be applied to two qubits involved
in the fusion of a given link.</p>
<p>Each Clifford gate is represented by a string. For example, <code>'RX'</code> and
<code>'RZ'</code> respectively mean pi/2 X-rotation (Z-rotation). If a qubit is
subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
represented by <code>'RX-RZ'</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n1</code></strong>, <strong><code>n2</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Names of the nodes connected by the link.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cl1</code></strong>, <strong><code>cl2</code></strong> :&ensp;<code>None</code> or <code>str</code></dt>
<dd>Clifford gates applied on the two qubits involved in the fusion
of the link.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_link_clifford(self, n1, n2):
    &#34;&#34;&#34;
    Get the Clifford gates that need to be applied to two qubits involved
    in the fusion of a given link.

    Each Clifford gate is represented by a string. For example, `&#39;RX&#39;` and
    `&#39;RZ&#39;` respectively mean pi/2 X-rotation (Z-rotation). If a qubit is
    subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
    represented by `&#39;RX-RZ&#39;`.

    Parameters
    ----------
    n1, n2 : int or str
        Names of the nodes connected by the link.

    Returns
    -------
    cl1, cl2 : None or str
        Clifford gates applied on the two qubits involved in the fusion
        of the link.
    &#34;&#34;&#34;

    network = self.fusion_network
    n1 = str(n1)
    n2 = str(n2)

    link = network.es[network.get_eid(n1, n2)]
    cliffords = link[&#39;cliffords&#39;]
    cls = []
    for n in [n1, n2]:
        try:
            cls.append(cliffords[n])
        except KeyError:
            cls.append(None)

    return tuple(cls)</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.get_vertex_clifford"><code class="name flex">
<span>def <span class="ident">get_vertex_clifford</span></span>(<span>self, vertex, unraveled=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the Clifford gate applied to a vertex in the unraveled graph
(by default) or the original graph.</p>
<p>Each Clifford gate is represented by a string. For example, <code>'RX'</code>
and <code>'RZ'</code> respectively mean pi/2 X-rotation (Z-rotation). If a qubit
is subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
represented by <code>'RX-RZ'</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vertex</code></strong> :&ensp;<code>int</code> or <code>str</code></dt>
<dd>Name of the vertex.</dd>
<dt><strong><code>unraveled</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to find the vertex in the unraveled or original graph.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>clifford</code></strong> :&ensp;<code>None</code> or <code>str</code></dt>
<dd>Clifford gate applied to the vertex.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_vertex_clifford(self, vertex, unraveled=True):
    &#34;&#34;&#34;
    Get the Clifford gate applied to a vertex in the unraveled graph
    (by default) or the original graph.

    Each Clifford gate is represented by a string. For example, `&#39;RX&#39;`
    and `&#39;RZ&#39;` respectively mean pi/2 X-rotation (Z-rotation). If a qubit
    is subjected to pi/2 X-rotation followed by pi/2 Z-rotation, it is
    represented by `&#39;RX-RZ&#39;`.

    Parameters
    ----------
    vertex : int or str
        Name of the vertex.

    unraveled : bool (default: True)
        Whether to find the vertex in the unraveled or original graph.

    Returns
    -------
    clifford : None or str
        Clifford gate applied to the vertex.
    &#34;&#34;&#34;

    graph = self.unraveled_graph if unraveled else self.graph
    if &#39;clifford&#39; in graph.vertex_attributes():
        cl = graph.vs.find(name=str(vertex))[&#39;clifford&#39;]
        return cl
    else:
        return None</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the created unraveled graph and fusion network and the
calculation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    &#34;&#34;&#34;
    Initialize the created unraveled graph and fusion network and the
    calculation data.
    &#34;&#34;&#34;
    self.unraveled_graph = None
    self.fusion_network = None
    self.data = {}</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.plot_fusion_network"><code class="name flex">
<span>def <span class="ident">plot_fusion_network</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the fusion network.</p>
<p>Links have different styles and colors depending on their types:</p>
<ul>
<li>'LL': Black solid line.</li>
<li>'RR': Red dashed line.</li>
<li>'RL': Blue arrow from leaf to root.</li>
</ul>
<p>The number placed on each link indicates the order of the fusion. It is
presented only when the resource overhead has been computed beforehand.</p>
<p>Links with <code>'C'</code> written on them indicate fusions accompanied by
non-trivial Clifford gates. These Clifford gates can be obtained by
using <code><a title="optgraphstate.GraphState.get_link_clifford" href="#optgraphstate.GraphState.get_link_clifford">GraphState.get_link_clifford()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>None</code> or <code>matplotlib Axes object (default: None)</code></dt>
<dd>If given, the figure is plotted on the given <code>Axes</code> object.</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>str (default: 'auto')</code></dt>
<dd>Layout algorithm for plotting.<br>
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a></dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>2-tuple</code> of <code>float (default: (5, 5))</code></dt>
<dd>Size of the figure in inches.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>None</code> or <code>str (default: None)</code></dt>
<dd>Path to save the figure.</dd>
<dt><strong><code>show_node_names</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>If <code>True</code>, node names are shown.</dd>
<dt><strong><code>node_color</code></strong> :&ensp;<code>str (default: 'white')</code></dt>
<dd>Color of nodes.</dd>
<dt><strong><code>show_link_names</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>If <code>True</code>, link names are shown.</dd>
<dt><strong><code>show_fusion_orders</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>
<p>If <code>True</code>, fusion orders are shown on links.</p>
<p>If both <code>show_link_names</code> and <code>show_fusion_orders</code> are <code>True</code>,
it is shown as <code>'{link name}-{fusion order}'</code></p>
</dd>
<dt><strong><code>show_link_cliffords</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>
<p>If <code>True</code>, links that correspond to fusions accompanied by
non-trivial Clifford gates are marked as <code>'C'</code>.</p>
<p>If <code>show_link_names</code> or <code>show_fusion_orders</code> are <code>True</code>, <code>'C'</code> is
appended to the end of the label.</p>
</dd>
<dt><strong><code>link_color_ll</code></strong> :&ensp;<code>str (default: 'black')</code></dt>
<dd>Color of leaf-to-leaf links.</dd>
<dt><strong><code>link_color_rl</code></strong> :&ensp;<code>str (default: 'blue')</code></dt>
<dd>Color of root-to-leaf links.</dd>
<dt><strong><code>link_color_rr</code></strong> :&ensp;<code>str (default: 'red')</code></dt>
<dd>Color of root-to-root links.</dd>
<dt><strong><code>arrow_size</code></strong> :&ensp;<code>float (default: 0.02)</code></dt>
<dd>Size of arrows for root-to-leaf links.</dd>
</dl>
<p>Any other keyword arguments in igraph.plot can be directly used.<br>
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a> <br>
If they are given, they override the above parameters.<br></p>
<h2 id="returns">Returns</h2>
<p>fig, ax : matplotlib Figure and Axes object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_fusion_network(self, **kwargs):
    &#34;&#34;&#34;
    Plot the fusion network.

    Links have different styles and colors depending on their types:

    - &#39;LL&#39;: Black solid line.
    - &#39;RR&#39;: Red dashed line.
    - &#39;RL&#39;: Blue arrow from leaf to root.

    The number placed on each link indicates the order of the fusion. It is
    presented only when the resource overhead has been computed beforehand.

    Links with `&#39;C&#39;` written on them indicate fusions accompanied by
    non-trivial Clifford gates. These Clifford gates can be obtained by
    using `GraphState.get_link_clifford()`.

    Parameters
    ----------
    ax : None or matplotlib Axes object (default: None)
        If given, the figure is plotted on the given `Axes` object.

    layout : str (default: &#39;auto&#39;)
        Layout algorithm for plotting.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

    figsize : 2-tuple of float (default: (5, 5))
        Size of the figure in inches.

    save : None or str (default: None)
        Path to save the figure.

    show_node_names : bool (default: True)
        If `True`, node names are shown.

    node_color : str (default: &#39;white&#39;)
        Color of nodes.

    show_link_names : bool (default: False)
        If `True`, link names are shown.

    show_fusion_orders : bool (default: True)
        If `True`, fusion orders are shown on links.

        If both `show_link_names` and `show_fusion_orders` are `True`,
        it is shown as `&#39;{link name}-{fusion order}&#39;`

    show_link_cliffords : bool (default: True)
        If `True`, links that correspond to fusions accompanied by
        non-trivial Clifford gates are marked as `&#39;C&#39;`.

        If `show_link_names` or `show_fusion_orders` are `True`, `&#39;C&#39;` is
        appended to the end of the label.

    link_color_ll : str (default: &#39;black&#39;)
        Color of leaf-to-leaf links.

    link_color_rl : str (default: &#39;blue&#39;)
        Color of root-to-leaf links.

    link_color_rr : str (default: &#39;red&#39;)
        Color of root-to-root links.

    arrow_size : float (default: 0.02)
        Size of arrows for root-to-leaf links.

    Any other keyword arguments in igraph.plot can be directly used.&lt;br&gt;
    See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
    If they are given, they override the above parameters.&lt;br&gt;

    Returns
    -------
    fig, ax : matplotlib Figure and Axes object.
    &#34;&#34;&#34;

    network = self.fusion_network
    if network is None:
        raise ValueError(&#39;No fusion network created.&#39;)

    fig, ax = plot_fusion_network(network, **kwargs)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.plot_graph"><code class="name flex">
<span>def <span class="ident">plot_graph</span></span>(<span>self, unraveled=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the original or unraveled graph.</p>
<p>If the unraveled graph is plotted, edges in the unraveled graph are
drawn as black solid lines while external fusions are drawn as red
dashed lines (by default).</p>
<p>Vertices with Clifford gates are colored in orange (by default).
These Clifford gates can be obtained by using
<code><a title="optgraphstate.GraphState.get_vertex_clifford" href="#optgraphstate.GraphState.get_vertex_clifford">GraphState.get_vertex_clifford()</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unraveled</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to plot the unraveled graph or the original graph.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>None</code> or <code>matplotlib Axes object (default: None)</code></dt>
<dd>If given, the figure is plotted on the given <code>Axes</code> object.</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>str (default: 'auto')</code></dt>
<dd>
<p>Layout algorithm for plotting.</p>
<p>See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a></p>
</dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>2-tuple</code> of <code>float (default: (5, 5))</code></dt>
<dd>Size of the figure in inches.</dd>
<dt><strong><code>save</code></strong> :&ensp;<code>None</code> or <code>str (default: None)</code></dt>
<dd>Path to save the figure.</dd>
<dt><strong><code>show_vertex_names</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>If <code>True</code>, vertex names are shown.</dd>
<dt><strong><code>vertex_color_normal</code></strong> :&ensp;<code>str (default: 'white')</code></dt>
<dd>Color of vertices without Clifford gates.</dd>
<dt><strong><code>vertex_color_clifford</code></strong> :&ensp;<code>str (default: 'orange')</code></dt>
<dd>Color of vertices with Clifford gates.</dd>
<dt><strong><code>vertices_to_highlight</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>{str</code> or <code>int} (default: None)</code></dt>
<dd>Name of vertices to highlight.</dd>
<dt><strong><code>vertex_color_highlight</code></strong> :&ensp;<code>str (default: purple)</code></dt>
<dd>
<p>Color of the highlighted vertices.</p>
<p>Ignored if <code>vertices_to_highlight</code> is <code>None</code>.</p>
</dd>
<dt><strong><code>edge_color_normal</code></strong> :&ensp;<code>str (default: black)</code></dt>
<dd>Color of edges in the graph.</dd>
<dt><strong><code>edge_color_fusion</code></strong> :&ensp;<code>str (default: red)</code></dt>
<dd>
<p>Color of lines for external fusions.</p>
<p>Ignored if <code>unraveled</code> is <code>False</code>.</p>
</dd>
<dt><strong><code>edge_style_fusion</code></strong> :&ensp;<code>str (default: '--')</code></dt>
<dd>Style of lines for external fusions.</dd>
</dl>
<p>Any other keyword arguments in <code>igraph.plot()</code> can be directly used.
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a>
If they are given, they override the above parameters.</p>
<h2 id="returns">Returns</h2>
<p>fig, ax : matplotlib Figure and Axes object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_graph(self, unraveled=False, **kwargs):
    &#34;&#34;&#34;
    Plot the original or unraveled graph.

    If the unraveled graph is plotted, edges in the unraveled graph are
    drawn as black solid lines while external fusions are drawn as red
    dashed lines (by default).

    Vertices with Clifford gates are colored in orange (by default).
    These Clifford gates can be obtained by using
    `GraphState.get_vertex_clifford()`.

    Parameters
    ----------
    unraveled : bool (default: False)
        Whether to plot the unraveled graph or the original graph.

    ax : None or matplotlib Axes object (default: None)
        If given, the figure is plotted on the given `Axes` object.

    layout : str (default: &#39;auto&#39;)
        Layout algorithm for plotting.

        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

    figsize : 2-tuple of float (default: (5, 5))
        Size of the figure in inches.

    save : None or str (default: None)
        Path to save the figure.

    show_vertex_names : bool (default: True)
        If `True`, vertex names are shown.

    vertex_color_normal : str (default: &#39;white&#39;)
        Color of vertices without Clifford gates.

    vertex_color_clifford : str (default: &#39;orange&#39;)
        Color of vertices with Clifford gates.

    vertices_to_highlight : None or list of {str or int} (default: None)
        Name of vertices to highlight.

    vertex_color_highlight : str (default: purple)
        Color of the highlighted vertices.

        Ignored if `vertices_to_highlight` is `None`.

    edge_color_normal : str (default: black)
        Color of edges in the graph.

    edge_color_fusion : str (default: red)
        Color of lines for external fusions.

        Ignored if `unraveled` is `False`.

    edge_style_fusion : str (default: &#39;--&#39;)
        Style of lines for external fusions.

    Any other keyword arguments in `igraph.plot()` can be directly used.
    See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting
    If they are given, they override the above parameters.

    Returns
    -------
    fig, ax : matplotlib Figure and Axes object.
    &#34;&#34;&#34;

    graph = self.unraveled_graph if unraveled else self.graph
    if graph is None:
        raise ValueError(&#34;No unraveled graph created.&#34;)

    fig, ax = plot_graph(graph, **kwargs)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, n_iter, p_succ=0.5, mp=False, n_procs=None, get_all_data=False, get_all_graphs=False, get_all_fusion_networks=False, unravel=True, unravel_bcs_first='random', fusion_order_strategy='weight_and_matching', optimize_num_fusions=False, seed='keep', verbose=True, pbar=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the strategy for a fixed number of iterations and obtain the
best one only (by default).</p>
<p>Attributes such as <code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">GraphState.data</a></code>, <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code>, and
<code><a title="optgraphstate.GraphState.fusion_network" href="#optgraphstate.GraphState.fusion_network">GraphState.fusion_network</a></code> are updated according to the result of the
best sample.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Iteration number.</dd>
<dt><strong><code>p_succ</code></strong> :&ensp;<code>float (default: 0.5)</code></dt>
<dd>Success probability of a fusion.</dd>
<dt><strong><code>mp</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>
<p>Whether to use multiprocessing for the iterations.</p>
<p>Package <em>parmap</em> should be installed to use it.</p>
</dd>
<dt><strong><code>n_procs</code></strong> :&ensp;<code>None</code> or <code>int (default: None)</code></dt>
<dd>
<p>Maximal number of simultaneous processes for multiprocessing.</p>
<p>If it is <code>None</code>, the number of CPUs is used.</p>
<p>Ignored when <code>mp</code> is <code>False</code>.</p>
</dd>
<dt><strong><code>get_all_data</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to obtain the data (overheads, numbers of steps, etc.) from
all samples or only the best sample.</dd>
<dt><strong><code>get_all_graphs</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to obtain the unraveled graphs from all samples or only the
best sample.</dd>
<dt><strong><code>get_all_fusion_networks</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to obtain the fusion networks from all samples or only the
best sample.</dd>
<dt><strong><code>unravel</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to unravel the graph or not.</dd>
<dt><strong><code>unravel_bcs_first</code></strong> :&ensp;<code>one</code> of <code>[True, False, 'random'] (default: 'random')</code></dt>
<dd>
<ul>
<li><code>True</code>: BCSs are unraveled first, then clqiues are unraveled.</li>
<li><code>False</code>, cliques are unraveled first, then BCSs are unraveled.</li>
<li><code>'random'</code>, the order is randomly chosen.</li>
</ul>
</dd>
<dt><strong><code>fusion_order_strategy</code></strong> :&ensp;<code>one</code> of <code>['weight', 'matching', 'weight_and_matching', 'random'] (default:</code>weight_and_matching')`</dt>
<dd>
<p>Strategy for determining the edge to contract in each step.</p>
<ul>
<li><code>'weight'</code>: Contract a random one among the edges with the
smallest weight.</li>
<li><code>'matching'</code>: Contract an edge in a maximum matching.</li>
<li><code>'weight_and_matching'</code>: Contract an edge in a maximum matching
of the subgraph of the intermediate fusion network induced by
the edges with the smallest weight.</li>
<li><code>'random'</code>: Contract a random edge.</li>
</ul>
</dd>
<dt><strong><code>optimize_num_fusions</code></strong> :&ensp;<code>bool</code></dt>
<dd>If <code>True</code>, use the averagte number of fusion attempts to quantify
resource overheads instead of the average number of basic resource
states.</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>'keep'</code> or <code>None</code> or <code>int (default: 'keep')</code></dt>
<dd>
<p>Random seed.</p>
<ul>
<li><code>'keep'</code>: The seed is not initialized.</li>
<li><code>None</code>: The current time is used as the random seed.</li>
<li><code>int</code>: The given number is used as the random seed.</li>
</ul>
<p>If <code>n_iter&gt;1</code>, the given seed is used to sample random seeds for
individual iterations. However, if <code>n_iter==1</code>, the given seed is
used as the random seed for the (only one) iteration itself.</p>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to print logs.</dd>
<dt><strong><code>pbar</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>
<p>Whether to show a progress bar.</p>
<p>Ignored if <code>mp</code> is <code>False</code></p>
</dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Additional keyword arguments for calculating overheads.</p>
<p>See the description of <code><a title="optgraphstate.GraphState.calculate_overhead" href="#optgraphstate.GraphState.calculate_overhead">GraphState.calculate_overhead()</a></code>.</p>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>res</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Result of the iterations.</p>
<p>By default, only the information of the best sample is returned.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self,
             n_iter,
             p_succ=0.5,
             mp=False,
             n_procs=None,
             get_all_data=False,
             get_all_graphs=False,
             get_all_fusion_networks=False,
             unravel=True,
             unravel_bcs_first=&#39;random&#39;,
             fusion_order_strategy=&#39;weight_and_matching&#39;,
             optimize_num_fusions=False,
             seed=&#39;keep&#39;,
             verbose=True,
             pbar=False,
             **kwargs):
    &#34;&#34;&#34;
    Execute the strategy for a fixed number of iterations and obtain the
    best one only (by default).

    Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
    `GraphState.fusion_network` are updated according to the result of the
    best sample.

    Parameters
    ----------
    n_iter : int
        Iteration number.

    p_succ : float (default: 0.5)
        Success probability of a fusion.

    mp : bool (default: False)
        Whether to use multiprocessing for the iterations.

        Package *parmap* should be installed to use it.

    n_procs : None or int (default: None)
        Maximal number of simultaneous processes for multiprocessing.

        If it is `None`, the number of CPUs is used.

        Ignored when `mp` is `False`.

    get_all_data : bool (default: False)
        Whether to obtain the data (overheads, numbers of steps, etc.) from
        all samples or only the best sample.

    get_all_graphs : bool (default: False)
        Whether to obtain the unraveled graphs from all samples or only the
        best sample.

    get_all_fusion_networks : bool (default: False)
        Whether to obtain the fusion networks from all samples or only the
        best sample.

    unravel : bool (default: True)
        Whether to unravel the graph or not.

    unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
        - `True`: BCSs are unraveled first, then clqiues are unraveled.
        - `False`, cliques are unraveled first, then BCSs are unraveled.
        - `&#39;random&#39;`, the order is randomly chosen.

    fusion_order_strategy : one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: `weight_and_matching&#39;)
        Strategy for determining the edge to contract in each step.

        - `&#39;weight&#39;`: Contract a random one among the edges with the
        smallest weight.
        - `&#39;matching&#39;`: Contract an edge in a maximum matching.
        - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
        of the subgraph of the intermediate fusion network induced by
        the edges with the smallest weight.
        - `&#39;random&#39;`: Contract a random edge.

    optimize_num_fusions : bool
        If `True`, use the averagte number of fusion attempts to quantify
        resource overheads instead of the average number of basic resource
        states.

    seed : &#39;keep&#39; or None or int (default: &#39;keep&#39;)
        Random seed.

        - `&#39;keep&#39;`: The seed is not initialized.
        - `None`: The current time is used as the random seed.
        - `int`: The given number is used as the random seed.

        If `n_iter&gt;1`, the given seed is used to sample random seeds for
        individual iterations. However, if `n_iter==1`, the given seed is
        used as the random seed for the (only one) iteration itself.

    verbose : bool (default: True)
        Whether to print logs.

    pbar : bool (default: False)
        Whether to show a progress bar.

        Ignored if `mp` is `False`

    kwargs : dict
        Additional keyword arguments for calculating overheads.

        See the description of `GraphState.calculate_overhead()`.

    Returns
    -------
    res : dict
        Result of the iterations.

        By default, only the information of the best sample is returned.
    &#34;&#34;&#34;

    t0 = time.time()

    overhead_key = &#39;num_fusions&#39; if optimize_num_fusions else &#39;overhead&#39;

    if seed != &#39;keep&#39;:
        np.random.seed(seed)

    if mp:
        if n_procs is None:
            n_procs = os.cpu_count()
        mp = mp and n_iter &gt;= n_procs

    if not mp:
        if verbose:
            print(&#34;Multiprocessing OFF.&#34;)
            print(f&#34;Calculating for n_iter = {n_iter}...&#34;)

        if n_iter == 1 and seed is not None and seed != &#39;keep&#39;:
            seeds_samples = [seed]
        else:
            seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

        overheads = [] if get_all_data else None
        nums_fusions = [] if get_all_data else None
        nums_steps = [] if get_all_data else None
        seeds = [] if get_all_data else None
        unravalled_graphs = [] if get_all_graphs else None
        fusion_networks = [] if get_all_fusion_networks else None

        best_sample = None
        lowest_overhead = None
        for i_sample in range(n_iter):
            seed_sample = seeds_samples[i_sample]
            np.random.seed(seed_sample)

            if unravel:
                self.unraveled_graph = None
                try:
                    self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                except:
                    print(&#39;Error occurs during unraveling&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

            try:
                self.build_fusion_network(use_unraveled_graph=unravel)
            except:
                print(&#39;Error occurs during building fusion network&#39;)
                print(&#39;seed =&#39;, seed_sample)
                raise ValueError

            try:
                data_now = self.calculate_overhead(
                    p_succ=p_succ,
                    strategy=fusion_order_strategy,
                    optimize_num_fusions=optimize_num_fusions,
                    **kwargs)
            except:
                print(&#39;Error occurs during calculating overhead&#39;)
                print(&#39;seed =&#39;, seed_sample)
                raise ValueError

            overhead_now = data_now[overhead_key]
            num_steps_now = data_now[&#39;num_steps&#39;]
            self.data[&#39;seed&#39;] = seed_sample

            if lowest_overhead is None or overhead_now &lt; lowest_overhead:
                best_sample = i_sample
                lowest_overhead = overhead_now
                best_ogs = self.copy()

            if get_all_data:
                overheads.append(data_now[&#39;overhead&#39;])
                nums_fusions.append(data_now[&#39;num_fusions&#39;])
                nums_steps.append(num_steps_now)
                seeds.append(seed_sample)

            if get_all_graphs:
                unravalled_graphs.append(self.unraveled_graph)

            if get_all_fusion_networks:
                fusion_networks.append(self.fusion_network)

        res = {
            &#39;best_overhead&#39;: best_ogs.data[&#39;overhead&#39;],
            &#39;best_num_fusions&#39;: best_ogs.data[&#39;num_fusions&#39;],
            &#39;best_num_steps&#39;: best_ogs.data[&#39;num_steps&#39;],
            &#39;best_seed&#39;: best_ogs.data[&#39;seed&#39;],
            &#39;n_iter&#39;: n_iter}

        if unravel:
            res[&#39;unravel_bcs_first&#39;] = best_ogs.data[&#39;unravel_bcs_first&#39;]

        if get_all_data or get_all_graphs or get_all_fusion_networks:
            res[&#39;best_sample&#39;] = best_sample

            if get_all_data:
                res[&#39;overheads&#39;] = overheads
                res[&#39;nums_fusions&#39;] = nums_fusions
                res[&#39;nums_steps&#39;] = nums_steps
                res[&#39;seeds&#39;] = seeds

            if get_all_graphs:
                res[&#39;unraveled_graphs&#39;] = unravalled_graphs

            if get_all_fusion_networks:
                res[&#39;fusion_networks&#39;] = fusion_networks

    else:
        if &#39;parmap&#39; not in sys.modules:
            raise ModuleNotFoundError(&#34;Package parmap is not installed.&#34;)

        if verbose:
            print(f&#34;Multiprocessing ON: n_procs = {n_procs}&#34;)
            print(f&#34;Calculating for n_iter = {n_iter}... &#34;, end=&#39;&#39;)

        additional_keys = []
        if get_all_data:
            additional_keys.extend([&#39;overheads&#39;, &#39;nums_fusions&#39;,
                                    &#39;nums_steps&#39;, &#39;seeds&#39;])
        if get_all_graphs:
            additional_keys.append(&#39;unraveled_graphs&#39;)
        if get_all_fusion_networks:
            additional_keys.append(&#39;fusion_networks&#39;)

        left = n_iter % n_procs
        ns_samples = [n_iter // n_procs] * n_procs
        for i in range(left):
            ns_samples[i] += 1

        seeds = np.random.randint(0, _max_seed(), size=n_procs)

        res_procs = parmap.starmap(
            _simulate_single,
            list(zip(ns_samples, seeds)),
            self.graph,
            p_succ=p_succ,
            get_all_data=get_all_data,
            get_all_graphs=get_all_graphs,
            get_all_fusion_networks=get_all_fusion_networks,
            unravel=unravel,
            unravel_bcs_first=unravel_bcs_first,
            fusion_order_strategy=fusion_order_strategy,
            optimize_num_fusions=optimize_num_fusions,
            pm_pbar=pbar,
            **kwargs)
        best_proc = np.argmin(
            [res_each[f&#39;best_{overhead_key}&#39;] for res_each in res_procs]
        )
        res = res_procs[best_proc]
        res[&#39;n_iter&#39;] = n_iter
        best_ogs = res[&#39;best_ogs&#39;]
        del res[&#39;best_ogs&#39;]

        if additional_keys:
            res[&#39;best_sample&#39;] += sum(ns_samples[:best_proc])

        for key in additional_keys:
            vals = [res_each[key] for res_each in res_procs]
            res[key] = list(itertools.chain(*vals))

    if verbose:
        print(f&#34;Done. Best: {res[f&#39;best_{overhead_key}&#39;]:.2f} &#34;
              f&#34;({time.time() - t0:.2f} s)&#34;)

    self.unraveled_graph = best_ogs.unraveled_graph
    self.fusion_network = best_ogs.fusion_network
    self.data = best_ogs.data

    return res</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.simulate_adaptive"><code class="name flex">
<span>def <span class="ident">simulate_adaptive</span></span>(<span>self, init_n_iter, mul=2, p_succ=0.5, mp=False, n_procs=None, get_all_data=False, get_all_graphs=False, get_all_fusion_networks=False, unravel=True, unravel_bcs_first='random', fusion_order_strategy='weight_and_matching', optimize_num_fusions=False, seed='keep', verbose=True, pbar=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the adaptive iteration method for the strategy and obtain the
best one only (by default).</p>
<p>The adaptive iteration method looks for the best iteration while
keeps increasing the iteration number until a certain condition
meets. In detail, denoting N iterations of the strategy as R(N),
R(<code>init_n_iter</code>) is first executed and <code>q0</code> is obtained which is the
lowest resource overhead. Then, R(<code>mul</code>*<code>init_n_iter</code>) is executed
and <code>q1</code> is obtained similarly. If <code>q0 &lt;= q1</code>, <code>q0</code> is returned. If
otherwise, R(<code>mul**2*init_n_iter</code>) is executed and <code>q2</code> is obtained.
If <code>q1 &lt;= q2</code>, <code>q1</code> is returned. If otherwise, R(<code>mul**3*init_n_iter</code>)
is executed, and so on.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>init_n_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Initial iteration number.</dd>
<dt><strong><code>mul</code></strong> :&ensp;<code>int (default: 2)</code></dt>
<dd>Multiplicative factor of the iteration number.</dd>
</dl>
<p>See the description of <code><a title="optgraphstate.GraphState.simulate" href="#optgraphstate.GraphState.simulate">GraphState.simulate()</a></code> for the other parameters.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>res</code></strong> :&ensp;<code>dict</code></dt>
<dd>
<p>Result of the iterations.</p>
<p>By default, only the information of the best sample is given.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_adaptive(self,
                      init_n_iter,
                      mul=2,
                      p_succ=0.5,
                      mp=False,
                      n_procs=None,
                      get_all_data=False,
                      get_all_graphs=False,
                      get_all_fusion_networks=False,
                      unravel=True,
                      unravel_bcs_first=&#39;random&#39;,
                      fusion_order_strategy=&#39;weight_and_matching&#39;,
                      optimize_num_fusions=False,
                      seed=&#39;keep&#39;,
                      verbose=True,
                      pbar=False,
                      **kwargs):
    &#34;&#34;&#34;
    Run the adaptive iteration method for the strategy and obtain the
    best one only (by default).

    The adaptive iteration method looks for the best iteration while
    keeps increasing the iteration number until a certain condition
    meets. In detail, denoting N iterations of the strategy as R(N),
    R(`init_n_iter`) is first executed and `q0` is obtained which is the
    lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
    and `q1` is obtained similarly. If `q0 &lt;= q1`, `q0` is returned. If
    otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
    If `q1 &lt;= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
    is executed, and so on.

    Parameters
    ----------
    init_n_iter : int
        Initial iteration number.

    mul : int (default: 2)
        Multiplicative factor of the iteration number.

    See the description of `GraphState.simulate()` for the other parameters.

    Returns
    -------
    res : dict
        Result of the iterations.

        By default, only the information of the best sample is given.
    &#34;&#34;&#34;

    if mp and n_procs is None:
        n_procs = os.cpu_count()

    if seed != &#39;keep&#39;:
        np.random.seed(seed)

    additional_keys = []
    if get_all_data:
        additional_keys.extend([&#39;overheads&#39;, &#39;nums_fusions&#39;, &#39;nums_steps&#39;])
    if get_all_graphs:
        additional_keys.append(&#39;unraveled_graphs&#39;)
    if get_all_fusion_networks:
        additional_keys.append(&#39;fusion_networks&#39;)

    if verbose:
        if mp:
            print(f&#34;Multiprocessing (n_procs = {n_procs})&#34;)
        else:
            print(&#34;No multiprocessing&#34;)

    best_overhead_key \
        = &#39;best_num_fusions&#39; if optimize_num_fusions else &#39;best_overhead&#39;

    n_iter_history = []
    n_iter_now = init_n_iter
    res = None

    while True:
        if verbose:
            print(f&#34;Calculating for n_iter = {n_iter_now}... &#34;, end=&#39;&#39;)
        t0 = time.time()

        n_iter_history.append(n_iter_now)
        res_now = self.simulate(
            n_iter=n_iter_now,
            p_succ=p_succ,
            mp=mp,
            n_procs=n_procs,
            get_all_data=get_all_data,
            get_all_graphs=get_all_graphs,
            get_all_fusion_networks=get_all_fusion_networks,
            unravel=unravel,
            unravel_bcs_first=unravel_bcs_first,
            fusion_order_strategy=fusion_order_strategy,
            optimize_num_fusions=optimize_num_fusions,
            verbose=False,
            pbar=pbar,
            **kwargs
        )

        if res is None:
            res = res_now
            best_ogs = self.copy()
            n_iter_now *= mul

        else:
            for key in additional_keys:
                res[key].extend(res_now[key])

            if res_now[best_overhead_key] &lt; res[best_overhead_key]:
                for key in additional_keys:
                    res_now[key] = res[key]
                res = res_now
                best_ogs = self.copy()

                n_iter_now *= mul

            else:
                if verbose:
                    print(f&#34;Done. Best: {res[best_overhead_key]:.2f} (&#34;
                          f&#34;{time.time() - t0:.2f} s)&#34;)
                break

        if verbose:
            print(f&#34;Done. Best: {res[best_overhead_key]:.2f} &#34;
                  f&#34;({time.time() - t0:.2f} s)&#34;)

    res[&#39;n_iter&#39;] = sum(n_iter_history)

    if additional_keys:
        res[&#39;best_sample&#39;] += res[&#39;best_sample&#39;]

    self.unraveled_graph = best_ogs.unraveled_graph
    self.fusion_network = best_ogs.fusion_network
    self.data = best_ogs.data

    return res</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.unravel_bcss"><code class="name flex">
<span>def <span class="ident">unravel_bcss</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unravel bipartitely-complete subgraphs (BCSs) of the graph.</p>
<p>The unraveled graph is saved in <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code> as
<a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs and plot the intermediate graphs during
the unraveling process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bcss</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>2-tuple</code> of <code>list</code> of <code>str</code></dt>
<dd>
<p>Information on the unraveled BCSs.</p>
<p><code>bcss[i][j][k][l]</code> (<code>k</code>=0 or 1) is the name of the <code>l</code>-th vertex in
the <code>k</code>-th part of the <code>j</code>-th BCS obtained by the <code>i</code>-th cycle of
finding non-overlapping BCSs.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unravel_bcss(self, verbose=False):
    &#34;&#34;&#34;
    Unravel bipartitely-complete subgraphs (BCSs) of the graph.

    The unraveled graph is saved in `GraphState.unraveled_graph` as
    [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

    Parameters
    ----------
    verbose : bool (default: False)
        Whether to print logs and plot the intermediate graphs during
        the unraveling process.

    Returns
    -------
    bcss : list of list of 2-tuple of list of str
        Information on the unraveled BCSs.

        `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
        the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
        finding non-overlapping BCSs.
    &#34;&#34;&#34;

    if self.unraveled_graph is None:
        self.unraveled_graph = self.graph.copy()

    graph = self.unraveled_graph

    vs_attrs = graph.vs.attributes()
    if &#39;ext_fusion&#39; not in vs_attrs:
        graph.vs[&#39;ext_fusion&#39;] = None
    if &#39;clifford&#39; not in vs_attrs:
        graph.vs[&#39;clifford&#39;] = None

    unraveled_bcss = []

    new_vertex_name = graph.vcount()

    while True:
        # Repeat until there are no bipartitely-complete subgraphs
        bcs_exist = False
        while True:
            bcss = find_nonoverlapping_bcss(graph, get_name=True)
            if bcss:
                bcs_exist = True
            else:
                break

            unraveled_bcss.append(bcss)
            eids_to_remove = []
            for part1, part2 in bcss:
                if verbose:
                    graph.delete_edges(eids_to_remove)
                    eids_to_remove.clear()
                    print(&#39;bcs to unravel =&#39;, part1, &#39;&amp;&#39;, part2)
                    vertex_color = []
                    for v in graph.vs:
                        if v[&#39;name&#39;] in part1:
                            vertex_color.append(&#39;orange&#39;)
                        elif v[&#39;name&#39;] in part2:
                            vertex_color.append(&#39;blue&#39;)
                        else:
                            vertex_color.append(&#39;white&#39;)
                    self.plot_graph(unraveled=True,
                                    vertex_color=vertex_color)
                    plt.show()

                eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                       vname1, vname2 in
                                       itertools.product(part1, part2)])

                vname1 = str(new_vertex_name)
                vname2 = str(new_vertex_name + 1)
                new_v1 = graph.add_vertex(name=vname1,
                                          ext_fusion=vname2,
                                          clifford=None)
                new_v2 = graph.add_vertex(name=vname2,
                                          ext_fusion=vname1,
                                          clifford=None)
                new_vertex_name += 2

                graph.add_edges(itertools.product([new_v1], part1))
                graph.add_edges(itertools.product([new_v2], part2))

            graph.delete_edges(eids_to_remove)

        if not bcs_exist:
            break

    return unraveled_bcss</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.unravel_cliques"><code class="name flex">
<span>def <span class="ident">unravel_cliques</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unravel cliques of the graph.</p>
<p>The unraveled graph is saved in <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code> as
<a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs and plot the intermediate graphs during
the unraveling process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cliques</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>set</code> of <code>str</code></dt>
<dd>
<p>Information on the unraveled cliques.</p>
<p><code>cliques[i][j]</code> is the set of the names of the vertices in the
<code>j</code>-th clique obtained by the <code>i</code>-th cycle of finding
non-overlapping cliques.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unravel_cliques(self, verbose=False):
    &#34;&#34;&#34;
    Unravel cliques of the graph.

    The unraveled graph is saved in `GraphState.unraveled_graph` as
    [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

    Parameters
    ----------
    verbose : bool (default: False)
        Whether to print logs and plot the intermediate graphs during
        the unraveling process.

    Returns
    -------
    cliques : list of list of set of str
        Information on the unraveled cliques.

        `cliques[i][j]` is the set of the names of the vertices in the
        `j`-th clique obtained by the `i`-th cycle of finding
        non-overlapping cliques.
    &#34;&#34;&#34;
    if self.unraveled_graph is None:
        self.unraveled_graph = self.graph.copy()

    graph = self.unraveled_graph

    vs_attrs = graph.vs.attributes()
    if &#39;ext_fusion&#39; not in vs_attrs:
        graph.vs[&#39;ext_fusion&#39;] = None
    if &#39;clifford&#39; not in vs_attrs:
        graph.vs[&#39;clifford&#39;] = None

    unraveled_cliques = []

    def apply_clifford(v, clifford):
        org_clifford = v[&#39;clifford&#39;]
        if org_clifford is None:
            new_clifford = clifford
        else:
            new_clifford = &#39;-&#39;.join([clifford, org_clifford])
        v[&#39;clifford&#39;] = new_clifford

    while True:
        cliques = find_nonoverlapping_cliques(graph, get_name=True)

        if not cliques:
            break

        unraveled_cliques.append(cliques)

        for clique in cliques:
            if verbose:
                print(&#39;clique to unravel =&#39;, clique)
                vertex_color = [&#39;orange&#39; if vname in clique else &#39;white&#39;
                                for vname in graph.vs[&#39;name&#39;]]
                self.plot_graph(unraveled=True, vertex_color=vertex_color)
                plt.show()
            clique = list(clique)
            clique_size = len(clique)

            # Choose a vertex to apply LC
            degrees = graph.degree(clique)
            min_degree = min(degrees)
            if min_degree == clique_size - 1:
                # There exists a vertex in the clique that doesn&#39;t have
                # outer edges
                vname_LC = [vname for vname, deg in zip(clique, degrees) if
                            deg == min_degree]
                need_to_separate = False
            else:
                vname_LC = clique
                need_to_separate = True

            if len(vname_LC) &gt; 1:
                vname_LC = np.random.choice(vname_LC)
            else:
                vname_LC = vname_LC[0]
            v_LC = graph.vs.find(name=vname_LC)

            # Separate the edges (E) incident to v_LC outside the clique
            # from v_LC
            eids_to_delete = []
            if need_to_separate:
                # Vertex connected with E
                new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                          clifford=v_LC[&#39;clifford&#39;],
                                          ext_fusion=v_LC[&#39;ext_fusion&#39;])

                # Vertex having an external fusion with v_LC
                new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                          clifford=None,
                                          ext_fusion=v_LC[&#39;name&#39;])

                graph.add_edge(new_v1, new_v2)

                ngh_vids = graph.neighbors(vname_LC)
                for ngh_vid in ngh_vids:
                    if graph.vs[ngh_vid][&#39;name&#39;] not in clique:
                        graph.add_edge(ngh_vid, new_v1)
                        eids_to_delete.append(graph.get_eid(vname_LC,
                                                            ngh_vid))

                vname_org_ext_fusion = v_LC[&#39;ext_fusion&#39;]
                if vname_org_ext_fusion is not None:
                    v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                    v_org_ext_fusion[&#39;ext_fusion&#39;] = new_v1[&#39;name&#39;]

                v_LC[&#39;ext_fusion&#39;] = new_v2[&#39;name&#39;]

                v_LC[&#39;name&#39;], new_v1[&#39;name&#39;] = new_v1[&#39;name&#39;], vname_LC

            # Apply LC
            adj_vnames = set(clique) - {vname_LC}
            apply_clifford(v_LC, &#39;RX&#39;)
            for adj_vname in adj_vnames:
                adj_v = graph.vs.find(name=adj_vname)
                apply_clifford(adj_v, &#39;RZ&#39;)

            new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                  vname1, vname2 in
                                  itertools.combinations(adj_vnames, r=2)]
            eids_to_delete.extend(new_eids_to_delete)
            graph.delete_edges(eids_to_delete)

    return unraveled_cliques</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.unravel_graph"><code class="name flex">
<span>def <span class="ident">unravel_graph</span></span>(<span>self, unravel_bcs_first='random', plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.</p>
<p>The unraveled graph is saved in <code>self.unraveled_graph</code> as
<a href="https://python.igraph.org/en/stable/api/igraph.Graph.html"><code>igraph.Graph</code></a>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unravel_bcs_first</code></strong> :&ensp;<code>one</code> of <code>[True, False, 'random'] (default: 'random')</code></dt>
<dd>
<ul>
<li><code>True</code>: BCSs are unraveled first, then clqiues are
unraveled.</li>
<li><code>False</code>: cliques are unraveled first, then BCSs are
unraveled.<br></li>
<li><code>'random'</code>: the order is randomly chosen.</li>
</ul>
</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to plot the unraveled graph after unraveling.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs and plot the intermediate graphs during
the unraveling process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bcss</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>2-tuple</code> of <code>list</code> of <code>str</code></dt>
<dd>
<p>Information on the unraveled BCSs.</p>
<p><code>bcss[i][j][k][l]</code> (<code>k</code>=0 or 1) is the name of the <code>l</code>-th vertex in
the <code>k</code>-th part of the <code>j</code>-th BCS obtained by the <code>i</code>-th cycle of
finding non-overlapping BCSs.</p>
</dd>
<dt><strong><code>cliques</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>set</code> of <code>str</code></dt>
<dd>
<p>Information on the unraveled cliques.</p>
<p><code>cliques[i][j]</code> is the set of the names of the vertices in the
<code>j</code>-th clique obtained by the <code>i</code>-th cycle of finding
non-overlapping cliques.</p>
</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unravel_graph(self,
                  unravel_bcs_first=&#39;random&#39;,
                  plot=False,
                  verbose=False):
    &#34;&#34;&#34;
    Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

    The unraveled graph is saved in `self.unraveled_graph` as
    [`igraph.Graph`](https://python.igraph.org/en/stable/api/igraph.Graph.html).

    Parameters
    ----------
    unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
        - `True`: BCSs are unraveled first, then clqiues are
        unraveled.
        - `False`: cliques are unraveled first, then BCSs are
        unraveled.&lt;br&gt;
        - `&#39;random&#39;`: the order is randomly chosen.

    plot : bool (default: False)
        Whether to plot the unraveled graph after unraveling.

    verbose : bool (default: False)
        Whether to print logs and plot the intermediate graphs during
        the unraveling process.

    Returns
    -------
    bcss : list of list of 2-tuple of list of str
        Information on the unraveled BCSs.

        `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
        the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
        finding non-overlapping BCSs.

    cliques : list of list of set of str
        Information on the unraveled cliques.

        `cliques[i][j]` is the set of the names of the vertices in the
        `j`-th clique obtained by the `i`-th cycle of finding
        non-overlapping cliques.
    &#34;&#34;&#34;

    if unravel_bcs_first == &#39;random&#39;:
        unravel_bcs_first = np.random.choice([True, False])

    if unravel_bcs_first:
        bcss = self.unravel_bcss(verbose=verbose)
        cliques = self.unravel_cliques(verbose=verbose)
    else:
        cliques = self.unravel_cliques(verbose=verbose)
        bcss = self.unravel_bcss(verbose=verbose)

    if plot or verbose:
        if verbose:
            print(&#39;[Final]&#39;)
        self.plot_graph(unraveled=True)
        plt.show()

    self.data[&#39;unravel&#39;] = True
    self.data[&#39;unravel_bcs_first&#39;] = unravel_bcs_first

    return bcss, cliques</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="optgraphstate.graph_tools" href="graph_tools.html">optgraphstate.graph_tools</a></code></li>
<li><code><a title="optgraphstate.utils" href="utils.html">optgraphstate.utils</a></code></li>
<li><code><a title="optgraphstate.visualization" href="visualization.html">optgraphstate.visualization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="optgraphstate.GraphState" href="#optgraphstate.GraphState">GraphState</a></code></h4>
<ul class="">
<li><code><a title="optgraphstate.GraphState.build_fusion_network" href="#optgraphstate.GraphState.build_fusion_network">build_fusion_network</a></code></li>
<li><code><a title="optgraphstate.GraphState.calculate_overhead" href="#optgraphstate.GraphState.calculate_overhead">calculate_overhead</a></code></li>
<li><code><a title="optgraphstate.GraphState.copy" href="#optgraphstate.GraphState.copy">copy</a></code></li>
<li><code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">data</a></code></li>
<li><code><a title="optgraphstate.GraphState.fusion_network" href="#optgraphstate.GraphState.fusion_network">fusion_network</a></code></li>
<li><code><a title="optgraphstate.GraphState.get_instructions" href="#optgraphstate.GraphState.get_instructions">get_instructions</a></code></li>
<li><code><a title="optgraphstate.GraphState.get_link_clifford" href="#optgraphstate.GraphState.get_link_clifford">get_link_clifford</a></code></li>
<li><code><a title="optgraphstate.GraphState.get_vertex_clifford" href="#optgraphstate.GraphState.get_vertex_clifford">get_vertex_clifford</a></code></li>
<li><code><a title="optgraphstate.GraphState.graph" href="#optgraphstate.GraphState.graph">graph</a></code></li>
<li><code><a title="optgraphstate.GraphState.initialize" href="#optgraphstate.GraphState.initialize">initialize</a></code></li>
<li><code><a title="optgraphstate.GraphState.plot_fusion_network" href="#optgraphstate.GraphState.plot_fusion_network">plot_fusion_network</a></code></li>
<li><code><a title="optgraphstate.GraphState.plot_graph" href="#optgraphstate.GraphState.plot_graph">plot_graph</a></code></li>
<li><code><a title="optgraphstate.GraphState.simulate" href="#optgraphstate.GraphState.simulate">simulate</a></code></li>
<li><code><a title="optgraphstate.GraphState.simulate_adaptive" href="#optgraphstate.GraphState.simulate_adaptive">simulate_adaptive</a></code></li>
<li><code><a title="optgraphstate.GraphState.unravel_bcss" href="#optgraphstate.GraphState.unravel_bcss">unravel_bcss</a></code></li>
<li><code><a title="optgraphstate.GraphState.unravel_cliques" href="#optgraphstate.GraphState.unravel_cliques">unravel_cliques</a></code></li>
<li><code><a title="optgraphstate.GraphState.unravel_graph" href="#optgraphstate.GraphState.unravel_graph">unravel_graph</a></code></li>
<li><code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">unraveled_graph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>