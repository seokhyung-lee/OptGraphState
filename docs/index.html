<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>optgraphstate API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>optgraphstate</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import time
import os
import sys

import networkx as nx

from .graph_tools import *
from .visualization import *

try:
    import parmap
except ModuleNotFoundError:
    pass


def _max_seed():
    return 2**32


class GraphState:
    graph: ig.Graph  #: Graph of the graph state to investigate.
    graph_info: set  #: Information of the graph in `GraphState.graph`. It is not empty only when the graph is initialized by using the parameters `shape` and `prms`.
    unraveled_graph: ig.Graph  #: Unraveled graph generated by unraveling the original graph (in `GraphState.graph`). It is `None` before the unraveled graph is created.
    fusion_network: ig.Graph  #: Fuson network constructed from the unraveled graph (in `GraphState.unraveled_graph`) or the original graph (in `GraphState.graph`). It is `None` before the fusion network is created.
    unraveled_bcss: set  #: Unraveled bipartitely-complete subgraphs (BCSs). It is empty before unraveling the graph.
    unraveled_cliques: set  #: Unraveled cliques. It is empty before unraveling the graph.
    data: dict  #: Any data obtained during unraveling the graph, constructing the fusion network, and calculating the resource overhead.

    def __init__(self,
                 graph=None,
                 edges=None,
                 shape=None,
                 prms=None,
                 cliffords=None,
                 unraveled_graph=None,
                 fusion_network=None):
        &#34;&#34;&#34;
        Class for calculating and optimizing the resource overhead of the
        fusion-based generation of a graph state.

        The graph of the concerned graph state can be given by the following
        three ways:

        1. Given explicitly by `igraph.Graph` or `networkx.Graph`.
        2. Given by a list of edges.
        3. Chosen among predefined graphs.

        Parameters
        ----------
        graph : None or igraph.Graph or networkx.Graph (default: None)
            Graph of the concerned graph.&lt;br&gt;
            If it is given, `edges`, `shape`, and `prms` are ignored. If it
            is `networkx.Graph`, it is internally converted to `igraph.Graph`.

        edges : None or list of 2-tuple of int (default: None)
            List of edges that form the concerned graph.&lt;br&gt;
            Each integer in the tuples indicates a vertex label. If it is
            given and `graph` is `None`, `shape` and `prms` are ignored.

        shape : None or str (default: None)
            Shape of the concerned graph chosen among predefined graphs.&lt;br&gt;
            One of `[None, &#39;random&#39;, &#39;complete&#39;, &#39;star&#39;, &#39;linear&#39;, &#39;cycle&#39;,
            &#39;lattice&#39;, &#39;tree&#39;, &#39;rhg&#39;, &#39;repeater&#39;, &#39;parity_encoding&#39;, &#39;ptqc&#39;]`.

            - `shape=&#39;random&#39;` : Random graph for fixed numbers of vertices
            and edges, sampled by the Erd√∂s-Renyi model.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
                - `prms[1]` &lt;`int`&gt; : Number of edges.
                - [Optional] `prms[2]` &lt;`None` or `int`&gt; : Random seed. If
                `None`, the current system time is used as the seed. If not
                given, the random number generator is not initialized.
            - `shape=&#39;complete&#39;`, `&#39;star&#39;`, `&#39;linear&#39;`, or `&#39;cycle&#39;` :
            Complete, star, linear, or cycle graph, respectively.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
            - `shape=&#39;lattice&#39;` : Lattice graph.
                - `prms` &lt;`tuple` of `int`&gt; : Numbers of repeated vertices
                along the axes. The dimension of the lattice is
                automatically set as `len(prms)`.
            - `shape=&#39;tree&#39;` : Tree graph where all branches in each
            generation have an equal number of children.
                - `prms[0]` &lt;`int`&gt; : Degree of the root vertex.
                - `prms[i]` (&lt;`int`&gt;, i &gt;= 1) : Number of the children of each
                `i`th-generation branch.
            - `shape=&#39;rhg&#39;` : Raussendorf-Harrington-Goyal lattice with primal
            boundaries only.
                - `prms[0]`, `prms[1]`, `prms[2]` &lt;`int`&gt; : Size of the lattice
                along the three axes in the unit of a cell.
            - `shape=&#39;repeater&#39;` : Repeater graph with 4m vertices.
                - `prms[0]` &lt;`int`&gt; : Parameter m.
            - `shape=&#39;parity_encoding&#39;` : (n, m) parity-encoded graph.
                - `prms[0]` &lt;`igraph.Graph`&gt; : Logical-level graph. Can be
                generated with python-igraph library directly or from the
                function `get_graph_from_edges()` or `get_sample_graph`.
                - `prms[1]`, `prms[2]` &lt;`int`&gt; : Parameters n and m of the
                parity encoding.
            - `shape=&#39;ptqc&#39;` : Microcluster for parity-encoding-based
            topological quantum computing protocol.
                - `prms[0]`, `prms[1]` &lt;`int`&gt; : Parameter n and m of the
                parity encoding.
                - `prms[2]` &lt;`bool`&gt; : Whether the H-configuration is
                HIC (`True`) or HIS (`False`).
                - `prms[3]` &lt;`bool`&gt; : Whether the microcluster is
                central (`True`) or side (`False`) one.

        prms : None or tuple or int (default: None)
            Parameters for a predefined graph.&lt;br&gt;
            See the description for parameter `shape`. If only one parameter
            is required, it can be given as a number, not a tuple.

        cliffords : None or list of str (default: None)
            Local clifford operations applied on the qubits of the graph
            state.&lt;br&gt;
            If it is `None`, no Clifford operations are applied on the qubits.&lt;br&gt;
            If it is a `list` of `str`, its length should be equal to the
            number of vertices in the graph. Its i-th element indicates the
            Clifford operation applied on the i-th qubit. For example,
            if it is `&#39;H&#39;`, it means that a Hadamard gate is applied on the
            qubit. If it is `&#39;H-S-Z&#39;`, it means that Hadamard, phase,
            and Z gates are applied in order.

        unraveled_graph : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven unraveled graph.&lt;br&gt;
            The code does not check the validity of the given unraveled graph.
            If it is `networkx.Graph`, it is internally converted to
            `igraph.Graph`.

        fusion_network : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven fusion network.&lt;br&gt;
            The code does not check the validity of the given fusion network.
            If it is `networkx.Graph`, it is internally converted to
            `igraph.Graph`.
        &#34;&#34;&#34;

        def convert_type(g, varname):
            if g is None:
                return None
            elif isinstance(g, ig.Graph):
                return g
            elif isinstance(g, nx.Graph):
                return ig.Graph.from_networkx(g)
            else:
                raise TypeError(f&#39;Parameter {varname} should be igraph.Graph &#39;
                                f&#39;or networkx.Graph.&#39;)

        if graph is not None:
            self.graph = convert_type(graph, &#39;graph&#39;)
            self.graph_info = None

        elif edges is not None:
            self.graph = ig.Graph(edges=edges)
            self.graph_info = None

        elif shape is not None:
            try:
                prms[0]
            except TypeError:
                prms = (prms,)

            self.graph, self.graph_info = get_sample_graph(shape, *prms)

        else:
            raise ValueError(
                &#34;At least one of graph, edges, and shape should be given.&#34;)

        if self.graph_info is None:
            self.graph_info = {
                &#39;num_vertices&#39;: self.graph.vcount(),
                &#39;num_edges&#39;: self.graph.ecount()}

        self.graph.vs[&#39;name&#39;] = [str(vid) for vid in
                                 range(self.graph.vcount())]

        if cliffords is not None and edges is None:
            self.graph.vs[&#39;clifford&#39;] = cliffords

        self.unraveled_graph = convert_type(unraveled_graph, &#39;unraveled_graph&#39;)
        self.unraveled_bcss = set()
        self.unraveled_cliques = set()

        self.fusion_network = convert_type(fusion_network, &#39;fusion_network&#39;)

        self.data = {}

    def initialize(self):
        &#34;&#34;&#34;
        Initialize the created unraveled graph and fusion network and the
        calculation data.
        &#34;&#34;&#34;
        self.unraveled_graph = None
        self.fusion_network = None
        self.unraveled_bcss = set()
        self.unraveled_cliques = set()
        self.data = {}

    def unravel_graph(self,
                      unravel_bcs_first=&#39;random&#39;,
                      plot=False,
                      verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

        The unraveled graph is saved in `self.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are
            unraveled.
            - `False`: cliques are unraveled first, then BCSs are
            unraveled.&lt;br&gt;
            - `&#39;random&#39;`: the order is randomly chosen.

        plot : bool (default: False)
            Whether to plot the unraveled graph after unraveling.

        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Data on unraveled BCSs, which is identical with
            `GraphState.unraveled_bcss`.&lt;br&gt;
            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.

        cliques : list of list of set of str
            Data on unraveled cliques, which is identical with
            `GraphState.unraveled_cliques`.&lt;br&gt;
            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        &#34;&#34;&#34;

        if unravel_bcs_first == &#39;random&#39;:
            unravel_bcs_first = np.random.choice([True, False])

        if unravel_bcs_first:
            bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)
            cliques = self.unravel_cliques(verbose=verbose)
        else:
            cliques = self.unravel_cliques(verbose=verbose)
            bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)

        if plot or verbose:
            if verbose:
                print(&#39;[Final]&#39;)
            self.plot_graph(unraveled=True)
            plt.show()

        self.data[&#39;unravel&#39;] = True
        self.data[&#39;unravel_bcs_first&#39;] = unravel_bcs_first

        return self.unraveled_graph, bcss, cliques

    def unravel_bipartitely_complete_subgraphs(self, verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Data on unraveled BCSs.&lt;br&gt;
            See the description of `GraphState.unravel_graph()`.
        &#34;&#34;&#34;

        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_bcss = []

        new_vertex_name = graph.vcount()

        while True:
            # Repeat until there are no bipartitely-complete subgraphs
            bcs_exist = False
            while True:
                bcss = find_nonoverlapping_bcs(graph, get_name=True)
                if bcss:
                    bcs_exist = True
                else:
                    break

                unraveled_bcss.append(bcss)
                eids_to_remove = []
                for part1, part2 in bcss:
                    if verbose:
                        graph.delete_edges(eids_to_remove)
                        eids_to_remove.clear()
                        print(&#39;bcs to unravel =&#39;, part1, &#39;&amp;&#39;, part2)
                        vertex_color = []
                        for v in graph.vs:
                            if v[&#39;name&#39;] in part1:
                                vertex_color.append(&#39;orange&#39;)
                            elif v[&#39;name&#39;] in part2:
                                vertex_color.append(&#39;blue&#39;)
                            else:
                                vertex_color.append(&#39;white&#39;)
                        self.plot_graph(unraveled=True,
                                        vertex_color=vertex_color)
                        plt.show()

                    eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                           vname1, vname2 in
                                           itertools.product(part1, part2)])

                    vname1 = str(new_vertex_name)
                    vname2 = str(new_vertex_name + 1)
                    new_v1 = graph.add_vertex(name=vname1,
                                              ext_fusion=vname2,
                                              clifford=None)
                    new_v2 = graph.add_vertex(name=vname2,
                                              ext_fusion=vname1,
                                              clifford=None)
                    new_vertex_name += 2

                    graph.add_edges(itertools.product([new_v1], part1))
                    graph.add_edges(itertools.product([new_v2], part2))

                graph.delete_edges(eids_to_remove)

            if not bcs_exist:
                break

        self.unraveled_bcss = unraveled_bcss

        return unraveled_bcss

    def unravel_cliques(self, verbose=False):
        &#34;&#34;&#34;
        Unravel cliques of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        cliques : list of list of set of str
            Data on unraveled cliques.&lt;br&gt;
            See the description of `GraphState.unravel_graph()`.
        &#34;&#34;&#34;
        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_cliques = []

        def apply_clifford(v, clifford):
            org_clifford = v[&#39;clifford&#39;]
            if org_clifford is None:
                new_clifford = clifford
            else:
                new_clifford = &#39;-&#39;.join([clifford, org_clifford])
            v[&#39;clifford&#39;] = new_clifford

        while True:
            cliques = find_nonoverlapping_cliques(graph, get_name=True)

            if not cliques:
                break

            unraveled_cliques.append(cliques)

            for clique in cliques:
                if verbose:
                    print(&#39;clique to unravel =&#39;, clique)
                    vertex_color = [&#39;orange&#39; if vname in clique else &#39;white&#39;
                                    for vname in graph.vs[&#39;name&#39;]]
                    self.plot_graph(unraveled=True, vertex_color=vertex_color)
                    plt.show()
                clique = list(clique)
                clique_size = len(clique)

                # Choose a vertex to apply LC
                degrees = graph.degree(clique)
                min_degree = min(degrees)
                if min_degree == clique_size - 1:
                    # There exists a vertex in the clique that doesn&#39;t have
                    # outer edges
                    vname_LC = [vname for vname, deg in zip(clique, degrees) if
                                deg == min_degree]
                    need_to_separate = False
                else:
                    vname_LC = clique
                    need_to_separate = True

                if len(vname_LC) &gt; 1:
                    vname_LC = np.random.choice(vname_LC)
                else:
                    vname_LC = vname_LC[0]
                v_LC = graph.vs.find(name=vname_LC)

                # Separate the edges (E) incident to v_LC outside the clique
                # from v_LC
                eids_to_delete = []
                if need_to_separate:
                    # Vertex connected with E
                    new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=v_LC[&#39;clifford&#39;],
                                              ext_fusion=v_LC[&#39;ext_fusion&#39;])

                    # Vertex having an external fusion with v_LC
                    new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=None,
                                              ext_fusion=v_LC[&#39;name&#39;])

                    graph.add_edge(new_v1, new_v2)

                    ngh_vids = graph.neighbors(vname_LC)
                    for ngh_vid in ngh_vids:
                        if graph.vs[ngh_vid][&#39;name&#39;] not in clique:
                            graph.add_edge(ngh_vid, new_v1)
                            eids_to_delete.append(graph.get_eid(vname_LC,
                                                                ngh_vid))

                    vname_org_ext_fusion = v_LC[&#39;ext_fusion&#39;]
                    if vname_org_ext_fusion is not None:
                        v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                        v_org_ext_fusion[&#39;ext_fusion&#39;] = new_v1[&#39;name&#39;]

                    v_LC[&#39;ext_fusion&#39;] = new_v2[&#39;name&#39;]

                # Apply LC
                adj_vnames = set(clique) - {vname_LC}
                apply_clifford(v_LC, &#39;R_X&#39;)
                for adj_vname in adj_vnames:
                    adj_v = graph.vs.find(name=adj_vname)
                    apply_clifford(adj_v, &#39;R_Z&#39;)

                new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                      vname1, vname2 in
                                      itertools.combinations(adj_vnames, r=2)]
                eids_to_delete.extend(new_eids_to_delete)
                graph.delete_edges(eids_to_delete)

        self.unraveled_cliques = unraveled_cliques

        return unraveled_cliques

    def build_fusion_network(self,
                             use_unraveled_graph=True,
                             plot=False,
                             verbose=False):
        &#34;&#34;&#34;
        Build a fusion network from the graph.

        The constructed fusion network is saved in `GraphState.fusion_network` as
        `igraph.Graph`.

        Parameters
        ----------
        use_unraveled_graph : bool (default: True)
            Whether to use the unraveled graph (in `GraphState.unraveled_graph`) or
            the original graph (in `GraphState.graph`) for building a fusion network.

        plot : bool (default: False)
            Whether to plot the fusion network after building it.

        verbose : bool (default: False)
            Whether to print logs.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if use_unraveled_graph else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled qubit graph created.&#34;)

        # Fusion network
        network = ig.Graph()
        self.fusion_network = network
        nodes_corr = {}

        # Links inside star graphs
        for v in graph.vs:
            num_internal_nodes = v.degree() - 1
            vname_xrot = v[&#39;name&#39;]
            if num_internal_nodes &gt;= 1:

                # Add nodes
                nid_init = network.vcount()
                seed = np.random.randint(0, num_internal_nodes)
                node_names = [vname_xrot if i == 0 else f&#39;{vname_xrot}-{i}&#39; for
                              i in itertools.chain(range(seed, -1, -1),
                                                   range(seed + 1,
                                                         num_internal_nodes))]
                attr = {
                    &#39;name&#39;: node_names,
                    &#39;seed&#39;: [True if i == seed else False for i in
                             range(num_internal_nodes)],
                    &#39;clifford_root&#39;: None,
                    # Clifford gate applied on the root qubit
                    &#39;clifford_leaves&#39;: None
                    # Clifford gate applied on the leaf qubits
                }
                network.add_vertices(num_internal_nodes, attributes=attr)
                nodes_corr[vname_xrot] = network.vs[
                                         nid_init:nid_init + num_internal_nodes]

                if num_internal_nodes &gt;= 2:
                    # Connect internal links
                    links = [(nid, nid + 1) for nid in range(nid_init,
                                                             nid_init + num_internal_nodes - 1)]
                    attr = {  # One of RR, RL, and LL, which respectively means
                        # that a fusion is performed on two roots,
                        # one root and one leaf, and two leaves of GHZ-3
                        # states.
                        &#39;kind&#39;: &#34;RL&#34;,  # Root node name, if kind == &#39;RL&#39;
                        &#39;root_node&#39;: [
                            node_names[i + 1] if i &lt; seed else node_names[i]
                            for i in range(num_internal_nodes - 1)]}
                    network.add_edges(links, attributes=attr)

        # Links between star graphs
        for e in graph.es:
            vs = [e.source_vertex, e.target_vertex]
            deg_vs = graph.degree(vs)

            if deg_vs[0] &gt; 1 and deg_vs[1] &gt; 1:
                nodes_to_connect = []
                for v in vs:
                    vname = v[&#39;name&#39;]
                    nodes = nodes_corr[
                        vname].select(lambda node: node.degree() &lt; (
                        2 if node[&#39;seed&#39;] else 3))
                    nodes_to_connect.append(np.random.choice(nodes))
                network.add_edge(*nodes_to_connect,
                                 kind=&#39;LL&#39;,
                                 root_node=None, )

        if verbose:
            print(&#34;Fusion network of the unraveled graph:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Set of seed node names where root vertices are connected by
        # external fusions.
        root_connected = set()
        is_node_not_full = lambda node: node.degree() &lt; (
            2 if node[&#39;seed&#39;] and (node[&#39;name&#39;] not in root_connected) else 3)

        def get_nodes_containing_vertex(vname):
            try:
                node = nodes_corr[vname].find(name=vname)
                root = True
            except KeyError:
                root_name = graph.vs[graph.neighbors(vname)[0]][&#39;name&#39;]
                nodes = nodes_corr[root_name].select(is_node_not_full)
                node = np.random.choice(nodes)
                root = False

            return node, root

        # Clifford operations
        vs_attrs = graph.vs.attributes()
        if &#39;clifford&#39; in vs_attrs:
            for v_cl in graph.vs.select(clifford_ne=None):
                vname = v_cl[&#39;name&#39;]
                node, root = get_nodes_containing_vertex(vname)
                cl = v_cl[&#39;clifford&#39;]

                if root:
                    node[&#39;clifford_root&#39;] = cl

                else:
                    key = v_cl[&#39;ext_fusion&#39;]
                    if key is None:
                        key = f&#39;final_{v_cl[&#34;name&#34;]}&#39;

                    clifford_leaves = node[&#39;clifford_leaves&#39;]
                    try:
                        clifford_leaves[key] = cl
                    except TypeError:
                        node[&#39;clifford_leaves&#39;] = {key: cl}

        if verbose:
            print(&#34;Apply Clifford operations:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Links by external fusions
        if &#39;ext_fusion&#39; in vs_attrs:
            done = set()
            for v1 in graph.vs.select(ext_fusion_ne=None):

                vname1 = v1[&#39;name&#39;]
                if vname1 in done:
                    continue
                vname2 = v1[&#39;ext_fusion&#39;]
                done.add(vname2)

                node1, root1 = get_nodes_containing_vertex(vname1)
                node2, root2 = get_nodes_containing_vertex(vname2)
                if root1 and root2:
                    kind = &#39;RR&#39;
                    root_node = None
                    root_connected.add(node1[&#39;name&#39;])
                    root_connected.add(node2[&#39;name&#39;])
                elif not root1 and not root2:
                    kind = &#39;LL&#39;
                    root_node = None
                else:
                    kind = &#39;RL&#39;
                    root_node = node1[&#39;name&#39;] if root1 else node2[&#39;name&#39;]
                    root_connected.add(root_node)
                network.add_edge(node1, node2, kind=kind, root_node=root_node)

        network.es[&#39;name&#39;] = [str(eid) for eid in range(network.ecount())]

        self.fusion_network = network

        if plot:
            print(&#34;Final:&#34;)
            self.plot_fusion_network()
            plt.show()

    def _contract_edge(self, fusion_network, ename_to_merge):
        ename_to_merge = str(ename_to_merge)

        e_to_merge = fusion_network.es.find(name=ename_to_merge)
        v_merged, v_removed = e_to_merge.source_vertex, e_to_merge.target_vertex
        enames_updated_weight = []

        if v_merged.degree() &lt; v_removed.degree():
            v_merged, v_removed = v_removed, v_merged

        vname_merged = v_merged[&#39;name&#39;]
        vname_removed = v_removed[&#39;name&#39;]

        v_merged[&#39;weight&#39;] = e_to_merge[&#39;weight&#39;]
        v_merged[&#39;step&#39;] = max(v_merged[&#39;step&#39;], v_removed[&#39;step&#39;]) + 1

        assert vname_merged != vname_removed

        eids_to_delete = list(set(fusion_network.incident(v_removed)))
        v_removed[&#39;on&#39;] = False

        for eid_connected in eids_to_delete:
            e_connected = fusion_network.es[eid_connected]
            ename_connected = e_connected[&#39;name&#39;]
            if ename_connected != ename_to_merge:
                enames_updated_weight.append(ename_connected)
                vs_ngh = e_connected.source_vertex, e_connected.target_vertex
                new_edge = [
                    v_merged if v_ngh[&#39;name&#39;] == vname_removed else v_ngh for
                    v_ngh in vs_ngh]
                if new_edge[0] == new_edge[1]:  # If a loop is formed
                    v_vrt = fusion_network.add_vertex(name=f&#39;vrt_{fusion_network.vcount()}&#39;,
                                                      weight=0,
                                                      step=0)
                    new_edge = [v_merged, v_vrt]

                fusion_network.add_edge(*new_edge,
                                        name=ename_connected,
                                        weight=None, )

        fusion_network.delete_edges(eids_to_delete)

        p_succ = fusion_network[&#39;p_succ&#39;]
        for eid_connected in list(set(fusion_network.incident(v_merged))):
            e_connected = fusion_network.es[eid_connected]
            v_ngh1, v_ngh2 = e_connected.source_vertex, e_connected.target_vertex

            assert v_ngh1 != v_ngh2
            new_weight = (v_ngh1[&#39;weight&#39;] + v_ngh2[&#39;weight&#39;]) / p_succ
            e_connected[&#39;weight&#39;] = new_weight

        self.fusion_network.es.find(name=ename_to_merge)[&#39;step&#39;] = v_merged[
            &#39;step&#39;]

        return enames_updated_weight

    def calculate_overhead(self,
                           p_succ=0.5,
                           strategy=&#39;weight_and_matching&#39;,
                           fusion_order=None,
                           get_fusion_order=False, ):
        &#34;&#34;&#34;
        Calculate the resource overhead from the fusion network.

        The resulting data is saved in `GraphState.data`.

        Parameters
        ----------
        p_succ : float (default: 0.5)
            Success probability of a fusion.

        strategy: str, one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: &#39;weight_and_matching&#39;)
            Strategy for determining the edge to contract in each step.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        fusion_order : None or list of {int or str} (default: None)
            Fusion order given explicitly as vertex names.&lt;br&gt;
            If it is not `None`, parameter `strategy` is ignored.

        get_fusion_order : bool (default: False)
            Whether to include the determined fusion order in the returned
            data.

        Returns
        -------
        data : dict
            Outcomes of the calculation, which is a shallow copy of
            `GraphState.data`.&lt;br&gt;
            The calculated overhead and number of steps can be obtained from
            `data[&#39;overhead&#39;]` and `data[&#39;step&#39;]`, respectively.
        &#34;&#34;&#34;

        if self.fusion_network is None:
            raise ValueError(&#34;No fusion network created&#34;)

        # Trivial cases
        node_num = self.fusion_network.vcount()
        if node_num == 0:
            self.data[&#39;overhead&#39;] = 0
            self.data[&#39;step&#39;] = 0
            return self.data
        elif node_num == 1:
            self.data[&#39;overhead&#39;] = 1
            self.data[&#39;step&#39;] = 0
            return self.data

        if fusion_order is None:
            fusion_order = []
            is_fusion_order_given = False
        else:
            is_fusion_order_given = True

        self.fusion_network.es[&#39;step&#39;] = None

        # Initialize intermediate fusion network
        network = self.fusion_network.copy()
        network[&#39;p_succ&#39;] = p_succ
        network.vs[&#39;weight&#39;] = 1
        network.vs[&#39;step&#39;] = 0
        network.vs[&#39;on&#39;] = True
        network.es[&#39;weight&#39;] = 2 / p_succ
        del network.es[&#39;step&#39;]

        turn = 0

        # Iterate until no edges remain in the fusion network
        while True:
            if not network.ecount():
                break

            if is_fusion_order_given:
                enames_curr_step = [str(fusion_order[turn])]
                is_parellel = True

            elif strategy == &#39;weight&#39;:
                min_weight = min(network.es[&#39;weight&#39;])
                eids_min_weight = network.es.select(weight=min_weight)
                enames_curr_step = eids_min_weight[&#39;name&#39;]
                is_parellel = len(enames_curr_step) == 1

            # elif strategy == &#39;betweenness&#39;:
            #     eb = np.array(network.edge_betweenness())
            #     min_eb = np.min(eb)
            #     eids_curr_step = np.nonzero(eb == min_eb)[0]
            #     enames_curr_step = [network.es[eid][&#39;name&#39;] for eid in
            #     eids_curr_step]
            #     is_parellel = len(enames_curr_step) == 1
            #
            # elif strategy == &#39;weight_and_betweenness&#39;:
            #     min_weight = min(network.es[&#39;weight&#39;])
            #     eids_min_weight = network.es.select(weight=min_weight)
            #     es_min_ovh = eids_min_weight
            #
            #     eb = network.edge_betweenness()
            #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
            #     min_eb = np.min(ebs_min_ovh)
            #     enames_curr_step = [es_min_ovh[i][&#39;name&#39;] for i in
            #     np.nonzero(ebs_min_ovh == min_eb)[0]]
            #     is_parellel = len(enames_curr_step) == 1

            elif &#39;matching&#39; in strategy:
                if strategy == &#39;weight_and_matching&#39;:
                    min_weight = min(network.es[&#39;weight&#39;])
                    es_min_weight = network.es.select(weight=min_weight)
                    subnetwork = network.subgraph_edges(es_min_weight)
                else:
                    subnetwork = network

                subnetwork_nx = subnetwork.to_networkx()
                if isinstance(subnetwork_nx, nx.MultiGraph):
                    subnetwork_nx = nx.Graph(subnetwork_nx)
                matching = nx.max_weight_matching(subnetwork_nx, weight=None)
                enames_curr_step = \
                    subnetwork.es[subnetwork.get_eids(matching)][&#39;name&#39;]

                is_parellel = True

            elif strategy == &#39;random&#39;:
                enames_curr_step = [np.random.choice(network.es[&#39;name&#39;])]
                is_parellel = True

            else:
                raise ValueError

            recalculated_enames = []

            if get_fusion_order and not is_fusion_order_given:
                fusion_order_curr_step = set()
                fusion_order.append(fusion_order_curr_step)

            while True:
                if not is_parellel:
                    for rec_ename in recalculated_enames:
                        try:
                            enames_curr_step.remove(rec_ename)
                        except ValueError:
                            pass

                if not enames_curr_step:
                    break

                recalculated_enames.clear()

                if is_parellel:
                    ename_to_merge = enames_curr_step.pop()
                else:
                    ename_to_merge = np.random.choice(enames_curr_step)
                    enames_curr_step.remove(ename_to_merge)

                if get_fusion_order:
                    e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                    v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                    fusion_order_curr_step.add((v1[&#39;name&#39;], v2[&#39;name&#39;],
                                                ename_to_merge))

                enames_updated_weight = self._contract_edge(network,
                                                            ename_to_merge)

                recalculated_enames.extend(enames_updated_weight)

        v_final = network.vs.select(on=True)
        overhead = sum(v_final[&#39;weight&#39;])
        step = max(v_final[&#39;step&#39;])

        results = {
            &#39;overhead&#39;: overhead,
            &#39;step&#39;: step,
            &#39;fusion_order_strategy&#39;: strategy,
            &#39;p_succ&#39;: p_succ}

        if get_fusion_order:
            results[&#39;fusion_order&#39;] = fusion_order

        self.data.update(results)

        return self.data.copy()

    def simulate(self,
                 n_iter,
                 p_succ=0.5,
                 mp=False,
                 n_procs=None,
                 get_all_data=False,
                 get_all_graphs=False,
                 get_all_fusion_networks=False,
                 unravel=True,
                 unravel_bcs_first=&#39;random&#39;,
                 fusion_order_strategy=&#39;weight_and_matching&#39;,
                 seed=&#39;keep&#39;,
                 verbose=True,
                 pbar=False,
                 **kwargs):
        &#34;&#34;&#34;
        Execute the strategy for a fixed number of iterations and obtain the
        best one only (by default).

        Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
        `GraphState.fusion_network` are updated according to the result of the best
        sample.

        Parameters
        ----------
        n_iter : int
            Iteration number.

        p_succ : float (default: 0.5)
            Success probability of a fusion.

        mp : bool (default: False)
            Whether to use multiprocessing for the iterations. Package
            *parmap* should be installed to use it.

        n_procs : None or int (default: None)
            Maximal number of simultaneous processes for multiprocessing.&lt;br&gt;
            If it is `None`, the number of CPUs is used. Ignored when `mp` is
            `False`.

        get_all_data : bool (default: False)
            Whether to obtain the data (overheads, numbers of steps, etc.) from
            all samples or only the best sample.

        get_all_graphs : bool (default: False)
            Whether to obtain the unraveled graphs from all samples or only the
            best sample.

        get_all_fusion_networks : bool (default: False)
            Whether to obtain the fusion networks from all samples or only the
            best sample.

        unravel : bool (default: True)
            Whether to unravel the graph or not.

        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are unraveled.
            - `False`, cliques are unraveled first, then BCSs are unraveled.
            - `&#39;random&#39;`, the order is randomly chosen.

        fusion_order_strategy : one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: `weight_and_matching&#39;)
            Strategy for determining the edge to contract in each step.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        seed : &#39;keep&#39; or None or int (default: &#39;keep&#39;)
            Random seed.

            - `&#39;keep&#39;`: The seed is not initialized.
            - `None`: The current time is used as the random seed.
            - `int`: The given number is used as the random seed.

        verbose : bool (default: True)
            Whether to print logs.

        pbar : bool (default: False)
            Whether to show a progress bar.&lt;br&gt;
            Ignored if `mp` is `False`

        kwargs : dict
            Additional keyword arguments for calculating overheads.&lt;br&gt;
            See the description of `GraphState.calculate_overhead()`.

        Returns
        -------
        res : dict
            Result of the iterations.&lt;br&gt;
            By default, only the information of the best sample is given.
        &#34;&#34;&#34;

        t0 = time.time()

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        if mp:
            if n_procs is None:
                n_procs = os.cpu_count()
            mp = mp and n_iter &gt;= n_procs

        if not mp:
            if verbose:
                print(&#34;Multiprocessing OFF.&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}...&#34;)

            if n_iter == 1 and seed is not None and seed != &#39;keep&#39;:
                seeds_samples = [seed]
            else:
                seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

            overheads = [] if get_all_data else None
            steps = [] if get_all_data else None
            seeds = [] if get_all_data else None
            unravalled_graphs = [] if get_all_graphs else None
            fusion_networks = [] if get_all_fusion_networks else None

            best_sample = None
            lowest_overhead = None
            for i_sample in range(n_iter):
                seed_sample = seeds_samples[i_sample]
                np.random.seed(seed_sample)

                if unravel:
                    self.unraveled_graph = None
                    try:
                        self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                    except:
                        print(&#39;Error occurs during unraveling&#39;)
                        print(&#39;seed =&#39;, seed_sample)
                        raise ValueError

                try:
                    self.build_fusion_network(use_unraveled_graph=unravel)
                except:
                    print(&#39;Error occurs during building fusion network&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                try:
                    data_now = self.calculate_overhead(p_succ=p_succ,
                                                       strategy=fusion_order_strategy,
                                                       **kwargs)
                except:
                    print(&#39;Error occurs during calculating overhead&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                overhead_now = data_now[&#39;overhead&#39;]
                step_now = data_now[&#39;step&#39;]
                self.data[&#39;seed&#39;] = seed_sample

                if lowest_overhead is None or overhead_now &lt; lowest_overhead:
                    best_sample = i_sample
                    lowest_overhead = overhead_now
                    best_ogs = self.copy()

                if get_all_data:
                    overheads.append(overhead_now)
                    steps.append(step_now)
                    seeds.append(seed_sample)

                if get_all_graphs:
                    unravalled_graphs.append(self.unraveled_graph)

                if get_all_fusion_networks:
                    fusion_networks.append(self.fusion_network)

            res = {
                &#39;best_overhead&#39;: best_ogs.data[&#39;overhead&#39;],
                &#39;best_step&#39;: best_ogs.data[&#39;step&#39;],
                &#39;best_seed&#39;: best_ogs.data[&#39;seed&#39;],
                &#39;n_iter&#39;: n_iter}

            if unravel:
                res[&#39;unravel_bcs_first&#39;] = best_ogs.data[&#39;unravel_bcs_first&#39;]

            if get_all_data or get_all_graphs or get_all_fusion_networks:
                res[&#39;best_sample&#39;] = best_sample

                if get_all_data:
                    res[&#39;overheads&#39;] = overheads
                    res[&#39;steps&#39;] = steps
                    res[&#39;seeds&#39;] = seeds

                if get_all_graphs:
                    res[&#39;unraveled_graphs&#39;] = unravalled_graphs

                if get_all_fusion_networks:
                    res[&#39;fusion_networks&#39;] = fusion_networks

        else:
            if &#39;parmap&#39; not in sys.modules:
                raise ModuleNotFoundError(&#34;Package parmap is not installed.&#34;)

            if verbose:
                print(f&#34;Multiprocessing ON: n_procs = {n_procs}&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}... &#34;, end=&#39;&#39;)

            additional_keys = []
            if get_all_data:
                additional_keys.extend([&#39;overheads&#39;, &#39;steps&#39;, &#39;seeds&#39;])
            if get_all_graphs:
                additional_keys.append(&#39;unraveled_graphs&#39;)
            if get_all_fusion_networks:
                additional_keys.append(&#39;fusion_networks&#39;)

            left = n_iter % n_procs
            ns_samples = [n_iter // n_procs] * n_procs
            for i in range(left):
                ns_samples[i] += 1

            seeds = np.random.randint(0, _max_seed(), size=n_procs)

            res_procs = parmap.starmap(_simulate_single,
                                       list(zip(ns_samples, seeds)),
                                       self.graph,
                                       p_succ=p_succ,
                                       get_all_data=get_all_data,
                                       get_all_graphs=get_all_graphs,
                                       get_all_fusion_networks=get_all_fusion_networks,
                                       unravel=unravel,
                                       unravel_bcs_first=unravel_bcs_first,
                                       fusion_order_strategy=fusion_order_strategy,
                                       pm_pbar=pbar,
                                       **kwargs)
            best_overheads = [res_each[&#39;best_overhead&#39;] for res_each in
                              res_procs]
            best_proc = np.argmin(best_overheads)
            res = res_procs[best_proc]
            res[&#39;n_iter&#39;] = n_iter
            best_ogs = res[&#39;best_ogs&#39;]
            del res[&#39;best_ogs&#39;]

            if additional_keys:
                res[&#39;best_sample&#39;] += sum(ns_samples[:best_proc])

            for key in additional_keys:
                vals = [res_each[key] for res_each in res_procs]
                res[key] = list(itertools.chain(*vals))

        if verbose:
            print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} &#34;
                  f&#34;({time.time() - t0:.2f} s)&#34;)

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.unraveled_bcss = best_ogs.unraveled_bcss
        self.unraveled_cliques = best_ogs.unraveled_cliques
        self.data = best_ogs.data

        return res

    def simulate_adaptive(self,
                          init_n_iter,
                          mul=2,
                          p_succ=0.5,
                          mp=False,
                          n_procs=None,
                          get_all_data=False,
                          get_all_graphs=False,
                          get_all_fusion_networks=False,
                          unravel=True,
                          unravel_bcs_first=&#39;random&#39;,
                          fusion_order_strategy=&#39;weight_and_matching&#39;,
                          seed=&#39;keep&#39;,
                          verbose=True,
                          pbar=False,
                          **kwargs):
        &#34;&#34;&#34;
        Run the adaptive iteration method for the strategy and obtain the
        best one only (by default).

        The adaptive iteration method looks for the best iteration while
        keeps increasing the iteration number until a certain condition
        meets. In detail, denoting N iterations of the strategy as R(N),
        R(`init_n_iter`) is first executed and `q0` is obtained which is the
        lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
        and `q1` is obtained similarly. If `q0 &lt;= q1`, `q0` is returned. If
        otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
        If `q1 &lt;= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
        is executed, and so on.

        Parameters
        ----------
        init_n_iter : int
            Initial iteration number.

        mul : int (default: 2)
            Multiplicative factor of the iteration number.

        See the description of `GraphState.simulate()` for the other parameters.

        Returns
        -------
        res : dict
            Result of the iterations.&lt;br&gt;
            By default, only the information of the best sample is given.
        &#34;&#34;&#34;

        if mp and n_procs is None:
            n_procs = os.cpu_count()

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        additional_keys = []
        if get_all_data:
            additional_keys.extend([&#39;overheads&#39;, &#39;steps&#39;])
        if get_all_graphs:
            additional_keys.append(&#39;unraveled_graphs&#39;)
        if get_all_fusion_networks:
            additional_keys.append(&#39;fusion_networks&#39;)

        if verbose:
            if mp:
                print(f&#34;Multiprocessing (n_procs = {n_procs})&#34;)
            else:
                print(&#34;No multiprocessing&#34;)

        n_iter_history = []
        n_iter_now = init_n_iter
        res = None
        while True:
            if verbose:
                print(f&#34;Calculating for n_iter = {n_iter_now}... &#34;, end=&#39;&#39;)
            t0 = time.time()

            n_iter_history.append(n_iter_now)
            res_now = self.simulate(n_iter=n_iter_now,
                                    p_succ=p_succ,
                                    mp=mp,
                                    n_procs=n_procs,
                                    get_all_data=get_all_data,
                                    get_all_graphs=get_all_graphs,
                                    get_all_fusion_networks=get_all_fusion_networks,
                                    unravel=unravel,
                                    unravel_bcs_first=unravel_bcs_first,
                                    fusion_order_strategy=fusion_order_strategy,
                                    verbose=False,
                                    pbar=pbar,
                                    **kwargs)

            if res is None:
                res = res_now
                best_ogs = self.copy()
                n_iter_now *= mul

            else:
                for key in additional_keys:
                    res[key].extend(res_now[key])

                if res_now[&#39;best_overhead&#39;] &lt; res[&#39;best_overhead&#39;]:
                    for key in additional_keys:
                        res_now[key] = res[key]
                    res = res_now
                    best_ogs = self.copy()

                    n_iter_now *= mul

                else:
                    if verbose:
                        print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} (&#34;
                              f&#34;{time.time() - t0:.2f} s)&#34;)
                    break

            if verbose:
                print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} &#34;
                      f&#34;({time.time() - t0:.2f} s)&#34;)

        res[&#39;n_iter&#39;] = sum(n_iter_history)

        if additional_keys:
            res[&#39;best_sample&#39;] += res[&#39;best_sample&#39;]

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.unraveled_bcss = best_ogs.unraveled_bcss
        self.unraveled_cliques = best_ogs.unraveled_cliques
        self.data = best_ogs.data

        return res

    def _get_graph(self, graph):
        if isinstance(graph, ig.Graph):
            return graph

        if graph == &#39;graph&#39;:
            return self.graph
        elif graph in [&#39;unraveled&#39;, &#39;unraveled_graph&#39;]:
            if self.unraveled_graph is None:
                raise ValueError(&#39;No unraveled graph created.&#39;)
            return self.unraveled_graph
        elif graph in [&#39;network&#39;, &#39;fusion_network&#39;]:
            if self.fusion_network is None:
                raise ValueError(&#39;No fusion network created&#39;)
            return self.fusion_network
        else:
            raise ValueError(&#39;Wrong input.&#39;)

    def group_links_by_steps(self):
        &#34;&#34;&#34;
        Get all the links grouped by their fusion steps.

        Returns
        -------
        group : dict
            `group[i]` (for `i` = 1, 2, ...) is the list of the connected pairs
            of nodes in the `i`-th step.
        &#34;&#34;&#34;
        network = self.fusion_network
        if not isinstance(network, ig.Graph):
            raise ValueError(&#39;No fusion network created&#39;)

        group = {}
        i = 1
        while True:
            es = network.es.select(step=i)
            if len(es) == 0:
                break
            node_pairs = []
            for e in es:
                node_pairs.append((e.source_vertex[&#39;name&#39;],
                                   e.target_vertex[&#39;name&#39;]))
            group[i] = node_pairs
            i += 1

        return group

    def plot_graph(self, unraveled=False, **kwargs):
        &#34;&#34;&#34;
        Plot the original or unraveled graph.

        If the unraveled graph is plotted, edges in the unraveled graph are
        drawn as black solid lines while external fusions are drawn as red
        dashed lines (by default).

        Parameters
        ----------
        unraveled : bool (default: False)
            Whether to plot the unraveled graph or the original graph.

        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.&lt;br&gt;
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (7, 7))
            Size of the figure in inches.

        show_vertex_name : bool (default: True)
            Whether to show vertex names.

        vertex_color_normal : str (default: &#39;white&#39;)
            Color of vertices without Clifford operations.

        vertex_color_clifford : str (default: &#39;orange&#39;)
            Color of vertices with Clifford operations.

        vertices_to_highlight : None or list of {str or int} (default: None)
            Name of vertices to highlight.

        vertex_color_highlight : str (default: purple)
            Color of the highlighted vertices.&lt;br&gt;
            Ignored if `vertices_to_highlight` is `None`.

        edge_color_normal : str (default: black)
            Color of edges in the graph.

        edge_color_fusion : str (default: red)
            Color of lines for external fusions.&lt;br&gt;
            Ignored if `unraveled` is `False`.

        edge_style_fusion : str (default: &#39;--&#39;)
            Style of lines for external fusions.

        Any other keyword arguments in `igraph.plot()` can be directly used.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
        If they are given, they override the above parameters.

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if unraveled else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled graph created.&#34;)

        fig, ax = plot_graph(graph, **kwargs)

        return fig, ax

    def plot_fusion_network(self, **kwargs):
        &#34;&#34;&#34;
        Plot the fusion network.

        Parameters
        ----------
        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.&lt;br&gt;
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (7, 7))
            Size of the figure in inches.

        show_node_name : bool (default: True)
            Whether to show node names.

        node_color_normal : str (default: &#39;white&#39;)
            Color of nodes without Clifford operations.

        node_color_clifford : str (default: &#39;orange&#39;)
            Color of nodes with Clifford operations.

        show_link_name : bool (default: False)
            Whether to show link names.

        show_fusion_order : bool (default: True)
            Whether to show fusion orders on links.&lt;br&gt;
            If both `show_link_name` and `show_fusion_order` are `True`,
            it is shown as `&#39;{link name}-{fusion order}&#39;`

        uniform_link_style : bool (default: False)
            Whether to use uniform link colors/styles or not.
            If it is `False`, links of different types (leaf-to-leaf,
            root-to-leaf, root-to-root) are drawn in different colors and
            linestyles. Specifically, root-to-leaf links are drawn as lines
            with arrows.

        link_color_ll : str (default: &#39;black&#39;)
            Color of links of &#39;leaf-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_color_rl : str (default: &#39;blue&#39;)
            Color of links of &#39;root-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_color_rr : str (default: &#39;red&#39;)
            Color of links of &#39;root-to-root&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_style_ll : str (default: &#39;-&#39;)
            Style of links of &#39;leaf-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_style_rl : str (default: &#39;-&#39;)
            Style of links of &#39;root-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_style_rr : str (default: &#39;--&#39;)
            Style of links of &#39;root-to-root&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        Any other keyword arguments in igraph.plot can be directly used.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
        If they are given, they override the above parameters.&lt;br&gt;

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        network = self.fusion_network
        if network is None:
            raise ValueError(&#39;No fusion network created.&#39;)

        fig, ax = plot_fusion_network(network, **kwargs)

        return fig, ax

    def copy(self):
        &#34;&#34;&#34;
        Return a **shallow** copy of this object.

        Returns
        -------
        copy : GraphState
            Copied instance of itself.
        &#34;&#34;&#34;

        copy = GraphState(graph=self.graph,
                          unraveled_graph=self.unraveled_graph,
                          fusion_network=self.fusion_network)

        copy.unraveled_bcss = self.unraveled_bcss
        copy.unraveled_cliques = self.unraveled_cliques
        copy.data = self.data.copy()
        if self.graph_info is not None:
            copy.graph_info = self.graph_info.copy()

        return copy


def _simulate_single(n_iter, seed, graph, **kwargs):
    ogs = GraphState(graph=graph)
    res = ogs.simulate(n_iter=n_iter, seed=seed, verbose=False, **kwargs)
    res[&#39;best_ogs&#39;] = ogs

    return res</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="optgraphstate.graph_tools" href="graph_tools.html">optgraphstate.graph_tools</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="optgraphstate.utils" href="utils.html">optgraphstate.utils</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="optgraphstate.visualization" href="visualization.html">optgraphstate.visualization</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="optgraphstate.GraphState"><code class="flex name class">
<span>class <span class="ident">GraphState</span></span>
<span>(</span><span>graph=None, edges=None, shape=None, prms=None, cliffords=None, unraveled_graph=None, fusion_network=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for calculating and optimizing the resource overhead of the
fusion-based generation of a graph state.</p>
<p>The graph of the concerned graph state can be given by the following
three ways:</p>
<ol>
<li>Given explicitly by <code>igraph.Graph</code> or <code>networkx.Graph</code>.</li>
<li>Given by a list of edges.</li>
<li>Chosen among predefined graphs.</li>
</ol>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>None</code> or <code>igraph.Graph</code> or <code>networkx.Graph (default: None)</code></dt>
<dd>Graph of the concerned graph.<br>
If it is given, <code>edges</code>, <code>shape</code>, and <code>prms</code> are ignored. If it
is <code>networkx.Graph</code>, it is internally converted to <code>igraph.Graph</code>.</dd>
<dt><strong><code>edges</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>2-tuple</code> of <code>int (default: None)</code></dt>
<dd>List of edges that form the concerned graph.<br>
Each integer in the tuples indicates a vertex label. If it is
given and <code>graph</code> is <code>None</code>, <code>shape</code> and <code>prms</code> are ignored.</dd>
<dt><strong><code>shape</code></strong> :&ensp;<code>None</code> or <code>str (default: None)</code></dt>
<dd>
<p>Shape of the concerned graph chosen among predefined graphs.<br>
One of <code>[None, 'random', 'complete', 'star', 'linear', 'cycle',
'lattice', 'tree', 'rhg', 'repeater', 'parity_encoding', 'ptqc']</code>.</p>
<ul>
<li><code>shape='random'</code> : Random graph for fixed numbers of vertices
and edges, sampled by the Erd√∂s-Renyi model.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Number of vertices.</li>
<li><code>prms[1]</code> &lt;<code>int</code>&gt; : Number of edges.</li>
<li>[Optional] <code>prms[2]</code> &lt;<code>None</code> or <code>int</code>&gt; : Random seed. If
<code>None</code>, the current system time is used as the seed. If not
given, the random number generator is not initialized.</li>
</ul>
</li>
<li><code>shape='complete'</code>, <code>'star'</code>, <code>'linear'</code>, or <code>'cycle'</code> :
Complete, star, linear, or cycle graph, respectively.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Number of vertices.</li>
</ul>
</li>
<li><code>shape='lattice'</code> : Lattice graph.<ul>
<li><code>prms</code> &lt;<code>tuple</code> of <code>int</code>&gt; : Numbers of repeated vertices
along the axes. The dimension of the lattice is
automatically set as <code>len(prms)</code>.</li>
</ul>
</li>
<li><code>shape='tree'</code> : Tree graph where all branches in each
generation have an equal number of children.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Degree of the root vertex.</li>
<li><code>prms[i]</code> (&lt;<code>int</code>&gt;, i &gt;= 1) : Number of the children of each
<code>i</code>th-generation branch.</li>
</ul>
</li>
<li><code>shape='rhg'</code> : Raussendorf-Harrington-Goyal lattice with primal
boundaries only.<ul>
<li><code>prms[0]</code>, <code>prms[1]</code>, <code>prms[2]</code> &lt;<code>int</code>&gt; : Size of the lattice
along the three axes in the unit of a cell.</li>
</ul>
</li>
<li><code>shape='repeater'</code> : Repeater graph with 4m vertices.<ul>
<li><code>prms[0]</code> &lt;<code>int</code>&gt; : Parameter m.</li>
</ul>
</li>
<li><code>shape='parity_encoding'</code> : (n, m) parity-encoded graph.<ul>
<li><code>prms[0]</code> &lt;<code>igraph.Graph</code>&gt; : Logical-level graph. Can be
generated with python-igraph library directly or from the
function <code>get_graph_from_edges()</code> or <code>get_sample_graph</code>.</li>
<li><code>prms[1]</code>, <code>prms[2]</code> &lt;<code>int</code>&gt; : Parameters n and m of the
parity encoding.</li>
</ul>
</li>
<li><code>shape='ptqc'</code> : Microcluster for parity-encoding-based
topological quantum computing protocol.<ul>
<li><code>prms[0]</code>, <code>prms[1]</code> &lt;<code>int</code>&gt; : Parameter n and m of the
parity encoding.</li>
<li><code>prms[2]</code> &lt;<code>bool</code>&gt; : Whether the H-configuration is
HIC (<code>True</code>) or HIS (<code>False</code>).</li>
<li><code>prms[3]</code> &lt;<code>bool</code>&gt; : Whether the microcluster is
central (<code>True</code>) or side (<code>False</code>) one.</li>
</ul>
</li>
</ul>
</dd>
<dt><strong><code>prms</code></strong> :&ensp;<code>None</code> or <code>tuple</code> or <code>int (default: None)</code></dt>
<dd>Parameters for a predefined graph.<br>
See the description for parameter <code>shape</code>. If only one parameter
is required, it can be given as a number, not a tuple.</dd>
<dt><strong><code>cliffords</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>str (default: None)</code></dt>
<dd>Local clifford operations applied on the qubits of the graph
state.<br>
If it is <code>None</code>, no Clifford operations are applied on the qubits.<br>
If it is a <code>list</code> of <code>str</code>, its length should be equal to the
number of vertices in the graph. Its i-th element indicates the
Clifford operation applied on the i-th qubit. For example,
if it is <code>'H'</code>, it means that a Hadamard gate is applied on the
qubit. If it is <code>'H-S-Z'</code>, it means that Hadamard, phase,
and Z gates are applied in order.</dd>
<dt><strong><code>unraveled_graph</code></strong> :&ensp;<code>None</code> or <code>igraph.Graph</code> or <code>networkx.Graph (default: None)</code></dt>
<dd>Pregiven unraveled graph.<br>
The code does not check the validity of the given unraveled graph.
If it is <code>networkx.Graph</code>, it is internally converted to
<code>igraph.Graph</code>.</dd>
<dt><strong><code>fusion_network</code></strong> :&ensp;<code>None</code> or <code>igraph.Graph</code> or <code>networkx.Graph (default: None)</code></dt>
<dd>Pregiven fusion network.<br>
The code does not check the validity of the given fusion network.
If it is <code>networkx.Graph</code>, it is internally converted to
<code>igraph.Graph</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GraphState:
    graph: ig.Graph  #: Graph of the graph state to investigate.
    graph_info: set  #: Information of the graph in `GraphState.graph`. It is not empty only when the graph is initialized by using the parameters `shape` and `prms`.
    unraveled_graph: ig.Graph  #: Unraveled graph generated by unraveling the original graph (in `GraphState.graph`). It is `None` before the unraveled graph is created.
    fusion_network: ig.Graph  #: Fuson network constructed from the unraveled graph (in `GraphState.unraveled_graph`) or the original graph (in `GraphState.graph`). It is `None` before the fusion network is created.
    unraveled_bcss: set  #: Unraveled bipartitely-complete subgraphs (BCSs). It is empty before unraveling the graph.
    unraveled_cliques: set  #: Unraveled cliques. It is empty before unraveling the graph.
    data: dict  #: Any data obtained during unraveling the graph, constructing the fusion network, and calculating the resource overhead.

    def __init__(self,
                 graph=None,
                 edges=None,
                 shape=None,
                 prms=None,
                 cliffords=None,
                 unraveled_graph=None,
                 fusion_network=None):
        &#34;&#34;&#34;
        Class for calculating and optimizing the resource overhead of the
        fusion-based generation of a graph state.

        The graph of the concerned graph state can be given by the following
        three ways:

        1. Given explicitly by `igraph.Graph` or `networkx.Graph`.
        2. Given by a list of edges.
        3. Chosen among predefined graphs.

        Parameters
        ----------
        graph : None or igraph.Graph or networkx.Graph (default: None)
            Graph of the concerned graph.&lt;br&gt;
            If it is given, `edges`, `shape`, and `prms` are ignored. If it
            is `networkx.Graph`, it is internally converted to `igraph.Graph`.

        edges : None or list of 2-tuple of int (default: None)
            List of edges that form the concerned graph.&lt;br&gt;
            Each integer in the tuples indicates a vertex label. If it is
            given and `graph` is `None`, `shape` and `prms` are ignored.

        shape : None or str (default: None)
            Shape of the concerned graph chosen among predefined graphs.&lt;br&gt;
            One of `[None, &#39;random&#39;, &#39;complete&#39;, &#39;star&#39;, &#39;linear&#39;, &#39;cycle&#39;,
            &#39;lattice&#39;, &#39;tree&#39;, &#39;rhg&#39;, &#39;repeater&#39;, &#39;parity_encoding&#39;, &#39;ptqc&#39;]`.

            - `shape=&#39;random&#39;` : Random graph for fixed numbers of vertices
            and edges, sampled by the Erd√∂s-Renyi model.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
                - `prms[1]` &lt;`int`&gt; : Number of edges.
                - [Optional] `prms[2]` &lt;`None` or `int`&gt; : Random seed. If
                `None`, the current system time is used as the seed. If not
                given, the random number generator is not initialized.
            - `shape=&#39;complete&#39;`, `&#39;star&#39;`, `&#39;linear&#39;`, or `&#39;cycle&#39;` :
            Complete, star, linear, or cycle graph, respectively.
                - `prms[0]` &lt;`int`&gt; : Number of vertices.
            - `shape=&#39;lattice&#39;` : Lattice graph.
                - `prms` &lt;`tuple` of `int`&gt; : Numbers of repeated vertices
                along the axes. The dimension of the lattice is
                automatically set as `len(prms)`.
            - `shape=&#39;tree&#39;` : Tree graph where all branches in each
            generation have an equal number of children.
                - `prms[0]` &lt;`int`&gt; : Degree of the root vertex.
                - `prms[i]` (&lt;`int`&gt;, i &gt;= 1) : Number of the children of each
                `i`th-generation branch.
            - `shape=&#39;rhg&#39;` : Raussendorf-Harrington-Goyal lattice with primal
            boundaries only.
                - `prms[0]`, `prms[1]`, `prms[2]` &lt;`int`&gt; : Size of the lattice
                along the three axes in the unit of a cell.
            - `shape=&#39;repeater&#39;` : Repeater graph with 4m vertices.
                - `prms[0]` &lt;`int`&gt; : Parameter m.
            - `shape=&#39;parity_encoding&#39;` : (n, m) parity-encoded graph.
                - `prms[0]` &lt;`igraph.Graph`&gt; : Logical-level graph. Can be
                generated with python-igraph library directly or from the
                function `get_graph_from_edges()` or `get_sample_graph`.
                - `prms[1]`, `prms[2]` &lt;`int`&gt; : Parameters n and m of the
                parity encoding.
            - `shape=&#39;ptqc&#39;` : Microcluster for parity-encoding-based
            topological quantum computing protocol.
                - `prms[0]`, `prms[1]` &lt;`int`&gt; : Parameter n and m of the
                parity encoding.
                - `prms[2]` &lt;`bool`&gt; : Whether the H-configuration is
                HIC (`True`) or HIS (`False`).
                - `prms[3]` &lt;`bool`&gt; : Whether the microcluster is
                central (`True`) or side (`False`) one.

        prms : None or tuple or int (default: None)
            Parameters for a predefined graph.&lt;br&gt;
            See the description for parameter `shape`. If only one parameter
            is required, it can be given as a number, not a tuple.

        cliffords : None or list of str (default: None)
            Local clifford operations applied on the qubits of the graph
            state.&lt;br&gt;
            If it is `None`, no Clifford operations are applied on the qubits.&lt;br&gt;
            If it is a `list` of `str`, its length should be equal to the
            number of vertices in the graph. Its i-th element indicates the
            Clifford operation applied on the i-th qubit. For example,
            if it is `&#39;H&#39;`, it means that a Hadamard gate is applied on the
            qubit. If it is `&#39;H-S-Z&#39;`, it means that Hadamard, phase,
            and Z gates are applied in order.

        unraveled_graph : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven unraveled graph.&lt;br&gt;
            The code does not check the validity of the given unraveled graph.
            If it is `networkx.Graph`, it is internally converted to
            `igraph.Graph`.

        fusion_network : None or igraph.Graph or networkx.Graph (default: None)
            Pregiven fusion network.&lt;br&gt;
            The code does not check the validity of the given fusion network.
            If it is `networkx.Graph`, it is internally converted to
            `igraph.Graph`.
        &#34;&#34;&#34;

        def convert_type(g, varname):
            if g is None:
                return None
            elif isinstance(g, ig.Graph):
                return g
            elif isinstance(g, nx.Graph):
                return ig.Graph.from_networkx(g)
            else:
                raise TypeError(f&#39;Parameter {varname} should be igraph.Graph &#39;
                                f&#39;or networkx.Graph.&#39;)

        if graph is not None:
            self.graph = convert_type(graph, &#39;graph&#39;)
            self.graph_info = None

        elif edges is not None:
            self.graph = ig.Graph(edges=edges)
            self.graph_info = None

        elif shape is not None:
            try:
                prms[0]
            except TypeError:
                prms = (prms,)

            self.graph, self.graph_info = get_sample_graph(shape, *prms)

        else:
            raise ValueError(
                &#34;At least one of graph, edges, and shape should be given.&#34;)

        if self.graph_info is None:
            self.graph_info = {
                &#39;num_vertices&#39;: self.graph.vcount(),
                &#39;num_edges&#39;: self.graph.ecount()}

        self.graph.vs[&#39;name&#39;] = [str(vid) for vid in
                                 range(self.graph.vcount())]

        if cliffords is not None and edges is None:
            self.graph.vs[&#39;clifford&#39;] = cliffords

        self.unraveled_graph = convert_type(unraveled_graph, &#39;unraveled_graph&#39;)
        self.unraveled_bcss = set()
        self.unraveled_cliques = set()

        self.fusion_network = convert_type(fusion_network, &#39;fusion_network&#39;)

        self.data = {}

    def initialize(self):
        &#34;&#34;&#34;
        Initialize the created unraveled graph and fusion network and the
        calculation data.
        &#34;&#34;&#34;
        self.unraveled_graph = None
        self.fusion_network = None
        self.unraveled_bcss = set()
        self.unraveled_cliques = set()
        self.data = {}

    def unravel_graph(self,
                      unravel_bcs_first=&#39;random&#39;,
                      plot=False,
                      verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

        The unraveled graph is saved in `self.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are
            unraveled.
            - `False`: cliques are unraveled first, then BCSs are
            unraveled.&lt;br&gt;
            - `&#39;random&#39;`: the order is randomly chosen.

        plot : bool (default: False)
            Whether to plot the unraveled graph after unraveling.

        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Data on unraveled BCSs, which is identical with
            `GraphState.unraveled_bcss`.&lt;br&gt;
            `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
            the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
            finding non-overlapping BCSs.

        cliques : list of list of set of str
            Data on unraveled cliques, which is identical with
            `GraphState.unraveled_cliques`.&lt;br&gt;
            `cliques[i][j]` is the set of the names of the vertices in the
            `j`-th clique obtained by the `i`-th cycle of finding
            non-overlapping cliques.
        &#34;&#34;&#34;

        if unravel_bcs_first == &#39;random&#39;:
            unravel_bcs_first = np.random.choice([True, False])

        if unravel_bcs_first:
            bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)
            cliques = self.unravel_cliques(verbose=verbose)
        else:
            cliques = self.unravel_cliques(verbose=verbose)
            bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)

        if plot or verbose:
            if verbose:
                print(&#39;[Final]&#39;)
            self.plot_graph(unraveled=True)
            plt.show()

        self.data[&#39;unravel&#39;] = True
        self.data[&#39;unravel_bcs_first&#39;] = unravel_bcs_first

        return self.unraveled_graph, bcss, cliques

    def unravel_bipartitely_complete_subgraphs(self, verbose=False):
        &#34;&#34;&#34;
        Unravel bipartitely-complete subgraphs (BCSs) of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        bcss : list of list of 2-tuple of list of str
            Data on unraveled BCSs.&lt;br&gt;
            See the description of `GraphState.unravel_graph()`.
        &#34;&#34;&#34;

        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_bcss = []

        new_vertex_name = graph.vcount()

        while True:
            # Repeat until there are no bipartitely-complete subgraphs
            bcs_exist = False
            while True:
                bcss = find_nonoverlapping_bcs(graph, get_name=True)
                if bcss:
                    bcs_exist = True
                else:
                    break

                unraveled_bcss.append(bcss)
                eids_to_remove = []
                for part1, part2 in bcss:
                    if verbose:
                        graph.delete_edges(eids_to_remove)
                        eids_to_remove.clear()
                        print(&#39;bcs to unravel =&#39;, part1, &#39;&amp;&#39;, part2)
                        vertex_color = []
                        for v in graph.vs:
                            if v[&#39;name&#39;] in part1:
                                vertex_color.append(&#39;orange&#39;)
                            elif v[&#39;name&#39;] in part2:
                                vertex_color.append(&#39;blue&#39;)
                            else:
                                vertex_color.append(&#39;white&#39;)
                        self.plot_graph(unraveled=True,
                                        vertex_color=vertex_color)
                        plt.show()

                    eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                           vname1, vname2 in
                                           itertools.product(part1, part2)])

                    vname1 = str(new_vertex_name)
                    vname2 = str(new_vertex_name + 1)
                    new_v1 = graph.add_vertex(name=vname1,
                                              ext_fusion=vname2,
                                              clifford=None)
                    new_v2 = graph.add_vertex(name=vname2,
                                              ext_fusion=vname1,
                                              clifford=None)
                    new_vertex_name += 2

                    graph.add_edges(itertools.product([new_v1], part1))
                    graph.add_edges(itertools.product([new_v2], part2))

                graph.delete_edges(eids_to_remove)

            if not bcs_exist:
                break

        self.unraveled_bcss = unraveled_bcss

        return unraveled_bcss

    def unravel_cliques(self, verbose=False):
        &#34;&#34;&#34;
        Unravel cliques of the graph.

        The unraveled graph is saved in `GraphState.unraveled_graph` as
        `igraph.Graph`.

        Parameters
        ----------
        verbose : bool (default: False)
            Whether to print logs and plot the intermediate graphs during
            the unraveling process.

        Returns
        -------
        cliques : list of list of set of str
            Data on unraveled cliques.&lt;br&gt;
            See the description of `GraphState.unravel_graph()`.
        &#34;&#34;&#34;
        if self.unraveled_graph is None:
            self.unraveled_graph = self.graph.copy()

        graph = self.unraveled_graph

        vs_attrs = graph.vs.attributes()
        if &#39;ext_fusion&#39; not in vs_attrs:
            graph.vs[&#39;ext_fusion&#39;] = None
        if &#39;clifford&#39; not in vs_attrs:
            graph.vs[&#39;clifford&#39;] = None

        unraveled_cliques = []

        def apply_clifford(v, clifford):
            org_clifford = v[&#39;clifford&#39;]
            if org_clifford is None:
                new_clifford = clifford
            else:
                new_clifford = &#39;-&#39;.join([clifford, org_clifford])
            v[&#39;clifford&#39;] = new_clifford

        while True:
            cliques = find_nonoverlapping_cliques(graph, get_name=True)

            if not cliques:
                break

            unraveled_cliques.append(cliques)

            for clique in cliques:
                if verbose:
                    print(&#39;clique to unravel =&#39;, clique)
                    vertex_color = [&#39;orange&#39; if vname in clique else &#39;white&#39;
                                    for vname in graph.vs[&#39;name&#39;]]
                    self.plot_graph(unraveled=True, vertex_color=vertex_color)
                    plt.show()
                clique = list(clique)
                clique_size = len(clique)

                # Choose a vertex to apply LC
                degrees = graph.degree(clique)
                min_degree = min(degrees)
                if min_degree == clique_size - 1:
                    # There exists a vertex in the clique that doesn&#39;t have
                    # outer edges
                    vname_LC = [vname for vname, deg in zip(clique, degrees) if
                                deg == min_degree]
                    need_to_separate = False
                else:
                    vname_LC = clique
                    need_to_separate = True

                if len(vname_LC) &gt; 1:
                    vname_LC = np.random.choice(vname_LC)
                else:
                    vname_LC = vname_LC[0]
                v_LC = graph.vs.find(name=vname_LC)

                # Separate the edges (E) incident to v_LC outside the clique
                # from v_LC
                eids_to_delete = []
                if need_to_separate:
                    # Vertex connected with E
                    new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=v_LC[&#39;clifford&#39;],
                                              ext_fusion=v_LC[&#39;ext_fusion&#39;])

                    # Vertex having an external fusion with v_LC
                    new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                              clifford=None,
                                              ext_fusion=v_LC[&#39;name&#39;])

                    graph.add_edge(new_v1, new_v2)

                    ngh_vids = graph.neighbors(vname_LC)
                    for ngh_vid in ngh_vids:
                        if graph.vs[ngh_vid][&#39;name&#39;] not in clique:
                            graph.add_edge(ngh_vid, new_v1)
                            eids_to_delete.append(graph.get_eid(vname_LC,
                                                                ngh_vid))

                    vname_org_ext_fusion = v_LC[&#39;ext_fusion&#39;]
                    if vname_org_ext_fusion is not None:
                        v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                        v_org_ext_fusion[&#39;ext_fusion&#39;] = new_v1[&#39;name&#39;]

                    v_LC[&#39;ext_fusion&#39;] = new_v2[&#39;name&#39;]

                # Apply LC
                adj_vnames = set(clique) - {vname_LC}
                apply_clifford(v_LC, &#39;R_X&#39;)
                for adj_vname in adj_vnames:
                    adj_v = graph.vs.find(name=adj_vname)
                    apply_clifford(adj_v, &#39;R_Z&#39;)

                new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                      vname1, vname2 in
                                      itertools.combinations(adj_vnames, r=2)]
                eids_to_delete.extend(new_eids_to_delete)
                graph.delete_edges(eids_to_delete)

        self.unraveled_cliques = unraveled_cliques

        return unraveled_cliques

    def build_fusion_network(self,
                             use_unraveled_graph=True,
                             plot=False,
                             verbose=False):
        &#34;&#34;&#34;
        Build a fusion network from the graph.

        The constructed fusion network is saved in `GraphState.fusion_network` as
        `igraph.Graph`.

        Parameters
        ----------
        use_unraveled_graph : bool (default: True)
            Whether to use the unraveled graph (in `GraphState.unraveled_graph`) or
            the original graph (in `GraphState.graph`) for building a fusion network.

        plot : bool (default: False)
            Whether to plot the fusion network after building it.

        verbose : bool (default: False)
            Whether to print logs.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if use_unraveled_graph else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled qubit graph created.&#34;)

        # Fusion network
        network = ig.Graph()
        self.fusion_network = network
        nodes_corr = {}

        # Links inside star graphs
        for v in graph.vs:
            num_internal_nodes = v.degree() - 1
            vname_xrot = v[&#39;name&#39;]
            if num_internal_nodes &gt;= 1:

                # Add nodes
                nid_init = network.vcount()
                seed = np.random.randint(0, num_internal_nodes)
                node_names = [vname_xrot if i == 0 else f&#39;{vname_xrot}-{i}&#39; for
                              i in itertools.chain(range(seed, -1, -1),
                                                   range(seed + 1,
                                                         num_internal_nodes))]
                attr = {
                    &#39;name&#39;: node_names,
                    &#39;seed&#39;: [True if i == seed else False for i in
                             range(num_internal_nodes)],
                    &#39;clifford_root&#39;: None,
                    # Clifford gate applied on the root qubit
                    &#39;clifford_leaves&#39;: None
                    # Clifford gate applied on the leaf qubits
                }
                network.add_vertices(num_internal_nodes, attributes=attr)
                nodes_corr[vname_xrot] = network.vs[
                                         nid_init:nid_init + num_internal_nodes]

                if num_internal_nodes &gt;= 2:
                    # Connect internal links
                    links = [(nid, nid + 1) for nid in range(nid_init,
                                                             nid_init + num_internal_nodes - 1)]
                    attr = {  # One of RR, RL, and LL, which respectively means
                        # that a fusion is performed on two roots,
                        # one root and one leaf, and two leaves of GHZ-3
                        # states.
                        &#39;kind&#39;: &#34;RL&#34;,  # Root node name, if kind == &#39;RL&#39;
                        &#39;root_node&#39;: [
                            node_names[i + 1] if i &lt; seed else node_names[i]
                            for i in range(num_internal_nodes - 1)]}
                    network.add_edges(links, attributes=attr)

        # Links between star graphs
        for e in graph.es:
            vs = [e.source_vertex, e.target_vertex]
            deg_vs = graph.degree(vs)

            if deg_vs[0] &gt; 1 and deg_vs[1] &gt; 1:
                nodes_to_connect = []
                for v in vs:
                    vname = v[&#39;name&#39;]
                    nodes = nodes_corr[
                        vname].select(lambda node: node.degree() &lt; (
                        2 if node[&#39;seed&#39;] else 3))
                    nodes_to_connect.append(np.random.choice(nodes))
                network.add_edge(*nodes_to_connect,
                                 kind=&#39;LL&#39;,
                                 root_node=None, )

        if verbose:
            print(&#34;Fusion network of the unraveled graph:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Set of seed node names where root vertices are connected by
        # external fusions.
        root_connected = set()
        is_node_not_full = lambda node: node.degree() &lt; (
            2 if node[&#39;seed&#39;] and (node[&#39;name&#39;] not in root_connected) else 3)

        def get_nodes_containing_vertex(vname):
            try:
                node = nodes_corr[vname].find(name=vname)
                root = True
            except KeyError:
                root_name = graph.vs[graph.neighbors(vname)[0]][&#39;name&#39;]
                nodes = nodes_corr[root_name].select(is_node_not_full)
                node = np.random.choice(nodes)
                root = False

            return node, root

        # Clifford operations
        vs_attrs = graph.vs.attributes()
        if &#39;clifford&#39; in vs_attrs:
            for v_cl in graph.vs.select(clifford_ne=None):
                vname = v_cl[&#39;name&#39;]
                node, root = get_nodes_containing_vertex(vname)
                cl = v_cl[&#39;clifford&#39;]

                if root:
                    node[&#39;clifford_root&#39;] = cl

                else:
                    key = v_cl[&#39;ext_fusion&#39;]
                    if key is None:
                        key = f&#39;final_{v_cl[&#34;name&#34;]}&#39;

                    clifford_leaves = node[&#39;clifford_leaves&#39;]
                    try:
                        clifford_leaves[key] = cl
                    except TypeError:
                        node[&#39;clifford_leaves&#39;] = {key: cl}

        if verbose:
            print(&#34;Apply Clifford operations:&#34;)
            self.plot_fusion_network()
            plt.show()

        # Links by external fusions
        if &#39;ext_fusion&#39; in vs_attrs:
            done = set()
            for v1 in graph.vs.select(ext_fusion_ne=None):

                vname1 = v1[&#39;name&#39;]
                if vname1 in done:
                    continue
                vname2 = v1[&#39;ext_fusion&#39;]
                done.add(vname2)

                node1, root1 = get_nodes_containing_vertex(vname1)
                node2, root2 = get_nodes_containing_vertex(vname2)
                if root1 and root2:
                    kind = &#39;RR&#39;
                    root_node = None
                    root_connected.add(node1[&#39;name&#39;])
                    root_connected.add(node2[&#39;name&#39;])
                elif not root1 and not root2:
                    kind = &#39;LL&#39;
                    root_node = None
                else:
                    kind = &#39;RL&#39;
                    root_node = node1[&#39;name&#39;] if root1 else node2[&#39;name&#39;]
                    root_connected.add(root_node)
                network.add_edge(node1, node2, kind=kind, root_node=root_node)

        network.es[&#39;name&#39;] = [str(eid) for eid in range(network.ecount())]

        self.fusion_network = network

        if plot:
            print(&#34;Final:&#34;)
            self.plot_fusion_network()
            plt.show()

    def _contract_edge(self, fusion_network, ename_to_merge):
        ename_to_merge = str(ename_to_merge)

        e_to_merge = fusion_network.es.find(name=ename_to_merge)
        v_merged, v_removed = e_to_merge.source_vertex, e_to_merge.target_vertex
        enames_updated_weight = []

        if v_merged.degree() &lt; v_removed.degree():
            v_merged, v_removed = v_removed, v_merged

        vname_merged = v_merged[&#39;name&#39;]
        vname_removed = v_removed[&#39;name&#39;]

        v_merged[&#39;weight&#39;] = e_to_merge[&#39;weight&#39;]
        v_merged[&#39;step&#39;] = max(v_merged[&#39;step&#39;], v_removed[&#39;step&#39;]) + 1

        assert vname_merged != vname_removed

        eids_to_delete = list(set(fusion_network.incident(v_removed)))
        v_removed[&#39;on&#39;] = False

        for eid_connected in eids_to_delete:
            e_connected = fusion_network.es[eid_connected]
            ename_connected = e_connected[&#39;name&#39;]
            if ename_connected != ename_to_merge:
                enames_updated_weight.append(ename_connected)
                vs_ngh = e_connected.source_vertex, e_connected.target_vertex
                new_edge = [
                    v_merged if v_ngh[&#39;name&#39;] == vname_removed else v_ngh for
                    v_ngh in vs_ngh]
                if new_edge[0] == new_edge[1]:  # If a loop is formed
                    v_vrt = fusion_network.add_vertex(name=f&#39;vrt_{fusion_network.vcount()}&#39;,
                                                      weight=0,
                                                      step=0)
                    new_edge = [v_merged, v_vrt]

                fusion_network.add_edge(*new_edge,
                                        name=ename_connected,
                                        weight=None, )

        fusion_network.delete_edges(eids_to_delete)

        p_succ = fusion_network[&#39;p_succ&#39;]
        for eid_connected in list(set(fusion_network.incident(v_merged))):
            e_connected = fusion_network.es[eid_connected]
            v_ngh1, v_ngh2 = e_connected.source_vertex, e_connected.target_vertex

            assert v_ngh1 != v_ngh2
            new_weight = (v_ngh1[&#39;weight&#39;] + v_ngh2[&#39;weight&#39;]) / p_succ
            e_connected[&#39;weight&#39;] = new_weight

        self.fusion_network.es.find(name=ename_to_merge)[&#39;step&#39;] = v_merged[
            &#39;step&#39;]

        return enames_updated_weight

    def calculate_overhead(self,
                           p_succ=0.5,
                           strategy=&#39;weight_and_matching&#39;,
                           fusion_order=None,
                           get_fusion_order=False, ):
        &#34;&#34;&#34;
        Calculate the resource overhead from the fusion network.

        The resulting data is saved in `GraphState.data`.

        Parameters
        ----------
        p_succ : float (default: 0.5)
            Success probability of a fusion.

        strategy: str, one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: &#39;weight_and_matching&#39;)
            Strategy for determining the edge to contract in each step.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        fusion_order : None or list of {int or str} (default: None)
            Fusion order given explicitly as vertex names.&lt;br&gt;
            If it is not `None`, parameter `strategy` is ignored.

        get_fusion_order : bool (default: False)
            Whether to include the determined fusion order in the returned
            data.

        Returns
        -------
        data : dict
            Outcomes of the calculation, which is a shallow copy of
            `GraphState.data`.&lt;br&gt;
            The calculated overhead and number of steps can be obtained from
            `data[&#39;overhead&#39;]` and `data[&#39;step&#39;]`, respectively.
        &#34;&#34;&#34;

        if self.fusion_network is None:
            raise ValueError(&#34;No fusion network created&#34;)

        # Trivial cases
        node_num = self.fusion_network.vcount()
        if node_num == 0:
            self.data[&#39;overhead&#39;] = 0
            self.data[&#39;step&#39;] = 0
            return self.data
        elif node_num == 1:
            self.data[&#39;overhead&#39;] = 1
            self.data[&#39;step&#39;] = 0
            return self.data

        if fusion_order is None:
            fusion_order = []
            is_fusion_order_given = False
        else:
            is_fusion_order_given = True

        self.fusion_network.es[&#39;step&#39;] = None

        # Initialize intermediate fusion network
        network = self.fusion_network.copy()
        network[&#39;p_succ&#39;] = p_succ
        network.vs[&#39;weight&#39;] = 1
        network.vs[&#39;step&#39;] = 0
        network.vs[&#39;on&#39;] = True
        network.es[&#39;weight&#39;] = 2 / p_succ
        del network.es[&#39;step&#39;]

        turn = 0

        # Iterate until no edges remain in the fusion network
        while True:
            if not network.ecount():
                break

            if is_fusion_order_given:
                enames_curr_step = [str(fusion_order[turn])]
                is_parellel = True

            elif strategy == &#39;weight&#39;:
                min_weight = min(network.es[&#39;weight&#39;])
                eids_min_weight = network.es.select(weight=min_weight)
                enames_curr_step = eids_min_weight[&#39;name&#39;]
                is_parellel = len(enames_curr_step) == 1

            # elif strategy == &#39;betweenness&#39;:
            #     eb = np.array(network.edge_betweenness())
            #     min_eb = np.min(eb)
            #     eids_curr_step = np.nonzero(eb == min_eb)[0]
            #     enames_curr_step = [network.es[eid][&#39;name&#39;] for eid in
            #     eids_curr_step]
            #     is_parellel = len(enames_curr_step) == 1
            #
            # elif strategy == &#39;weight_and_betweenness&#39;:
            #     min_weight = min(network.es[&#39;weight&#39;])
            #     eids_min_weight = network.es.select(weight=min_weight)
            #     es_min_ovh = eids_min_weight
            #
            #     eb = network.edge_betweenness()
            #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
            #     min_eb = np.min(ebs_min_ovh)
            #     enames_curr_step = [es_min_ovh[i][&#39;name&#39;] for i in
            #     np.nonzero(ebs_min_ovh == min_eb)[0]]
            #     is_parellel = len(enames_curr_step) == 1

            elif &#39;matching&#39; in strategy:
                if strategy == &#39;weight_and_matching&#39;:
                    min_weight = min(network.es[&#39;weight&#39;])
                    es_min_weight = network.es.select(weight=min_weight)
                    subnetwork = network.subgraph_edges(es_min_weight)
                else:
                    subnetwork = network

                subnetwork_nx = subnetwork.to_networkx()
                if isinstance(subnetwork_nx, nx.MultiGraph):
                    subnetwork_nx = nx.Graph(subnetwork_nx)
                matching = nx.max_weight_matching(subnetwork_nx, weight=None)
                enames_curr_step = \
                    subnetwork.es[subnetwork.get_eids(matching)][&#39;name&#39;]

                is_parellel = True

            elif strategy == &#39;random&#39;:
                enames_curr_step = [np.random.choice(network.es[&#39;name&#39;])]
                is_parellel = True

            else:
                raise ValueError

            recalculated_enames = []

            if get_fusion_order and not is_fusion_order_given:
                fusion_order_curr_step = set()
                fusion_order.append(fusion_order_curr_step)

            while True:
                if not is_parellel:
                    for rec_ename in recalculated_enames:
                        try:
                            enames_curr_step.remove(rec_ename)
                        except ValueError:
                            pass

                if not enames_curr_step:
                    break

                recalculated_enames.clear()

                if is_parellel:
                    ename_to_merge = enames_curr_step.pop()
                else:
                    ename_to_merge = np.random.choice(enames_curr_step)
                    enames_curr_step.remove(ename_to_merge)

                if get_fusion_order:
                    e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                    v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                    fusion_order_curr_step.add((v1[&#39;name&#39;], v2[&#39;name&#39;],
                                                ename_to_merge))

                enames_updated_weight = self._contract_edge(network,
                                                            ename_to_merge)

                recalculated_enames.extend(enames_updated_weight)

        v_final = network.vs.select(on=True)
        overhead = sum(v_final[&#39;weight&#39;])
        step = max(v_final[&#39;step&#39;])

        results = {
            &#39;overhead&#39;: overhead,
            &#39;step&#39;: step,
            &#39;fusion_order_strategy&#39;: strategy,
            &#39;p_succ&#39;: p_succ}

        if get_fusion_order:
            results[&#39;fusion_order&#39;] = fusion_order

        self.data.update(results)

        return self.data.copy()

    def simulate(self,
                 n_iter,
                 p_succ=0.5,
                 mp=False,
                 n_procs=None,
                 get_all_data=False,
                 get_all_graphs=False,
                 get_all_fusion_networks=False,
                 unravel=True,
                 unravel_bcs_first=&#39;random&#39;,
                 fusion_order_strategy=&#39;weight_and_matching&#39;,
                 seed=&#39;keep&#39;,
                 verbose=True,
                 pbar=False,
                 **kwargs):
        &#34;&#34;&#34;
        Execute the strategy for a fixed number of iterations and obtain the
        best one only (by default).

        Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
        `GraphState.fusion_network` are updated according to the result of the best
        sample.

        Parameters
        ----------
        n_iter : int
            Iteration number.

        p_succ : float (default: 0.5)
            Success probability of a fusion.

        mp : bool (default: False)
            Whether to use multiprocessing for the iterations. Package
            *parmap* should be installed to use it.

        n_procs : None or int (default: None)
            Maximal number of simultaneous processes for multiprocessing.&lt;br&gt;
            If it is `None`, the number of CPUs is used. Ignored when `mp` is
            `False`.

        get_all_data : bool (default: False)
            Whether to obtain the data (overheads, numbers of steps, etc.) from
            all samples or only the best sample.

        get_all_graphs : bool (default: False)
            Whether to obtain the unraveled graphs from all samples or only the
            best sample.

        get_all_fusion_networks : bool (default: False)
            Whether to obtain the fusion networks from all samples or only the
            best sample.

        unravel : bool (default: True)
            Whether to unravel the graph or not.

        unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
            - `True`: BCSs are unraveled first, then clqiues are unraveled.
            - `False`, cliques are unraveled first, then BCSs are unraveled.
            - `&#39;random&#39;`, the order is randomly chosen.

        fusion_order_strategy : one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: `weight_and_matching&#39;)
            Strategy for determining the edge to contract in each step.

            - `&#39;weight&#39;`: Contract a random one among the edges with the
            smallest weight.
            - `&#39;matching&#39;`: Contract an edge in a maximum matching.
            - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
            of the subgraph of the intermediate fusion network induced by
            the edges with the smallest weight.
            - `&#39;random&#39;`: Contract a random edge.

        seed : &#39;keep&#39; or None or int (default: &#39;keep&#39;)
            Random seed.

            - `&#39;keep&#39;`: The seed is not initialized.
            - `None`: The current time is used as the random seed.
            - `int`: The given number is used as the random seed.

        verbose : bool (default: True)
            Whether to print logs.

        pbar : bool (default: False)
            Whether to show a progress bar.&lt;br&gt;
            Ignored if `mp` is `False`

        kwargs : dict
            Additional keyword arguments for calculating overheads.&lt;br&gt;
            See the description of `GraphState.calculate_overhead()`.

        Returns
        -------
        res : dict
            Result of the iterations.&lt;br&gt;
            By default, only the information of the best sample is given.
        &#34;&#34;&#34;

        t0 = time.time()

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        if mp:
            if n_procs is None:
                n_procs = os.cpu_count()
            mp = mp and n_iter &gt;= n_procs

        if not mp:
            if verbose:
                print(&#34;Multiprocessing OFF.&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}...&#34;)

            if n_iter == 1 and seed is not None and seed != &#39;keep&#39;:
                seeds_samples = [seed]
            else:
                seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

            overheads = [] if get_all_data else None
            steps = [] if get_all_data else None
            seeds = [] if get_all_data else None
            unravalled_graphs = [] if get_all_graphs else None
            fusion_networks = [] if get_all_fusion_networks else None

            best_sample = None
            lowest_overhead = None
            for i_sample in range(n_iter):
                seed_sample = seeds_samples[i_sample]
                np.random.seed(seed_sample)

                if unravel:
                    self.unraveled_graph = None
                    try:
                        self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                    except:
                        print(&#39;Error occurs during unraveling&#39;)
                        print(&#39;seed =&#39;, seed_sample)
                        raise ValueError

                try:
                    self.build_fusion_network(use_unraveled_graph=unravel)
                except:
                    print(&#39;Error occurs during building fusion network&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                try:
                    data_now = self.calculate_overhead(p_succ=p_succ,
                                                       strategy=fusion_order_strategy,
                                                       **kwargs)
                except:
                    print(&#39;Error occurs during calculating overhead&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

                overhead_now = data_now[&#39;overhead&#39;]
                step_now = data_now[&#39;step&#39;]
                self.data[&#39;seed&#39;] = seed_sample

                if lowest_overhead is None or overhead_now &lt; lowest_overhead:
                    best_sample = i_sample
                    lowest_overhead = overhead_now
                    best_ogs = self.copy()

                if get_all_data:
                    overheads.append(overhead_now)
                    steps.append(step_now)
                    seeds.append(seed_sample)

                if get_all_graphs:
                    unravalled_graphs.append(self.unraveled_graph)

                if get_all_fusion_networks:
                    fusion_networks.append(self.fusion_network)

            res = {
                &#39;best_overhead&#39;: best_ogs.data[&#39;overhead&#39;],
                &#39;best_step&#39;: best_ogs.data[&#39;step&#39;],
                &#39;best_seed&#39;: best_ogs.data[&#39;seed&#39;],
                &#39;n_iter&#39;: n_iter}

            if unravel:
                res[&#39;unravel_bcs_first&#39;] = best_ogs.data[&#39;unravel_bcs_first&#39;]

            if get_all_data or get_all_graphs or get_all_fusion_networks:
                res[&#39;best_sample&#39;] = best_sample

                if get_all_data:
                    res[&#39;overheads&#39;] = overheads
                    res[&#39;steps&#39;] = steps
                    res[&#39;seeds&#39;] = seeds

                if get_all_graphs:
                    res[&#39;unraveled_graphs&#39;] = unravalled_graphs

                if get_all_fusion_networks:
                    res[&#39;fusion_networks&#39;] = fusion_networks

        else:
            if &#39;parmap&#39; not in sys.modules:
                raise ModuleNotFoundError(&#34;Package parmap is not installed.&#34;)

            if verbose:
                print(f&#34;Multiprocessing ON: n_procs = {n_procs}&#34;)
                print(f&#34;Calculating for n_iter = {n_iter}... &#34;, end=&#39;&#39;)

            additional_keys = []
            if get_all_data:
                additional_keys.extend([&#39;overheads&#39;, &#39;steps&#39;, &#39;seeds&#39;])
            if get_all_graphs:
                additional_keys.append(&#39;unraveled_graphs&#39;)
            if get_all_fusion_networks:
                additional_keys.append(&#39;fusion_networks&#39;)

            left = n_iter % n_procs
            ns_samples = [n_iter // n_procs] * n_procs
            for i in range(left):
                ns_samples[i] += 1

            seeds = np.random.randint(0, _max_seed(), size=n_procs)

            res_procs = parmap.starmap(_simulate_single,
                                       list(zip(ns_samples, seeds)),
                                       self.graph,
                                       p_succ=p_succ,
                                       get_all_data=get_all_data,
                                       get_all_graphs=get_all_graphs,
                                       get_all_fusion_networks=get_all_fusion_networks,
                                       unravel=unravel,
                                       unravel_bcs_first=unravel_bcs_first,
                                       fusion_order_strategy=fusion_order_strategy,
                                       pm_pbar=pbar,
                                       **kwargs)
            best_overheads = [res_each[&#39;best_overhead&#39;] for res_each in
                              res_procs]
            best_proc = np.argmin(best_overheads)
            res = res_procs[best_proc]
            res[&#39;n_iter&#39;] = n_iter
            best_ogs = res[&#39;best_ogs&#39;]
            del res[&#39;best_ogs&#39;]

            if additional_keys:
                res[&#39;best_sample&#39;] += sum(ns_samples[:best_proc])

            for key in additional_keys:
                vals = [res_each[key] for res_each in res_procs]
                res[key] = list(itertools.chain(*vals))

        if verbose:
            print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} &#34;
                  f&#34;({time.time() - t0:.2f} s)&#34;)

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.unraveled_bcss = best_ogs.unraveled_bcss
        self.unraveled_cliques = best_ogs.unraveled_cliques
        self.data = best_ogs.data

        return res

    def simulate_adaptive(self,
                          init_n_iter,
                          mul=2,
                          p_succ=0.5,
                          mp=False,
                          n_procs=None,
                          get_all_data=False,
                          get_all_graphs=False,
                          get_all_fusion_networks=False,
                          unravel=True,
                          unravel_bcs_first=&#39;random&#39;,
                          fusion_order_strategy=&#39;weight_and_matching&#39;,
                          seed=&#39;keep&#39;,
                          verbose=True,
                          pbar=False,
                          **kwargs):
        &#34;&#34;&#34;
        Run the adaptive iteration method for the strategy and obtain the
        best one only (by default).

        The adaptive iteration method looks for the best iteration while
        keeps increasing the iteration number until a certain condition
        meets. In detail, denoting N iterations of the strategy as R(N),
        R(`init_n_iter`) is first executed and `q0` is obtained which is the
        lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
        and `q1` is obtained similarly. If `q0 &lt;= q1`, `q0` is returned. If
        otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
        If `q1 &lt;= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
        is executed, and so on.

        Parameters
        ----------
        init_n_iter : int
            Initial iteration number.

        mul : int (default: 2)
            Multiplicative factor of the iteration number.

        See the description of `GraphState.simulate()` for the other parameters.

        Returns
        -------
        res : dict
            Result of the iterations.&lt;br&gt;
            By default, only the information of the best sample is given.
        &#34;&#34;&#34;

        if mp and n_procs is None:
            n_procs = os.cpu_count()

        if seed != &#39;keep&#39;:
            np.random.seed(seed)

        additional_keys = []
        if get_all_data:
            additional_keys.extend([&#39;overheads&#39;, &#39;steps&#39;])
        if get_all_graphs:
            additional_keys.append(&#39;unraveled_graphs&#39;)
        if get_all_fusion_networks:
            additional_keys.append(&#39;fusion_networks&#39;)

        if verbose:
            if mp:
                print(f&#34;Multiprocessing (n_procs = {n_procs})&#34;)
            else:
                print(&#34;No multiprocessing&#34;)

        n_iter_history = []
        n_iter_now = init_n_iter
        res = None
        while True:
            if verbose:
                print(f&#34;Calculating for n_iter = {n_iter_now}... &#34;, end=&#39;&#39;)
            t0 = time.time()

            n_iter_history.append(n_iter_now)
            res_now = self.simulate(n_iter=n_iter_now,
                                    p_succ=p_succ,
                                    mp=mp,
                                    n_procs=n_procs,
                                    get_all_data=get_all_data,
                                    get_all_graphs=get_all_graphs,
                                    get_all_fusion_networks=get_all_fusion_networks,
                                    unravel=unravel,
                                    unravel_bcs_first=unravel_bcs_first,
                                    fusion_order_strategy=fusion_order_strategy,
                                    verbose=False,
                                    pbar=pbar,
                                    **kwargs)

            if res is None:
                res = res_now
                best_ogs = self.copy()
                n_iter_now *= mul

            else:
                for key in additional_keys:
                    res[key].extend(res_now[key])

                if res_now[&#39;best_overhead&#39;] &lt; res[&#39;best_overhead&#39;]:
                    for key in additional_keys:
                        res_now[key] = res[key]
                    res = res_now
                    best_ogs = self.copy()

                    n_iter_now *= mul

                else:
                    if verbose:
                        print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} (&#34;
                              f&#34;{time.time() - t0:.2f} s)&#34;)
                    break

            if verbose:
                print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} &#34;
                      f&#34;({time.time() - t0:.2f} s)&#34;)

        res[&#39;n_iter&#39;] = sum(n_iter_history)

        if additional_keys:
            res[&#39;best_sample&#39;] += res[&#39;best_sample&#39;]

        self.unraveled_graph = best_ogs.unraveled_graph
        self.fusion_network = best_ogs.fusion_network
        self.unraveled_bcss = best_ogs.unraveled_bcss
        self.unraveled_cliques = best_ogs.unraveled_cliques
        self.data = best_ogs.data

        return res

    def _get_graph(self, graph):
        if isinstance(graph, ig.Graph):
            return graph

        if graph == &#39;graph&#39;:
            return self.graph
        elif graph in [&#39;unraveled&#39;, &#39;unraveled_graph&#39;]:
            if self.unraveled_graph is None:
                raise ValueError(&#39;No unraveled graph created.&#39;)
            return self.unraveled_graph
        elif graph in [&#39;network&#39;, &#39;fusion_network&#39;]:
            if self.fusion_network is None:
                raise ValueError(&#39;No fusion network created&#39;)
            return self.fusion_network
        else:
            raise ValueError(&#39;Wrong input.&#39;)

    def group_links_by_steps(self):
        &#34;&#34;&#34;
        Get all the links grouped by their fusion steps.

        Returns
        -------
        group : dict
            `group[i]` (for `i` = 1, 2, ...) is the list of the connected pairs
            of nodes in the `i`-th step.
        &#34;&#34;&#34;
        network = self.fusion_network
        if not isinstance(network, ig.Graph):
            raise ValueError(&#39;No fusion network created&#39;)

        group = {}
        i = 1
        while True:
            es = network.es.select(step=i)
            if len(es) == 0:
                break
            node_pairs = []
            for e in es:
                node_pairs.append((e.source_vertex[&#39;name&#39;],
                                   e.target_vertex[&#39;name&#39;]))
            group[i] = node_pairs
            i += 1

        return group

    def plot_graph(self, unraveled=False, **kwargs):
        &#34;&#34;&#34;
        Plot the original or unraveled graph.

        If the unraveled graph is plotted, edges in the unraveled graph are
        drawn as black solid lines while external fusions are drawn as red
        dashed lines (by default).

        Parameters
        ----------
        unraveled : bool (default: False)
            Whether to plot the unraveled graph or the original graph.

        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.&lt;br&gt;
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (7, 7))
            Size of the figure in inches.

        show_vertex_name : bool (default: True)
            Whether to show vertex names.

        vertex_color_normal : str (default: &#39;white&#39;)
            Color of vertices without Clifford operations.

        vertex_color_clifford : str (default: &#39;orange&#39;)
            Color of vertices with Clifford operations.

        vertices_to_highlight : None or list of {str or int} (default: None)
            Name of vertices to highlight.

        vertex_color_highlight : str (default: purple)
            Color of the highlighted vertices.&lt;br&gt;
            Ignored if `vertices_to_highlight` is `None`.

        edge_color_normal : str (default: black)
            Color of edges in the graph.

        edge_color_fusion : str (default: red)
            Color of lines for external fusions.&lt;br&gt;
            Ignored if `unraveled` is `False`.

        edge_style_fusion : str (default: &#39;--&#39;)
            Style of lines for external fusions.

        Any other keyword arguments in `igraph.plot()` can be directly used.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
        If they are given, they override the above parameters.

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        graph = self.unraveled_graph if unraveled else self.graph
        if graph is None:
            raise ValueError(&#34;No unraveled graph created.&#34;)

        fig, ax = plot_graph(graph, **kwargs)

        return fig, ax

    def plot_fusion_network(self, **kwargs):
        &#34;&#34;&#34;
        Plot the fusion network.

        Parameters
        ----------
        ax : None or matplotlib Axes object (default: None)
            If given, the figure is plotted on the given `Axes` object.

        layout : str (default: &#39;auto&#39;)
            Layout algorithm for plotting.&lt;br&gt;
            See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

        figsize : 2-tuple of float (default: (7, 7))
            Size of the figure in inches.

        show_node_name : bool (default: True)
            Whether to show node names.

        node_color_normal : str (default: &#39;white&#39;)
            Color of nodes without Clifford operations.

        node_color_clifford : str (default: &#39;orange&#39;)
            Color of nodes with Clifford operations.

        show_link_name : bool (default: False)
            Whether to show link names.

        show_fusion_order : bool (default: True)
            Whether to show fusion orders on links.&lt;br&gt;
            If both `show_link_name` and `show_fusion_order` are `True`,
            it is shown as `&#39;{link name}-{fusion order}&#39;`

        uniform_link_style : bool (default: False)
            Whether to use uniform link colors/styles or not.
            If it is `False`, links of different types (leaf-to-leaf,
            root-to-leaf, root-to-root) are drawn in different colors and
            linestyles. Specifically, root-to-leaf links are drawn as lines
            with arrows.

        link_color_ll : str (default: &#39;black&#39;)
            Color of links of &#39;leaf-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_color_rl : str (default: &#39;blue&#39;)
            Color of links of &#39;root-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_color_rr : str (default: &#39;red&#39;)
            Color of links of &#39;root-to-root&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_style_ll : str (default: &#39;-&#39;)
            Style of links of &#39;leaf-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_style_rl : str (default: &#39;-&#39;)
            Style of links of &#39;root-to-leaf&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        link_style_rr : str (default: &#39;--&#39;)
            Style of links of &#39;root-to-root&#39; type.&lt;br&gt;
            Ignored if `uniform_link_style` is `True`

        Any other keyword arguments in igraph.plot can be directly used.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
        If they are given, they override the above parameters.&lt;br&gt;

        Returns
        -------
        fig, ax : matplotlib Figure and Axes object.
        &#34;&#34;&#34;

        network = self.fusion_network
        if network is None:
            raise ValueError(&#39;No fusion network created.&#39;)

        fig, ax = plot_fusion_network(network, **kwargs)

        return fig, ax

    def copy(self):
        &#34;&#34;&#34;
        Return a **shallow** copy of this object.

        Returns
        -------
        copy : GraphState
            Copied instance of itself.
        &#34;&#34;&#34;

        copy = GraphState(graph=self.graph,
                          unraveled_graph=self.unraveled_graph,
                          fusion_network=self.fusion_network)

        copy.unraveled_bcss = self.unraveled_bcss
        copy.unraveled_cliques = self.unraveled_cliques
        copy.data = self.data.copy()
        if self.graph_info is not None:
            copy.graph_info = self.graph_info.copy()

        return copy</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="optgraphstate.GraphState.data"><code class="name">var <span class="ident">data</span> :¬†dict</code></dt>
<dd>
<div class="desc"><p>Any data obtained during unraveling the graph, constructing the fusion network, and calculating the resource overhead.</p></div>
</dd>
<dt id="optgraphstate.GraphState.fusion_network"><code class="name">var <span class="ident">fusion_network</span> :¬†igraph.Graph</code></dt>
<dd>
<div class="desc"><p>Fuson network constructed from the unraveled graph (in <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code>) or the original graph (in <code><a title="optgraphstate.GraphState.graph" href="#optgraphstate.GraphState.graph">GraphState.graph</a></code>). It is <code>None</code> before the fusion network is created.</p></div>
</dd>
<dt id="optgraphstate.GraphState.graph"><code class="name">var <span class="ident">graph</span> :¬†igraph.Graph</code></dt>
<dd>
<div class="desc"><p>Graph of the graph state to investigate.</p></div>
</dd>
<dt id="optgraphstate.GraphState.graph_info"><code class="name">var <span class="ident">graph_info</span> :¬†set</code></dt>
<dd>
<div class="desc"><p>Information of the graph in <code><a title="optgraphstate.GraphState.graph" href="#optgraphstate.GraphState.graph">GraphState.graph</a></code>. It is not empty only when the graph is initialized by using the parameters <code>shape</code> and <code>prms</code>.</p></div>
</dd>
<dt id="optgraphstate.GraphState.unraveled_bcss"><code class="name">var <span class="ident">unraveled_bcss</span> :¬†set</code></dt>
<dd>
<div class="desc"><p>Unraveled bipartitely-complete subgraphs (BCSs). It is empty before unraveling the graph.</p></div>
</dd>
<dt id="optgraphstate.GraphState.unraveled_cliques"><code class="name">var <span class="ident">unraveled_cliques</span> :¬†set</code></dt>
<dd>
<div class="desc"><p>Unraveled cliques. It is empty before unraveling the graph.</p></div>
</dd>
<dt id="optgraphstate.GraphState.unraveled_graph"><code class="name">var <span class="ident">unraveled_graph</span> :¬†igraph.Graph</code></dt>
<dd>
<div class="desc"><p>Unraveled graph generated by unraveling the original graph (in <code><a title="optgraphstate.GraphState.graph" href="#optgraphstate.GraphState.graph">GraphState.graph</a></code>). It is <code>None</code> before the unraveled graph is created.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optgraphstate.GraphState.build_fusion_network"><code class="name flex">
<span>def <span class="ident">build_fusion_network</span></span>(<span>self, use_unraveled_graph=True, plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Build a fusion network from the graph.</p>
<p>The constructed fusion network is saved in <code><a title="optgraphstate.GraphState.fusion_network" href="#optgraphstate.GraphState.fusion_network">GraphState.fusion_network</a></code> as
<code>igraph.Graph</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>use_unraveled_graph</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to use the unraveled graph (in <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code>) or
the original graph (in <code><a title="optgraphstate.GraphState.graph" href="#optgraphstate.GraphState.graph">GraphState.graph</a></code>) for building a fusion network.</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to plot the fusion network after building it.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_fusion_network(self,
                         use_unraveled_graph=True,
                         plot=False,
                         verbose=False):
    &#34;&#34;&#34;
    Build a fusion network from the graph.

    The constructed fusion network is saved in `GraphState.fusion_network` as
    `igraph.Graph`.

    Parameters
    ----------
    use_unraveled_graph : bool (default: True)
        Whether to use the unraveled graph (in `GraphState.unraveled_graph`) or
        the original graph (in `GraphState.graph`) for building a fusion network.

    plot : bool (default: False)
        Whether to plot the fusion network after building it.

    verbose : bool (default: False)
        Whether to print logs.
    &#34;&#34;&#34;

    graph = self.unraveled_graph if use_unraveled_graph else self.graph
    if graph is None:
        raise ValueError(&#34;No unraveled qubit graph created.&#34;)

    # Fusion network
    network = ig.Graph()
    self.fusion_network = network
    nodes_corr = {}

    # Links inside star graphs
    for v in graph.vs:
        num_internal_nodes = v.degree() - 1
        vname_xrot = v[&#39;name&#39;]
        if num_internal_nodes &gt;= 1:

            # Add nodes
            nid_init = network.vcount()
            seed = np.random.randint(0, num_internal_nodes)
            node_names = [vname_xrot if i == 0 else f&#39;{vname_xrot}-{i}&#39; for
                          i in itertools.chain(range(seed, -1, -1),
                                               range(seed + 1,
                                                     num_internal_nodes))]
            attr = {
                &#39;name&#39;: node_names,
                &#39;seed&#39;: [True if i == seed else False for i in
                         range(num_internal_nodes)],
                &#39;clifford_root&#39;: None,
                # Clifford gate applied on the root qubit
                &#39;clifford_leaves&#39;: None
                # Clifford gate applied on the leaf qubits
            }
            network.add_vertices(num_internal_nodes, attributes=attr)
            nodes_corr[vname_xrot] = network.vs[
                                     nid_init:nid_init + num_internal_nodes]

            if num_internal_nodes &gt;= 2:
                # Connect internal links
                links = [(nid, nid + 1) for nid in range(nid_init,
                                                         nid_init + num_internal_nodes - 1)]
                attr = {  # One of RR, RL, and LL, which respectively means
                    # that a fusion is performed on two roots,
                    # one root and one leaf, and two leaves of GHZ-3
                    # states.
                    &#39;kind&#39;: &#34;RL&#34;,  # Root node name, if kind == &#39;RL&#39;
                    &#39;root_node&#39;: [
                        node_names[i + 1] if i &lt; seed else node_names[i]
                        for i in range(num_internal_nodes - 1)]}
                network.add_edges(links, attributes=attr)

    # Links between star graphs
    for e in graph.es:
        vs = [e.source_vertex, e.target_vertex]
        deg_vs = graph.degree(vs)

        if deg_vs[0] &gt; 1 and deg_vs[1] &gt; 1:
            nodes_to_connect = []
            for v in vs:
                vname = v[&#39;name&#39;]
                nodes = nodes_corr[
                    vname].select(lambda node: node.degree() &lt; (
                    2 if node[&#39;seed&#39;] else 3))
                nodes_to_connect.append(np.random.choice(nodes))
            network.add_edge(*nodes_to_connect,
                             kind=&#39;LL&#39;,
                             root_node=None, )

    if verbose:
        print(&#34;Fusion network of the unraveled graph:&#34;)
        self.plot_fusion_network()
        plt.show()

    # Set of seed node names where root vertices are connected by
    # external fusions.
    root_connected = set()
    is_node_not_full = lambda node: node.degree() &lt; (
        2 if node[&#39;seed&#39;] and (node[&#39;name&#39;] not in root_connected) else 3)

    def get_nodes_containing_vertex(vname):
        try:
            node = nodes_corr[vname].find(name=vname)
            root = True
        except KeyError:
            root_name = graph.vs[graph.neighbors(vname)[0]][&#39;name&#39;]
            nodes = nodes_corr[root_name].select(is_node_not_full)
            node = np.random.choice(nodes)
            root = False

        return node, root

    # Clifford operations
    vs_attrs = graph.vs.attributes()
    if &#39;clifford&#39; in vs_attrs:
        for v_cl in graph.vs.select(clifford_ne=None):
            vname = v_cl[&#39;name&#39;]
            node, root = get_nodes_containing_vertex(vname)
            cl = v_cl[&#39;clifford&#39;]

            if root:
                node[&#39;clifford_root&#39;] = cl

            else:
                key = v_cl[&#39;ext_fusion&#39;]
                if key is None:
                    key = f&#39;final_{v_cl[&#34;name&#34;]}&#39;

                clifford_leaves = node[&#39;clifford_leaves&#39;]
                try:
                    clifford_leaves[key] = cl
                except TypeError:
                    node[&#39;clifford_leaves&#39;] = {key: cl}

    if verbose:
        print(&#34;Apply Clifford operations:&#34;)
        self.plot_fusion_network()
        plt.show()

    # Links by external fusions
    if &#39;ext_fusion&#39; in vs_attrs:
        done = set()
        for v1 in graph.vs.select(ext_fusion_ne=None):

            vname1 = v1[&#39;name&#39;]
            if vname1 in done:
                continue
            vname2 = v1[&#39;ext_fusion&#39;]
            done.add(vname2)

            node1, root1 = get_nodes_containing_vertex(vname1)
            node2, root2 = get_nodes_containing_vertex(vname2)
            if root1 and root2:
                kind = &#39;RR&#39;
                root_node = None
                root_connected.add(node1[&#39;name&#39;])
                root_connected.add(node2[&#39;name&#39;])
            elif not root1 and not root2:
                kind = &#39;LL&#39;
                root_node = None
            else:
                kind = &#39;RL&#39;
                root_node = node1[&#39;name&#39;] if root1 else node2[&#39;name&#39;]
                root_connected.add(root_node)
            network.add_edge(node1, node2, kind=kind, root_node=root_node)

    network.es[&#39;name&#39;] = [str(eid) for eid in range(network.ecount())]

    self.fusion_network = network

    if plot:
        print(&#34;Final:&#34;)
        self.plot_fusion_network()
        plt.show()</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.calculate_overhead"><code class="name flex">
<span>def <span class="ident">calculate_overhead</span></span>(<span>self, p_succ=0.5, strategy='weight_and_matching', fusion_order=None, get_fusion_order=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the resource overhead from the fusion network.</p>
<p>The resulting data is saved in <code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">GraphState.data</a></code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>p_succ</code></strong> :&ensp;<code>float (default: 0.5)</code></dt>
<dd>Success probability of a fusion.</dd>
<dt><strong><code>strategy</code></strong> :&ensp;<code>str, one</code> of <code>['weight', 'matching', 'weight_and_matching', 'random'] (default: 'weight_and_matching')</code></dt>
<dd>
<p>Strategy for determining the edge to contract in each step.</p>
<ul>
<li><code>'weight'</code>: Contract a random one among the edges with the
smallest weight.</li>
<li><code>'matching'</code>: Contract an edge in a maximum matching.</li>
<li><code>'weight_and_matching'</code>: Contract an edge in a maximum matching
of the subgraph of the intermediate fusion network induced by
the edges with the smallest weight.</li>
<li><code>'random'</code>: Contract a random edge.</li>
</ul>
</dd>
<dt><strong><code>fusion_order</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>{int</code> or <code>str} (default: None)</code></dt>
<dd>Fusion order given explicitly as vertex names.<br>
If it is not <code>None</code>, parameter <code>strategy</code> is ignored.</dd>
<dt><strong><code>get_fusion_order</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to include the determined fusion order in the returned
data.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Outcomes of the calculation, which is a shallow copy of
<code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">GraphState.data</a></code>.<br>
The calculated overhead and number of steps can be obtained from
<code>data['overhead']</code> and <code>data['step']</code>, respectively.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_overhead(self,
                       p_succ=0.5,
                       strategy=&#39;weight_and_matching&#39;,
                       fusion_order=None,
                       get_fusion_order=False, ):
    &#34;&#34;&#34;
    Calculate the resource overhead from the fusion network.

    The resulting data is saved in `GraphState.data`.

    Parameters
    ----------
    p_succ : float (default: 0.5)
        Success probability of a fusion.

    strategy: str, one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: &#39;weight_and_matching&#39;)
        Strategy for determining the edge to contract in each step.

        - `&#39;weight&#39;`: Contract a random one among the edges with the
        smallest weight.
        - `&#39;matching&#39;`: Contract an edge in a maximum matching.
        - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
        of the subgraph of the intermediate fusion network induced by
        the edges with the smallest weight.
        - `&#39;random&#39;`: Contract a random edge.

    fusion_order : None or list of {int or str} (default: None)
        Fusion order given explicitly as vertex names.&lt;br&gt;
        If it is not `None`, parameter `strategy` is ignored.

    get_fusion_order : bool (default: False)
        Whether to include the determined fusion order in the returned
        data.

    Returns
    -------
    data : dict
        Outcomes of the calculation, which is a shallow copy of
        `GraphState.data`.&lt;br&gt;
        The calculated overhead and number of steps can be obtained from
        `data[&#39;overhead&#39;]` and `data[&#39;step&#39;]`, respectively.
    &#34;&#34;&#34;

    if self.fusion_network is None:
        raise ValueError(&#34;No fusion network created&#34;)

    # Trivial cases
    node_num = self.fusion_network.vcount()
    if node_num == 0:
        self.data[&#39;overhead&#39;] = 0
        self.data[&#39;step&#39;] = 0
        return self.data
    elif node_num == 1:
        self.data[&#39;overhead&#39;] = 1
        self.data[&#39;step&#39;] = 0
        return self.data

    if fusion_order is None:
        fusion_order = []
        is_fusion_order_given = False
    else:
        is_fusion_order_given = True

    self.fusion_network.es[&#39;step&#39;] = None

    # Initialize intermediate fusion network
    network = self.fusion_network.copy()
    network[&#39;p_succ&#39;] = p_succ
    network.vs[&#39;weight&#39;] = 1
    network.vs[&#39;step&#39;] = 0
    network.vs[&#39;on&#39;] = True
    network.es[&#39;weight&#39;] = 2 / p_succ
    del network.es[&#39;step&#39;]

    turn = 0

    # Iterate until no edges remain in the fusion network
    while True:
        if not network.ecount():
            break

        if is_fusion_order_given:
            enames_curr_step = [str(fusion_order[turn])]
            is_parellel = True

        elif strategy == &#39;weight&#39;:
            min_weight = min(network.es[&#39;weight&#39;])
            eids_min_weight = network.es.select(weight=min_weight)
            enames_curr_step = eids_min_weight[&#39;name&#39;]
            is_parellel = len(enames_curr_step) == 1

        # elif strategy == &#39;betweenness&#39;:
        #     eb = np.array(network.edge_betweenness())
        #     min_eb = np.min(eb)
        #     eids_curr_step = np.nonzero(eb == min_eb)[0]
        #     enames_curr_step = [network.es[eid][&#39;name&#39;] for eid in
        #     eids_curr_step]
        #     is_parellel = len(enames_curr_step) == 1
        #
        # elif strategy == &#39;weight_and_betweenness&#39;:
        #     min_weight = min(network.es[&#39;weight&#39;])
        #     eids_min_weight = network.es.select(weight=min_weight)
        #     es_min_ovh = eids_min_weight
        #
        #     eb = network.edge_betweenness()
        #     ebs_min_ovh = np.array([eb[e.index] for e in es_min_ovh])
        #     min_eb = np.min(ebs_min_ovh)
        #     enames_curr_step = [es_min_ovh[i][&#39;name&#39;] for i in
        #     np.nonzero(ebs_min_ovh == min_eb)[0]]
        #     is_parellel = len(enames_curr_step) == 1

        elif &#39;matching&#39; in strategy:
            if strategy == &#39;weight_and_matching&#39;:
                min_weight = min(network.es[&#39;weight&#39;])
                es_min_weight = network.es.select(weight=min_weight)
                subnetwork = network.subgraph_edges(es_min_weight)
            else:
                subnetwork = network

            subnetwork_nx = subnetwork.to_networkx()
            if isinstance(subnetwork_nx, nx.MultiGraph):
                subnetwork_nx = nx.Graph(subnetwork_nx)
            matching = nx.max_weight_matching(subnetwork_nx, weight=None)
            enames_curr_step = \
                subnetwork.es[subnetwork.get_eids(matching)][&#39;name&#39;]

            is_parellel = True

        elif strategy == &#39;random&#39;:
            enames_curr_step = [np.random.choice(network.es[&#39;name&#39;])]
            is_parellel = True

        else:
            raise ValueError

        recalculated_enames = []

        if get_fusion_order and not is_fusion_order_given:
            fusion_order_curr_step = set()
            fusion_order.append(fusion_order_curr_step)

        while True:
            if not is_parellel:
                for rec_ename in recalculated_enames:
                    try:
                        enames_curr_step.remove(rec_ename)
                    except ValueError:
                        pass

            if not enames_curr_step:
                break

            recalculated_enames.clear()

            if is_parellel:
                ename_to_merge = enames_curr_step.pop()
            else:
                ename_to_merge = np.random.choice(enames_curr_step)
                enames_curr_step.remove(ename_to_merge)

            if get_fusion_order:
                e_to_merge = self.fusion_network.es.find(name=ename_to_merge)
                v1, v2 = e_to_merge.source_vertex, e_to_merge.target_vertex
                fusion_order_curr_step.add((v1[&#39;name&#39;], v2[&#39;name&#39;],
                                            ename_to_merge))

            enames_updated_weight = self._contract_edge(network,
                                                        ename_to_merge)

            recalculated_enames.extend(enames_updated_weight)

    v_final = network.vs.select(on=True)
    overhead = sum(v_final[&#39;weight&#39;])
    step = max(v_final[&#39;step&#39;])

    results = {
        &#39;overhead&#39;: overhead,
        &#39;step&#39;: step,
        &#39;fusion_order_strategy&#39;: strategy,
        &#39;p_succ&#39;: p_succ}

    if get_fusion_order:
        results[&#39;fusion_order&#39;] = fusion_order

    self.data.update(results)

    return self.data.copy()</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a <strong>shallow</strong> copy of this object.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>copy</code></strong> :&ensp;<code><a title="optgraphstate.GraphState" href="#optgraphstate.GraphState">GraphState</a></code></dt>
<dd>Copied instance of itself.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;
    Return a **shallow** copy of this object.

    Returns
    -------
    copy : GraphState
        Copied instance of itself.
    &#34;&#34;&#34;

    copy = GraphState(graph=self.graph,
                      unraveled_graph=self.unraveled_graph,
                      fusion_network=self.fusion_network)

    copy.unraveled_bcss = self.unraveled_bcss
    copy.unraveled_cliques = self.unraveled_cliques
    copy.data = self.data.copy()
    if self.graph_info is not None:
        copy.graph_info = self.graph_info.copy()

    return copy</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.group_links_by_steps"><code class="name flex">
<span>def <span class="ident">group_links_by_steps</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get all the links grouped by their fusion steps.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>group</code></strong> :&ensp;<code>dict</code></dt>
<dd><code>group[i]</code> (for <code>i</code> = 1, 2, &hellip;) is the list of the connected pairs
of nodes in the <code>i</code>-th step.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def group_links_by_steps(self):
    &#34;&#34;&#34;
    Get all the links grouped by their fusion steps.

    Returns
    -------
    group : dict
        `group[i]` (for `i` = 1, 2, ...) is the list of the connected pairs
        of nodes in the `i`-th step.
    &#34;&#34;&#34;
    network = self.fusion_network
    if not isinstance(network, ig.Graph):
        raise ValueError(&#39;No fusion network created&#39;)

    group = {}
    i = 1
    while True:
        es = network.es.select(step=i)
        if len(es) == 0:
            break
        node_pairs = []
        for e in es:
            node_pairs.append((e.source_vertex[&#39;name&#39;],
                               e.target_vertex[&#39;name&#39;]))
        group[i] = node_pairs
        i += 1

    return group</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the created unraveled graph and fusion network and the
calculation data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self):
    &#34;&#34;&#34;
    Initialize the created unraveled graph and fusion network and the
    calculation data.
    &#34;&#34;&#34;
    self.unraveled_graph = None
    self.fusion_network = None
    self.unraveled_bcss = set()
    self.unraveled_cliques = set()
    self.data = {}</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.plot_fusion_network"><code class="name flex">
<span>def <span class="ident">plot_fusion_network</span></span>(<span>self, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the fusion network.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ax</code></strong> :&ensp;<code>None</code> or <code>matplotlib Axes object (default: None)</code></dt>
<dd>If given, the figure is plotted on the given <code>Axes</code> object.</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>str (default: 'auto')</code></dt>
<dd>Layout algorithm for plotting.<br>
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a></dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>2-tuple</code> of <code>float (default: (7, 7))</code></dt>
<dd>Size of the figure in inches.</dd>
<dt><strong><code>show_node_name</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to show node names.</dd>
<dt><strong><code>node_color_normal</code></strong> :&ensp;<code>str (default: 'white')</code></dt>
<dd>Color of nodes without Clifford operations.</dd>
<dt><strong><code>node_color_clifford</code></strong> :&ensp;<code>str (default: 'orange')</code></dt>
<dd>Color of nodes with Clifford operations.</dd>
<dt><strong><code>show_link_name</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to show link names.</dd>
<dt><strong><code>show_fusion_order</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to show fusion orders on links.<br>
If both <code>show_link_name</code> and <code>show_fusion_order</code> are <code>True</code>,
it is shown as <code>'{link name}-{fusion order}'</code></dd>
<dt><strong><code>uniform_link_style</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to use uniform link colors/styles or not.
If it is <code>False</code>, links of different types (leaf-to-leaf,
root-to-leaf, root-to-root) are drawn in different colors and
linestyles. Specifically, root-to-leaf links are drawn as lines
with arrows.</dd>
<dt><strong><code>link_color_ll</code></strong> :&ensp;<code>str (default: 'black')</code></dt>
<dd>Color of links of 'leaf-to-leaf' type.<br>
Ignored if <code>uniform_link_style</code> is <code>True</code></dd>
<dt><strong><code>link_color_rl</code></strong> :&ensp;<code>str (default: 'blue')</code></dt>
<dd>Color of links of 'root-to-leaf' type.<br>
Ignored if <code>uniform_link_style</code> is <code>True</code></dd>
<dt><strong><code>link_color_rr</code></strong> :&ensp;<code>str (default: 'red')</code></dt>
<dd>Color of links of 'root-to-root' type.<br>
Ignored if <code>uniform_link_style</code> is <code>True</code></dd>
<dt><strong><code>link_style_ll</code></strong> :&ensp;<code>str (default: '-')</code></dt>
<dd>Style of links of 'leaf-to-leaf' type.<br>
Ignored if <code>uniform_link_style</code> is <code>True</code></dd>
<dt><strong><code>link_style_rl</code></strong> :&ensp;<code>str (default: '-')</code></dt>
<dd>Style of links of 'root-to-leaf' type.<br>
Ignored if <code>uniform_link_style</code> is <code>True</code></dd>
<dt><strong><code>link_style_rr</code></strong> :&ensp;<code>str (default: '--')</code></dt>
<dd>Style of links of 'root-to-root' type.<br>
Ignored if <code>uniform_link_style</code> is <code>True</code></dd>
</dl>
<p>Any other keyword arguments in igraph.plot can be directly used.<br>
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a> <br>
If they are given, they override the above parameters.<br></p>
<h2 id="returns">Returns</h2>
<p>fig, ax : matplotlib Figure and Axes object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_fusion_network(self, **kwargs):
    &#34;&#34;&#34;
    Plot the fusion network.

    Parameters
    ----------
    ax : None or matplotlib Axes object (default: None)
        If given, the figure is plotted on the given `Axes` object.

    layout : str (default: &#39;auto&#39;)
        Layout algorithm for plotting.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

    figsize : 2-tuple of float (default: (7, 7))
        Size of the figure in inches.

    show_node_name : bool (default: True)
        Whether to show node names.

    node_color_normal : str (default: &#39;white&#39;)
        Color of nodes without Clifford operations.

    node_color_clifford : str (default: &#39;orange&#39;)
        Color of nodes with Clifford operations.

    show_link_name : bool (default: False)
        Whether to show link names.

    show_fusion_order : bool (default: True)
        Whether to show fusion orders on links.&lt;br&gt;
        If both `show_link_name` and `show_fusion_order` are `True`,
        it is shown as `&#39;{link name}-{fusion order}&#39;`

    uniform_link_style : bool (default: False)
        Whether to use uniform link colors/styles or not.
        If it is `False`, links of different types (leaf-to-leaf,
        root-to-leaf, root-to-root) are drawn in different colors and
        linestyles. Specifically, root-to-leaf links are drawn as lines
        with arrows.

    link_color_ll : str (default: &#39;black&#39;)
        Color of links of &#39;leaf-to-leaf&#39; type.&lt;br&gt;
        Ignored if `uniform_link_style` is `True`

    link_color_rl : str (default: &#39;blue&#39;)
        Color of links of &#39;root-to-leaf&#39; type.&lt;br&gt;
        Ignored if `uniform_link_style` is `True`

    link_color_rr : str (default: &#39;red&#39;)
        Color of links of &#39;root-to-root&#39; type.&lt;br&gt;
        Ignored if `uniform_link_style` is `True`

    link_style_ll : str (default: &#39;-&#39;)
        Style of links of &#39;leaf-to-leaf&#39; type.&lt;br&gt;
        Ignored if `uniform_link_style` is `True`

    link_style_rl : str (default: &#39;-&#39;)
        Style of links of &#39;root-to-leaf&#39; type.&lt;br&gt;
        Ignored if `uniform_link_style` is `True`

    link_style_rr : str (default: &#39;--&#39;)
        Style of links of &#39;root-to-root&#39; type.&lt;br&gt;
        Ignored if `uniform_link_style` is `True`

    Any other keyword arguments in igraph.plot can be directly used.&lt;br&gt;
    See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
    If they are given, they override the above parameters.&lt;br&gt;

    Returns
    -------
    fig, ax : matplotlib Figure and Axes object.
    &#34;&#34;&#34;

    network = self.fusion_network
    if network is None:
        raise ValueError(&#39;No fusion network created.&#39;)

    fig, ax = plot_fusion_network(network, **kwargs)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.plot_graph"><code class="name flex">
<span>def <span class="ident">plot_graph</span></span>(<span>self, unraveled=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the original or unraveled graph.</p>
<p>If the unraveled graph is plotted, edges in the unraveled graph are
drawn as black solid lines while external fusions are drawn as red
dashed lines (by default).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unraveled</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to plot the unraveled graph or the original graph.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>None</code> or <code>matplotlib Axes object (default: None)</code></dt>
<dd>If given, the figure is plotted on the given <code>Axes</code> object.</dd>
<dt><strong><code>layout</code></strong> :&ensp;<code>str (default: 'auto')</code></dt>
<dd>Layout algorithm for plotting.<br>
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a></dd>
<dt><strong><code>figsize</code></strong> :&ensp;<code>2-tuple</code> of <code>float (default: (7, 7))</code></dt>
<dd>Size of the figure in inches.</dd>
<dt><strong><code>show_vertex_name</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to show vertex names.</dd>
<dt><strong><code>vertex_color_normal</code></strong> :&ensp;<code>str (default: 'white')</code></dt>
<dd>Color of vertices without Clifford operations.</dd>
<dt><strong><code>vertex_color_clifford</code></strong> :&ensp;<code>str (default: 'orange')</code></dt>
<dd>Color of vertices with Clifford operations.</dd>
<dt><strong><code>vertices_to_highlight</code></strong> :&ensp;<code>None</code> or <code>list</code> of <code>{str</code> or <code>int} (default: None)</code></dt>
<dd>Name of vertices to highlight.</dd>
<dt><strong><code>vertex_color_highlight</code></strong> :&ensp;<code>str (default: purple)</code></dt>
<dd>Color of the highlighted vertices.<br>
Ignored if <code>vertices_to_highlight</code> is <code>None</code>.</dd>
<dt><strong><code>edge_color_normal</code></strong> :&ensp;<code>str (default: black)</code></dt>
<dd>Color of edges in the graph.</dd>
<dt><strong><code>edge_color_fusion</code></strong> :&ensp;<code>str (default: red)</code></dt>
<dd>Color of lines for external fusions.<br>
Ignored if <code>unraveled</code> is <code>False</code>.</dd>
<dt><strong><code>edge_style_fusion</code></strong> :&ensp;<code>str (default: '--')</code></dt>
<dd>Style of lines for external fusions.</dd>
</dl>
<p>Any other keyword arguments in <code>igraph.plot()</code> can be directly used.<br>
See <a href="https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting">https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting</a> <br>
If they are given, they override the above parameters.</p>
<h2 id="returns">Returns</h2>
<p>fig, ax : matplotlib Figure and Axes object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_graph(self, unraveled=False, **kwargs):
    &#34;&#34;&#34;
    Plot the original or unraveled graph.

    If the unraveled graph is plotted, edges in the unraveled graph are
    drawn as black solid lines while external fusions are drawn as red
    dashed lines (by default).

    Parameters
    ----------
    unraveled : bool (default: False)
        Whether to plot the unraveled graph or the original graph.

    ax : None or matplotlib Axes object (default: None)
        If given, the figure is plotted on the given `Axes` object.

    layout : str (default: &#39;auto&#39;)
        Layout algorithm for plotting.&lt;br&gt;
        See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting

    figsize : 2-tuple of float (default: (7, 7))
        Size of the figure in inches.

    show_vertex_name : bool (default: True)
        Whether to show vertex names.

    vertex_color_normal : str (default: &#39;white&#39;)
        Color of vertices without Clifford operations.

    vertex_color_clifford : str (default: &#39;orange&#39;)
        Color of vertices with Clifford operations.

    vertices_to_highlight : None or list of {str or int} (default: None)
        Name of vertices to highlight.

    vertex_color_highlight : str (default: purple)
        Color of the highlighted vertices.&lt;br&gt;
        Ignored if `vertices_to_highlight` is `None`.

    edge_color_normal : str (default: black)
        Color of edges in the graph.

    edge_color_fusion : str (default: red)
        Color of lines for external fusions.&lt;br&gt;
        Ignored if `unraveled` is `False`.

    edge_style_fusion : str (default: &#39;--&#39;)
        Style of lines for external fusions.

    Any other keyword arguments in `igraph.plot()` can be directly used.&lt;br&gt;
    See https://python.igraph.org/en/stable/tutorial.html#layouts-and-plotting &lt;br&gt;
    If they are given, they override the above parameters.

    Returns
    -------
    fig, ax : matplotlib Figure and Axes object.
    &#34;&#34;&#34;

    graph = self.unraveled_graph if unraveled else self.graph
    if graph is None:
        raise ValueError(&#34;No unraveled graph created.&#34;)

    fig, ax = plot_graph(graph, **kwargs)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.simulate"><code class="name flex">
<span>def <span class="ident">simulate</span></span>(<span>self, n_iter, p_succ=0.5, mp=False, n_procs=None, get_all_data=False, get_all_graphs=False, get_all_fusion_networks=False, unravel=True, unravel_bcs_first='random', fusion_order_strategy='weight_and_matching', seed='keep', verbose=True, pbar=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Execute the strategy for a fixed number of iterations and obtain the
best one only (by default).</p>
<p>Attributes such as <code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">GraphState.data</a></code>, <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code>, and
<code><a title="optgraphstate.GraphState.fusion_network" href="#optgraphstate.GraphState.fusion_network">GraphState.fusion_network</a></code> are updated according to the result of the best
sample.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>n_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Iteration number.</dd>
<dt><strong><code>p_succ</code></strong> :&ensp;<code>float (default: 0.5)</code></dt>
<dd>Success probability of a fusion.</dd>
<dt><strong><code>mp</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to use multiprocessing for the iterations. Package
<em>parmap</em> should be installed to use it.</dd>
<dt><strong><code>n_procs</code></strong> :&ensp;<code>None</code> or <code>int (default: None)</code></dt>
<dd>Maximal number of simultaneous processes for multiprocessing.<br>
If it is <code>None</code>, the number of CPUs is used. Ignored when <code>mp</code> is
<code>False</code>.</dd>
<dt><strong><code>get_all_data</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to obtain the data (overheads, numbers of steps, etc.) from
all samples or only the best sample.</dd>
<dt><strong><code>get_all_graphs</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to obtain the unraveled graphs from all samples or only the
best sample.</dd>
<dt><strong><code>get_all_fusion_networks</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to obtain the fusion networks from all samples or only the
best sample.</dd>
<dt><strong><code>unravel</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to unravel the graph or not.</dd>
<dt><strong><code>unravel_bcs_first</code></strong> :&ensp;<code>one</code> of <code>[True, False, 'random'] (default: 'random')</code></dt>
<dd>
<ul>
<li><code>True</code>: BCSs are unraveled first, then clqiues are unraveled.</li>
<li><code>False</code>, cliques are unraveled first, then BCSs are unraveled.</li>
<li><code>'random'</code>, the order is randomly chosen.</li>
</ul>
</dd>
<dt><strong><code>fusion_order_strategy</code></strong> :&ensp;<code>one</code> of <code>['weight', 'matching', 'weight_and_matching', 'random'] (default:</code>weight_and_matching')`</dt>
<dd>
<p>Strategy for determining the edge to contract in each step.</p>
<ul>
<li><code>'weight'</code>: Contract a random one among the edges with the
smallest weight.</li>
<li><code>'matching'</code>: Contract an edge in a maximum matching.</li>
<li><code>'weight_and_matching'</code>: Contract an edge in a maximum matching
of the subgraph of the intermediate fusion network induced by
the edges with the smallest weight.</li>
<li><code>'random'</code>: Contract a random edge.</li>
</ul>
</dd>
<dt><strong><code>seed</code></strong> :&ensp;<code>'keep'</code> or <code>None</code> or <code>int (default: 'keep')</code></dt>
<dd>
<p>Random seed.</p>
<ul>
<li><code>'keep'</code>: The seed is not initialized.</li>
<li><code>None</code>: The current time is used as the random seed.</li>
<li><code>int</code>: The given number is used as the random seed.</li>
</ul>
</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: True)</code></dt>
<dd>Whether to print logs.</dd>
<dt><strong><code>pbar</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to show a progress bar.<br>
Ignored if <code>mp</code> is <code>False</code></dd>
<dt><strong><code>kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>Additional keyword arguments for calculating overheads.<br>
See the description of <code><a title="optgraphstate.GraphState.calculate_overhead" href="#optgraphstate.GraphState.calculate_overhead">GraphState.calculate_overhead()</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>res</code></strong> :&ensp;<code>dict</code></dt>
<dd>Result of the iterations.<br>
By default, only the information of the best sample is given.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate(self,
             n_iter,
             p_succ=0.5,
             mp=False,
             n_procs=None,
             get_all_data=False,
             get_all_graphs=False,
             get_all_fusion_networks=False,
             unravel=True,
             unravel_bcs_first=&#39;random&#39;,
             fusion_order_strategy=&#39;weight_and_matching&#39;,
             seed=&#39;keep&#39;,
             verbose=True,
             pbar=False,
             **kwargs):
    &#34;&#34;&#34;
    Execute the strategy for a fixed number of iterations and obtain the
    best one only (by default).

    Attributes such as `GraphState.data`, `GraphState.unraveled_graph`, and
    `GraphState.fusion_network` are updated according to the result of the best
    sample.

    Parameters
    ----------
    n_iter : int
        Iteration number.

    p_succ : float (default: 0.5)
        Success probability of a fusion.

    mp : bool (default: False)
        Whether to use multiprocessing for the iterations. Package
        *parmap* should be installed to use it.

    n_procs : None or int (default: None)
        Maximal number of simultaneous processes for multiprocessing.&lt;br&gt;
        If it is `None`, the number of CPUs is used. Ignored when `mp` is
        `False`.

    get_all_data : bool (default: False)
        Whether to obtain the data (overheads, numbers of steps, etc.) from
        all samples or only the best sample.

    get_all_graphs : bool (default: False)
        Whether to obtain the unraveled graphs from all samples or only the
        best sample.

    get_all_fusion_networks : bool (default: False)
        Whether to obtain the fusion networks from all samples or only the
        best sample.

    unravel : bool (default: True)
        Whether to unravel the graph or not.

    unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
        - `True`: BCSs are unraveled first, then clqiues are unraveled.
        - `False`, cliques are unraveled first, then BCSs are unraveled.
        - `&#39;random&#39;`, the order is randomly chosen.

    fusion_order_strategy : one of [&#39;weight&#39;, &#39;matching&#39;, &#39;weight_and_matching&#39;, &#39;random&#39;] (default: `weight_and_matching&#39;)
        Strategy for determining the edge to contract in each step.

        - `&#39;weight&#39;`: Contract a random one among the edges with the
        smallest weight.
        - `&#39;matching&#39;`: Contract an edge in a maximum matching.
        - `&#39;weight_and_matching&#39;`: Contract an edge in a maximum matching
        of the subgraph of the intermediate fusion network induced by
        the edges with the smallest weight.
        - `&#39;random&#39;`: Contract a random edge.

    seed : &#39;keep&#39; or None or int (default: &#39;keep&#39;)
        Random seed.

        - `&#39;keep&#39;`: The seed is not initialized.
        - `None`: The current time is used as the random seed.
        - `int`: The given number is used as the random seed.

    verbose : bool (default: True)
        Whether to print logs.

    pbar : bool (default: False)
        Whether to show a progress bar.&lt;br&gt;
        Ignored if `mp` is `False`

    kwargs : dict
        Additional keyword arguments for calculating overheads.&lt;br&gt;
        See the description of `GraphState.calculate_overhead()`.

    Returns
    -------
    res : dict
        Result of the iterations.&lt;br&gt;
        By default, only the information of the best sample is given.
    &#34;&#34;&#34;

    t0 = time.time()

    if seed != &#39;keep&#39;:
        np.random.seed(seed)

    if mp:
        if n_procs is None:
            n_procs = os.cpu_count()
        mp = mp and n_iter &gt;= n_procs

    if not mp:
        if verbose:
            print(&#34;Multiprocessing OFF.&#34;)
            print(f&#34;Calculating for n_iter = {n_iter}...&#34;)

        if n_iter == 1 and seed is not None and seed != &#39;keep&#39;:
            seeds_samples = [seed]
        else:
            seeds_samples = np.random.randint(0, _max_seed(), size=n_iter)

        overheads = [] if get_all_data else None
        steps = [] if get_all_data else None
        seeds = [] if get_all_data else None
        unravalled_graphs = [] if get_all_graphs else None
        fusion_networks = [] if get_all_fusion_networks else None

        best_sample = None
        lowest_overhead = None
        for i_sample in range(n_iter):
            seed_sample = seeds_samples[i_sample]
            np.random.seed(seed_sample)

            if unravel:
                self.unraveled_graph = None
                try:
                    self.unravel_graph(unravel_bcs_first=unravel_bcs_first)
                except:
                    print(&#39;Error occurs during unraveling&#39;)
                    print(&#39;seed =&#39;, seed_sample)
                    raise ValueError

            try:
                self.build_fusion_network(use_unraveled_graph=unravel)
            except:
                print(&#39;Error occurs during building fusion network&#39;)
                print(&#39;seed =&#39;, seed_sample)
                raise ValueError

            try:
                data_now = self.calculate_overhead(p_succ=p_succ,
                                                   strategy=fusion_order_strategy,
                                                   **kwargs)
            except:
                print(&#39;Error occurs during calculating overhead&#39;)
                print(&#39;seed =&#39;, seed_sample)
                raise ValueError

            overhead_now = data_now[&#39;overhead&#39;]
            step_now = data_now[&#39;step&#39;]
            self.data[&#39;seed&#39;] = seed_sample

            if lowest_overhead is None or overhead_now &lt; lowest_overhead:
                best_sample = i_sample
                lowest_overhead = overhead_now
                best_ogs = self.copy()

            if get_all_data:
                overheads.append(overhead_now)
                steps.append(step_now)
                seeds.append(seed_sample)

            if get_all_graphs:
                unravalled_graphs.append(self.unraveled_graph)

            if get_all_fusion_networks:
                fusion_networks.append(self.fusion_network)

        res = {
            &#39;best_overhead&#39;: best_ogs.data[&#39;overhead&#39;],
            &#39;best_step&#39;: best_ogs.data[&#39;step&#39;],
            &#39;best_seed&#39;: best_ogs.data[&#39;seed&#39;],
            &#39;n_iter&#39;: n_iter}

        if unravel:
            res[&#39;unravel_bcs_first&#39;] = best_ogs.data[&#39;unravel_bcs_first&#39;]

        if get_all_data or get_all_graphs or get_all_fusion_networks:
            res[&#39;best_sample&#39;] = best_sample

            if get_all_data:
                res[&#39;overheads&#39;] = overheads
                res[&#39;steps&#39;] = steps
                res[&#39;seeds&#39;] = seeds

            if get_all_graphs:
                res[&#39;unraveled_graphs&#39;] = unravalled_graphs

            if get_all_fusion_networks:
                res[&#39;fusion_networks&#39;] = fusion_networks

    else:
        if &#39;parmap&#39; not in sys.modules:
            raise ModuleNotFoundError(&#34;Package parmap is not installed.&#34;)

        if verbose:
            print(f&#34;Multiprocessing ON: n_procs = {n_procs}&#34;)
            print(f&#34;Calculating for n_iter = {n_iter}... &#34;, end=&#39;&#39;)

        additional_keys = []
        if get_all_data:
            additional_keys.extend([&#39;overheads&#39;, &#39;steps&#39;, &#39;seeds&#39;])
        if get_all_graphs:
            additional_keys.append(&#39;unraveled_graphs&#39;)
        if get_all_fusion_networks:
            additional_keys.append(&#39;fusion_networks&#39;)

        left = n_iter % n_procs
        ns_samples = [n_iter // n_procs] * n_procs
        for i in range(left):
            ns_samples[i] += 1

        seeds = np.random.randint(0, _max_seed(), size=n_procs)

        res_procs = parmap.starmap(_simulate_single,
                                   list(zip(ns_samples, seeds)),
                                   self.graph,
                                   p_succ=p_succ,
                                   get_all_data=get_all_data,
                                   get_all_graphs=get_all_graphs,
                                   get_all_fusion_networks=get_all_fusion_networks,
                                   unravel=unravel,
                                   unravel_bcs_first=unravel_bcs_first,
                                   fusion_order_strategy=fusion_order_strategy,
                                   pm_pbar=pbar,
                                   **kwargs)
        best_overheads = [res_each[&#39;best_overhead&#39;] for res_each in
                          res_procs]
        best_proc = np.argmin(best_overheads)
        res = res_procs[best_proc]
        res[&#39;n_iter&#39;] = n_iter
        best_ogs = res[&#39;best_ogs&#39;]
        del res[&#39;best_ogs&#39;]

        if additional_keys:
            res[&#39;best_sample&#39;] += sum(ns_samples[:best_proc])

        for key in additional_keys:
            vals = [res_each[key] for res_each in res_procs]
            res[key] = list(itertools.chain(*vals))

    if verbose:
        print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} &#34;
              f&#34;({time.time() - t0:.2f} s)&#34;)

    self.unraveled_graph = best_ogs.unraveled_graph
    self.fusion_network = best_ogs.fusion_network
    self.unraveled_bcss = best_ogs.unraveled_bcss
    self.unraveled_cliques = best_ogs.unraveled_cliques
    self.data = best_ogs.data

    return res</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.simulate_adaptive"><code class="name flex">
<span>def <span class="ident">simulate_adaptive</span></span>(<span>self, init_n_iter, mul=2, p_succ=0.5, mp=False, n_procs=None, get_all_data=False, get_all_graphs=False, get_all_fusion_networks=False, unravel=True, unravel_bcs_first='random', fusion_order_strategy='weight_and_matching', seed='keep', verbose=True, pbar=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Run the adaptive iteration method for the strategy and obtain the
best one only (by default).</p>
<p>The adaptive iteration method looks for the best iteration while
keeps increasing the iteration number until a certain condition
meets. In detail, denoting N iterations of the strategy as R(N),
R(<code>init_n_iter</code>) is first executed and <code>q0</code> is obtained which is the
lowest resource overhead. Then, R(<code>mul</code>*<code>init_n_iter</code>) is executed
and <code>q1</code> is obtained similarly. If <code>q0 &lt;= q1</code>, <code>q0</code> is returned. If
otherwise, R(<code>mul**2*init_n_iter</code>) is executed and <code>q2</code> is obtained.
If <code>q1 &lt;= q2</code>, <code>q1</code> is returned. If otherwise, R(<code>mul**3*init_n_iter</code>)
is executed, and so on.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>init_n_iter</code></strong> :&ensp;<code>int</code></dt>
<dd>Initial iteration number.</dd>
<dt><strong><code>mul</code></strong> :&ensp;<code>int (default: 2)</code></dt>
<dd>Multiplicative factor of the iteration number.</dd>
</dl>
<p>See the description of <code><a title="optgraphstate.GraphState.simulate" href="#optgraphstate.GraphState.simulate">GraphState.simulate()</a></code> for the other parameters.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>res</code></strong> :&ensp;<code>dict</code></dt>
<dd>Result of the iterations.<br>
By default, only the information of the best sample is given.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_adaptive(self,
                      init_n_iter,
                      mul=2,
                      p_succ=0.5,
                      mp=False,
                      n_procs=None,
                      get_all_data=False,
                      get_all_graphs=False,
                      get_all_fusion_networks=False,
                      unravel=True,
                      unravel_bcs_first=&#39;random&#39;,
                      fusion_order_strategy=&#39;weight_and_matching&#39;,
                      seed=&#39;keep&#39;,
                      verbose=True,
                      pbar=False,
                      **kwargs):
    &#34;&#34;&#34;
    Run the adaptive iteration method for the strategy and obtain the
    best one only (by default).

    The adaptive iteration method looks for the best iteration while
    keeps increasing the iteration number until a certain condition
    meets. In detail, denoting N iterations of the strategy as R(N),
    R(`init_n_iter`) is first executed and `q0` is obtained which is the
    lowest resource overhead. Then, R(`mul`*`init_n_iter`) is executed
    and `q1` is obtained similarly. If `q0 &lt;= q1`, `q0` is returned. If
    otherwise, R(`mul**2*init_n_iter`) is executed and `q2` is obtained.
    If `q1 &lt;= q2`, `q1` is returned. If otherwise, R(`mul**3*init_n_iter`)
    is executed, and so on.

    Parameters
    ----------
    init_n_iter : int
        Initial iteration number.

    mul : int (default: 2)
        Multiplicative factor of the iteration number.

    See the description of `GraphState.simulate()` for the other parameters.

    Returns
    -------
    res : dict
        Result of the iterations.&lt;br&gt;
        By default, only the information of the best sample is given.
    &#34;&#34;&#34;

    if mp and n_procs is None:
        n_procs = os.cpu_count()

    if seed != &#39;keep&#39;:
        np.random.seed(seed)

    additional_keys = []
    if get_all_data:
        additional_keys.extend([&#39;overheads&#39;, &#39;steps&#39;])
    if get_all_graphs:
        additional_keys.append(&#39;unraveled_graphs&#39;)
    if get_all_fusion_networks:
        additional_keys.append(&#39;fusion_networks&#39;)

    if verbose:
        if mp:
            print(f&#34;Multiprocessing (n_procs = {n_procs})&#34;)
        else:
            print(&#34;No multiprocessing&#34;)

    n_iter_history = []
    n_iter_now = init_n_iter
    res = None
    while True:
        if verbose:
            print(f&#34;Calculating for n_iter = {n_iter_now}... &#34;, end=&#39;&#39;)
        t0 = time.time()

        n_iter_history.append(n_iter_now)
        res_now = self.simulate(n_iter=n_iter_now,
                                p_succ=p_succ,
                                mp=mp,
                                n_procs=n_procs,
                                get_all_data=get_all_data,
                                get_all_graphs=get_all_graphs,
                                get_all_fusion_networks=get_all_fusion_networks,
                                unravel=unravel,
                                unravel_bcs_first=unravel_bcs_first,
                                fusion_order_strategy=fusion_order_strategy,
                                verbose=False,
                                pbar=pbar,
                                **kwargs)

        if res is None:
            res = res_now
            best_ogs = self.copy()
            n_iter_now *= mul

        else:
            for key in additional_keys:
                res[key].extend(res_now[key])

            if res_now[&#39;best_overhead&#39;] &lt; res[&#39;best_overhead&#39;]:
                for key in additional_keys:
                    res_now[key] = res[key]
                res = res_now
                best_ogs = self.copy()

                n_iter_now *= mul

            else:
                if verbose:
                    print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} (&#34;
                          f&#34;{time.time() - t0:.2f} s)&#34;)
                break

        if verbose:
            print(f&#34;Done. Best: {res[&#39;best_overhead&#39;]:.2f} &#34;
                  f&#34;({time.time() - t0:.2f} s)&#34;)

    res[&#39;n_iter&#39;] = sum(n_iter_history)

    if additional_keys:
        res[&#39;best_sample&#39;] += res[&#39;best_sample&#39;]

    self.unraveled_graph = best_ogs.unraveled_graph
    self.fusion_network = best_ogs.fusion_network
    self.unraveled_bcss = best_ogs.unraveled_bcss
    self.unraveled_cliques = best_ogs.unraveled_cliques
    self.data = best_ogs.data

    return res</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.unravel_bipartitely_complete_subgraphs"><code class="name flex">
<span>def <span class="ident">unravel_bipartitely_complete_subgraphs</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unravel bipartitely-complete subgraphs (BCSs) of the graph.</p>
<p>The unraveled graph is saved in <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code> as
<code>igraph.Graph</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs and plot the intermediate graphs during
the unraveling process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bcss</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>2-tuple</code> of <code>list</code> of <code>str</code></dt>
<dd>Data on unraveled BCSs.<br>
See the description of <code><a title="optgraphstate.GraphState.unravel_graph" href="#optgraphstate.GraphState.unravel_graph">GraphState.unravel_graph()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unravel_bipartitely_complete_subgraphs(self, verbose=False):
    &#34;&#34;&#34;
    Unravel bipartitely-complete subgraphs (BCSs) of the graph.

    The unraveled graph is saved in `GraphState.unraveled_graph` as
    `igraph.Graph`.

    Parameters
    ----------
    verbose : bool (default: False)
        Whether to print logs and plot the intermediate graphs during
        the unraveling process.

    Returns
    -------
    bcss : list of list of 2-tuple of list of str
        Data on unraveled BCSs.&lt;br&gt;
        See the description of `GraphState.unravel_graph()`.
    &#34;&#34;&#34;

    if self.unraveled_graph is None:
        self.unraveled_graph = self.graph.copy()

    graph = self.unraveled_graph

    vs_attrs = graph.vs.attributes()
    if &#39;ext_fusion&#39; not in vs_attrs:
        graph.vs[&#39;ext_fusion&#39;] = None
    if &#39;clifford&#39; not in vs_attrs:
        graph.vs[&#39;clifford&#39;] = None

    unraveled_bcss = []

    new_vertex_name = graph.vcount()

    while True:
        # Repeat until there are no bipartitely-complete subgraphs
        bcs_exist = False
        while True:
            bcss = find_nonoverlapping_bcs(graph, get_name=True)
            if bcss:
                bcs_exist = True
            else:
                break

            unraveled_bcss.append(bcss)
            eids_to_remove = []
            for part1, part2 in bcss:
                if verbose:
                    graph.delete_edges(eids_to_remove)
                    eids_to_remove.clear()
                    print(&#39;bcs to unravel =&#39;, part1, &#39;&amp;&#39;, part2)
                    vertex_color = []
                    for v in graph.vs:
                        if v[&#39;name&#39;] in part1:
                            vertex_color.append(&#39;orange&#39;)
                        elif v[&#39;name&#39;] in part2:
                            vertex_color.append(&#39;blue&#39;)
                        else:
                            vertex_color.append(&#39;white&#39;)
                    self.plot_graph(unraveled=True,
                                    vertex_color=vertex_color)
                    plt.show()

                eids_to_remove.extend([graph.get_eid(vname1, vname2) for
                                       vname1, vname2 in
                                       itertools.product(part1, part2)])

                vname1 = str(new_vertex_name)
                vname2 = str(new_vertex_name + 1)
                new_v1 = graph.add_vertex(name=vname1,
                                          ext_fusion=vname2,
                                          clifford=None)
                new_v2 = graph.add_vertex(name=vname2,
                                          ext_fusion=vname1,
                                          clifford=None)
                new_vertex_name += 2

                graph.add_edges(itertools.product([new_v1], part1))
                graph.add_edges(itertools.product([new_v2], part2))

            graph.delete_edges(eids_to_remove)

        if not bcs_exist:
            break

    self.unraveled_bcss = unraveled_bcss

    return unraveled_bcss</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.unravel_cliques"><code class="name flex">
<span>def <span class="ident">unravel_cliques</span></span>(<span>self, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unravel cliques of the graph.</p>
<p>The unraveled graph is saved in <code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">GraphState.unraveled_graph</a></code> as
<code>igraph.Graph</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs and plot the intermediate graphs during
the unraveling process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cliques</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>set</code> of <code>str</code></dt>
<dd>Data on unraveled cliques.<br>
See the description of <code><a title="optgraphstate.GraphState.unravel_graph" href="#optgraphstate.GraphState.unravel_graph">GraphState.unravel_graph()</a></code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unravel_cliques(self, verbose=False):
    &#34;&#34;&#34;
    Unravel cliques of the graph.

    The unraveled graph is saved in `GraphState.unraveled_graph` as
    `igraph.Graph`.

    Parameters
    ----------
    verbose : bool (default: False)
        Whether to print logs and plot the intermediate graphs during
        the unraveling process.

    Returns
    -------
    cliques : list of list of set of str
        Data on unraveled cliques.&lt;br&gt;
        See the description of `GraphState.unravel_graph()`.
    &#34;&#34;&#34;
    if self.unraveled_graph is None:
        self.unraveled_graph = self.graph.copy()

    graph = self.unraveled_graph

    vs_attrs = graph.vs.attributes()
    if &#39;ext_fusion&#39; not in vs_attrs:
        graph.vs[&#39;ext_fusion&#39;] = None
    if &#39;clifford&#39; not in vs_attrs:
        graph.vs[&#39;clifford&#39;] = None

    unraveled_cliques = []

    def apply_clifford(v, clifford):
        org_clifford = v[&#39;clifford&#39;]
        if org_clifford is None:
            new_clifford = clifford
        else:
            new_clifford = &#39;-&#39;.join([clifford, org_clifford])
        v[&#39;clifford&#39;] = new_clifford

    while True:
        cliques = find_nonoverlapping_cliques(graph, get_name=True)

        if not cliques:
            break

        unraveled_cliques.append(cliques)

        for clique in cliques:
            if verbose:
                print(&#39;clique to unravel =&#39;, clique)
                vertex_color = [&#39;orange&#39; if vname in clique else &#39;white&#39;
                                for vname in graph.vs[&#39;name&#39;]]
                self.plot_graph(unraveled=True, vertex_color=vertex_color)
                plt.show()
            clique = list(clique)
            clique_size = len(clique)

            # Choose a vertex to apply LC
            degrees = graph.degree(clique)
            min_degree = min(degrees)
            if min_degree == clique_size - 1:
                # There exists a vertex in the clique that doesn&#39;t have
                # outer edges
                vname_LC = [vname for vname, deg in zip(clique, degrees) if
                            deg == min_degree]
                need_to_separate = False
            else:
                vname_LC = clique
                need_to_separate = True

            if len(vname_LC) &gt; 1:
                vname_LC = np.random.choice(vname_LC)
            else:
                vname_LC = vname_LC[0]
            v_LC = graph.vs.find(name=vname_LC)

            # Separate the edges (E) incident to v_LC outside the clique
            # from v_LC
            eids_to_delete = []
            if need_to_separate:
                # Vertex connected with E
                new_v1 = graph.add_vertex(name=str(graph.vcount()),
                                          clifford=v_LC[&#39;clifford&#39;],
                                          ext_fusion=v_LC[&#39;ext_fusion&#39;])

                # Vertex having an external fusion with v_LC
                new_v2 = graph.add_vertex(name=str(graph.vcount()),
                                          clifford=None,
                                          ext_fusion=v_LC[&#39;name&#39;])

                graph.add_edge(new_v1, new_v2)

                ngh_vids = graph.neighbors(vname_LC)
                for ngh_vid in ngh_vids:
                    if graph.vs[ngh_vid][&#39;name&#39;] not in clique:
                        graph.add_edge(ngh_vid, new_v1)
                        eids_to_delete.append(graph.get_eid(vname_LC,
                                                            ngh_vid))

                vname_org_ext_fusion = v_LC[&#39;ext_fusion&#39;]
                if vname_org_ext_fusion is not None:
                    v_org_ext_fusion = graph.vs.find(name=vname_org_ext_fusion)
                    v_org_ext_fusion[&#39;ext_fusion&#39;] = new_v1[&#39;name&#39;]

                v_LC[&#39;ext_fusion&#39;] = new_v2[&#39;name&#39;]

            # Apply LC
            adj_vnames = set(clique) - {vname_LC}
            apply_clifford(v_LC, &#39;R_X&#39;)
            for adj_vname in adj_vnames:
                adj_v = graph.vs.find(name=adj_vname)
                apply_clifford(adj_v, &#39;R_Z&#39;)

            new_eids_to_delete = [graph.get_eid(vname1, vname2) for
                                  vname1, vname2 in
                                  itertools.combinations(adj_vnames, r=2)]
            eids_to_delete.extend(new_eids_to_delete)
            graph.delete_edges(eids_to_delete)

    self.unraveled_cliques = unraveled_cliques

    return unraveled_cliques</code></pre>
</details>
</dd>
<dt id="optgraphstate.GraphState.unravel_graph"><code class="name flex">
<span>def <span class="ident">unravel_graph</span></span>(<span>self, unravel_bcs_first='random', plot=False, verbose=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.</p>
<p>The unraveled graph is saved in <code>self.unraveled_graph</code> as
<code>igraph.Graph</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unravel_bcs_first</code></strong> :&ensp;<code>one</code> of <code>[True, False, 'random'] (default: 'random')</code></dt>
<dd>
<ul>
<li><code>True</code>: BCSs are unraveled first, then clqiues are
unraveled.</li>
<li><code>False</code>: cliques are unraveled first, then BCSs are
unraveled.<br></li>
<li><code>'random'</code>: the order is randomly chosen.</li>
</ul>
</dd>
<dt><strong><code>plot</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to plot the unraveled graph after unraveling.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool (default: False)</code></dt>
<dd>Whether to print logs and plot the intermediate graphs during
the unraveling process.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bcss</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>2-tuple</code> of <code>list</code> of <code>str</code></dt>
<dd>Data on unraveled BCSs, which is identical with
<code><a title="optgraphstate.GraphState.unraveled_bcss" href="#optgraphstate.GraphState.unraveled_bcss">GraphState.unraveled_bcss</a></code>.<br>
<code>bcss[i][j][k][l]</code> (<code>k</code>=0 or 1) is the name of the <code>l</code>-th vertex in
the <code>k</code>-th part of the <code>j</code>-th BCS obtained by the <code>i</code>-th cycle of
finding non-overlapping BCSs.</dd>
<dt><strong><code>cliques</code></strong> :&ensp;<code>list</code> of <code>list</code> of <code>set</code> of <code>str</code></dt>
<dd>Data on unraveled cliques, which is identical with
<code><a title="optgraphstate.GraphState.unraveled_cliques" href="#optgraphstate.GraphState.unraveled_cliques">GraphState.unraveled_cliques</a></code>.<br>
<code>cliques[i][j]</code> is the set of the names of the vertices in the
<code>j</code>-th clique obtained by the <code>i</code>-th cycle of finding
non-overlapping cliques.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unravel_graph(self,
                  unravel_bcs_first=&#39;random&#39;,
                  plot=False,
                  verbose=False):
    &#34;&#34;&#34;
    Unravel bipartitely-complete subgraphs (BCSs) and cliques of the graph.

    The unraveled graph is saved in `self.unraveled_graph` as
    `igraph.Graph`.

    Parameters
    ----------
    unravel_bcs_first : one of [True, False, &#39;random&#39;] (default: &#39;random&#39;)
        - `True`: BCSs are unraveled first, then clqiues are
        unraveled.
        - `False`: cliques are unraveled first, then BCSs are
        unraveled.&lt;br&gt;
        - `&#39;random&#39;`: the order is randomly chosen.

    plot : bool (default: False)
        Whether to plot the unraveled graph after unraveling.

    verbose : bool (default: False)
        Whether to print logs and plot the intermediate graphs during
        the unraveling process.

    Returns
    -------
    bcss : list of list of 2-tuple of list of str
        Data on unraveled BCSs, which is identical with
        `GraphState.unraveled_bcss`.&lt;br&gt;
        `bcss[i][j][k][l]` (`k`=0 or 1) is the name of the `l`-th vertex in
        the `k`-th part of the `j`-th BCS obtained by the `i`-th cycle of
        finding non-overlapping BCSs.

    cliques : list of list of set of str
        Data on unraveled cliques, which is identical with
        `GraphState.unraveled_cliques`.&lt;br&gt;
        `cliques[i][j]` is the set of the names of the vertices in the
        `j`-th clique obtained by the `i`-th cycle of finding
        non-overlapping cliques.
    &#34;&#34;&#34;

    if unravel_bcs_first == &#39;random&#39;:
        unravel_bcs_first = np.random.choice([True, False])

    if unravel_bcs_first:
        bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)
        cliques = self.unravel_cliques(verbose=verbose)
    else:
        cliques = self.unravel_cliques(verbose=verbose)
        bcss = self.unravel_bipartitely_complete_subgraphs(verbose=verbose)

    if plot or verbose:
        if verbose:
            print(&#39;[Final]&#39;)
        self.plot_graph(unraveled=True)
        plt.show()

    self.data[&#39;unravel&#39;] = True
    self.data[&#39;unravel_bcs_first&#39;] = unravel_bcs_first

    return self.unraveled_graph, bcss, cliques</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="optgraphstate.graph_tools" href="graph_tools.html">optgraphstate.graph_tools</a></code></li>
<li><code><a title="optgraphstate.utils" href="utils.html">optgraphstate.utils</a></code></li>
<li><code><a title="optgraphstate.visualization" href="visualization.html">optgraphstate.visualization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="optgraphstate.GraphState" href="#optgraphstate.GraphState">GraphState</a></code></h4>
<ul class="">
<li><code><a title="optgraphstate.GraphState.build_fusion_network" href="#optgraphstate.GraphState.build_fusion_network">build_fusion_network</a></code></li>
<li><code><a title="optgraphstate.GraphState.calculate_overhead" href="#optgraphstate.GraphState.calculate_overhead">calculate_overhead</a></code></li>
<li><code><a title="optgraphstate.GraphState.copy" href="#optgraphstate.GraphState.copy">copy</a></code></li>
<li><code><a title="optgraphstate.GraphState.data" href="#optgraphstate.GraphState.data">data</a></code></li>
<li><code><a title="optgraphstate.GraphState.fusion_network" href="#optgraphstate.GraphState.fusion_network">fusion_network</a></code></li>
<li><code><a title="optgraphstate.GraphState.graph" href="#optgraphstate.GraphState.graph">graph</a></code></li>
<li><code><a title="optgraphstate.GraphState.graph_info" href="#optgraphstate.GraphState.graph_info">graph_info</a></code></li>
<li><code><a title="optgraphstate.GraphState.group_links_by_steps" href="#optgraphstate.GraphState.group_links_by_steps">group_links_by_steps</a></code></li>
<li><code><a title="optgraphstate.GraphState.initialize" href="#optgraphstate.GraphState.initialize">initialize</a></code></li>
<li><code><a title="optgraphstate.GraphState.plot_fusion_network" href="#optgraphstate.GraphState.plot_fusion_network">plot_fusion_network</a></code></li>
<li><code><a title="optgraphstate.GraphState.plot_graph" href="#optgraphstate.GraphState.plot_graph">plot_graph</a></code></li>
<li><code><a title="optgraphstate.GraphState.simulate" href="#optgraphstate.GraphState.simulate">simulate</a></code></li>
<li><code><a title="optgraphstate.GraphState.simulate_adaptive" href="#optgraphstate.GraphState.simulate_adaptive">simulate_adaptive</a></code></li>
<li><code><a title="optgraphstate.GraphState.unravel_bipartitely_complete_subgraphs" href="#optgraphstate.GraphState.unravel_bipartitely_complete_subgraphs">unravel_bipartitely_complete_subgraphs</a></code></li>
<li><code><a title="optgraphstate.GraphState.unravel_cliques" href="#optgraphstate.GraphState.unravel_cliques">unravel_cliques</a></code></li>
<li><code><a title="optgraphstate.GraphState.unravel_graph" href="#optgraphstate.GraphState.unravel_graph">unravel_graph</a></code></li>
<li><code><a title="optgraphstate.GraphState.unraveled_bcss" href="#optgraphstate.GraphState.unraveled_bcss">unraveled_bcss</a></code></li>
<li><code><a title="optgraphstate.GraphState.unraveled_cliques" href="#optgraphstate.GraphState.unraveled_cliques">unraveled_cliques</a></code></li>
<li><code><a title="optgraphstate.GraphState.unraveled_graph" href="#optgraphstate.GraphState.unraveled_graph">unraveled_graph</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>